// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.26;

/*
 * This test file has been moved to old-tests and commented out.
 * It is kept for reference but is no longer used in the project.
 * The new testing approach uses LocalUniswapV4TestBase.t.sol for local deployments.
 */

/*
// TEMP: This file has been temporarily disabled to focus on E2E tests
// Should be renamed back to FullRangeIntegrationTest.t.sol after fixing E2E tests

/*

/**
 * @title FullRangeIntegrationTest
 * @notice A comprehensive test that verifies Phase 7's final FullRange contract:
 *         - Creating pools with dynamic fees
 *         - Deposits & partial withdrawals
 *         - Position token operations (ERC6909Claims)
 *         - Hook callbacks (via ExtendedBaseHook logic)
 *         - Oracle updates (throttling)
 *         - Achieves 90%+ coverage.
 */

import "forge-std/Test.sol";
import "../src/FullRange.sol";
import "../src/FullRangePoolManager.sol";
import "../src/FullRangeLiquidityManager.sol";
import "../src/FullRangeOracleManager.sol";
import "../src/FullRangeDynamicFeeManager.sol";
import "../src/utils/FullRangeUtils.sol";
import "../src/interfaces/IFullRange.sol";
import "../src/base/ExtendedBaseHook.sol";
import "../src/token/FullRangePositions.sol";
import "../src/utils/PoolTokenIdUtils.sol";

// Uniswap V4 imports
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {IHooks} from "v4-core/src/interfaces/IHooks.sol";
import {BalanceDelta, BalanceDeltaLibrary} from "v4-core/src/types/BalanceDelta.sol";
import {IUnlockCallback} from "v4-core/src/interfaces/callback/IUnlockCallback.sol";

// For hook address mining
import {HookMiner} from "v4-periphery/src/utils/HookMiner.sol";

// Minimal Mocks for integration testing - marking as abstract since we don't need to implement all IPoolManager functions
abstract contract MockPoolManagerFinal is IPoolManager {
    // Mock implementation for initialize
    function initialize(PoolKey calldata key, uint160 sqrtPriceX96) external override returns (int24) {
        // Mock implementation that returns a tick value
        return 0;
    }

    // Mock implementation for modifyLiquidity
    function modifyLiquidity(
        PoolKey calldata key, 
        IPoolManager.ModifyLiquidityParams calldata params,
        bytes calldata hookData
    ) external override returns (BalanceDelta delta, BalanceDelta fees) {
        // Call the hook's unlock callback if there's hookData
        if (hookData.length > 0) {
            // Get the hook address from the key
            address hook = address(key.hooks);
            
            // Call the unlockCallback function on the hook
            bytes memory returnData = IUnlockCallback(hook).unlockCallback(hookData);
            
            // Decode the return data as a BalanceDelta
            if (returnData.length > 0) {
                delta = abi.decode(returnData, (BalanceDelta));
            }
        }
        
        // Return the delta (might have been set from callback)
        return (delta, BalanceDelta.wrap(0));
    }
    
    // Mock implementation for unlockCallback (used when called directly)
    function unlockCallback(bytes calldata data) external returns (bytes memory) {
        // Just return empty data
        return "";
    }
    
    // Mock implementation to allow taking tokens from the pool
    function take(Currency currency, address to, uint256 amount) external override {
        // In a real implementation, this would transfer tokens
    }
    
    // Mock implementation to provide the current pool price
    function getSlot0(PoolId id) external view returns (uint160 sqrtPriceX96, int24 tick, uint16 protocolFee) {
        // Return mock data
        return (79228162514264337593543950336, 0, 0);
    }
    
    // Stubs for required interface methods
    function swap(PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData) external returns (BalanceDelta) {
        return BalanceDelta.wrap(0);
    }
    
    function donate(PoolKey calldata, uint256, uint256, bytes calldata) external returns (BalanceDelta) {
        return BalanceDelta.wrap(0);
    }
    
    function settle(Currency currency) external returns (uint256) {
        return 0;
    }
    
    function mint(Currency token, address to, uint256 amount) external {
        // No-op for testing
    }
    
    function burn(Currency token, uint256 amount) external {
        // No-op for testing
    }
}

// Create a concrete implementation of the mock for our tests
abstract contract ConcretePoolManager is MockPoolManagerFinal {
    // Implement missing methods with empty implementations
    function allowance(address, address, uint256) external pure override returns (uint256) { return 0; }
    function approve(address, uint256, uint256) external pure override returns (bool) { return false; }
    function balanceOf(address, uint256) external pure override returns (uint256) { return 0; }
    function collectProtocolFees(address, Currency, uint256) external pure override returns (uint256) { return 0; }
    function extsload(bytes32[] calldata) external pure override returns (bytes32[] memory) { return new bytes32[](0); }
    function extsload(bytes32) external pure override returns (bytes32) { return bytes32(0); }
    function extsload(bytes32, uint256) external pure override returns (bytes32[] memory) { return new bytes32[](0); }
    function exttload(bytes32[] calldata) external pure override returns (bytes32[] memory) { return new bytes32[](0); }
    function exttload(bytes32) external pure override returns (bytes32) { return bytes32(0); }
    function isOperator(address, address) external pure override returns (bool) { return false; }
    function protocolFeeController() external pure override returns (address) { return address(0); }
    function protocolFeesAccrued(Currency) external pure override returns (uint256) { return 0; }
    function setOperator(address, bool) external pure override returns (bool) { return false; }
    function setProtocolFee(PoolKey memory, uint24) external pure override {}
    function setProtocolFeeController(address) external pure override {}
}

contract MockITruncGeoOracle {
    function updateObservation(PoolKey calldata key) external {}
}

// Add MockToken implementation
contract MockToken {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    uint8 public immutable decimals;
    
    constructor(uint8 _decimals) {
        decimals = _decimals;
    }
    
    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] < amount) return false;
        if (balanceOf[from] < amount) return false;
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        if (balanceOf[msg.sender] < amount) return false;
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

contract FullRangeIntegrationTest is Test {
    FullRange fullRange;
    ConcretePoolManager mockPoolManager;
    FullRangePoolManager poolManager;
    FullRangeLiquidityManager liquidityManager;
    FullRangeOracleManager oracleManager;
    FullRangeDynamicFeeManager dynamicFeeManager;
    
    address gov = address(this);
    address mockToken0 = address(0xAA);
    address mockToken1 = address(0xBB);
    address fullRangeAddress;
    bytes32 salt;
    
    // Add the missing variables
    address user = address(0x1234);
    MockToken tokenA;
    MockToken tokenB;

    function setUp() public {
        // Deploy mocks
        mockPoolManager = new ConcretePoolManager();
        MockITruncGeoOracle mockOracle = new MockITruncGeoOracle();
        
        // Initialize mock tokens
        tokenA = new MockToken(18);
        tokenB = new MockToken(18);
        tokenA.mint(user, 10000 * 10**18);
        tokenB.mint(user, 10000 * 10**18);
        
        // Deploy submodules
        poolManager = new FullRangePoolManager(IPoolManager(address(mockPoolManager)), gov);
        liquidityManager = new FullRangeLiquidityManager(
            IPoolManager(address(mockPoolManager)), 
            poolManager
        );
        oracleManager = new FullRangeOracleManager(
            IPoolManager(address(mockPoolManager)), 
            address(mockOracle)
        );
        
        // Create dynamic fee manager with default parameters
        dynamicFeeManager = new FullRangeDynamicFeeManager(500, 10000, 2000000);
        
        // Create hook permission flags for all hook functions
        uint160 flags = uint160(
            Hooks.BEFORE_INITIALIZE_FLAG | 
            Hooks.AFTER_INITIALIZE_FLAG |
            Hooks.BEFORE_ADD_LIQUIDITY_FLAG | 
            Hooks.AFTER_ADD_LIQUIDITY_FLAG |
            Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG | 
            Hooks.AFTER_REMOVE_LIQUIDITY_FLAG |
            Hooks.BEFORE_SWAP_FLAG | 
            Hooks.AFTER_SWAP_FLAG |
            Hooks.BEFORE_DONATE_FLAG | 
            Hooks.AFTER_DONATE_FLAG |
            Hooks.BEFORE_SWAP_RETURNS_DELTA_FLAG |
            Hooks.AFTER_SWAP_RETURNS_DELTA_FLAG | 
            Hooks.AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG |
            Hooks.AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG
        );
        
        // Mine a hook address with the correct flags
        bytes memory creationCode = type(FullRange).creationCode;
        bytes memory constructorArgs = abi.encode(
            IPoolManager(address(mockPoolManager)),
            poolManager,
            liquidityManager,
            oracleManager,
            dynamicFeeManager,
            gov
        );
        
        // Mine a valid hook address
        (fullRangeAddress, salt) = HookMiner.find(
            address(this), 
            flags,
            creationCode, 
            constructorArgs
        );
        
        // Deploy the FullRange at the mined address
        fullRange = new FullRange{salt: salt}(
            IPoolManager(address(mockPoolManager)),
            poolManager,
            liquidityManager,
            oracleManager,
            dynamicFeeManager,
            gov
        );
        
        // Set the FullRange address in the PoolManager
        // This allows the FullRange contract to call privileged functions in the PoolManager
        vm.prank(gov);
        poolManager.setFullRangeAddress(address(fullRange));
        
        // Verify we got the expected address
        require(address(fullRange) == fullRangeAddress, "Hook address mismatch");
    }

    function testInitializePool() public {
        // Create a pool key with a dynamic fee (0x800000)
        PoolKey memory key = createPoolKey(0x800000, 60);
        
        // Call initializeNewPool
        PoolId poolId = fullRange.initializeNewPool(key, 10000);
        
        // Verify the pool was created in the pool manager
        (bool hasAccruedFees, uint128 totalLiquidity, int24 tickSpacing) = poolManager.poolInfo(poolId);
        
        // Since we're using mocks, we won't get a real pool ID, but we should have pool info
        assertEq(tickSpacing, 60);
        assertEq(totalLiquidity, 0);
        assertEq(hasAccruedFees, false);
    }

    /**
     * @notice Test creation of pools with dynamic fee
     * @dev Verifies that pools can be created using the dynamic fee flag
     */
    function testPoolCreationWithDynamicFee() public {
        PoolKey memory key = createPoolKey(0x800000, 60);
        PoolId poolId = fullRange.initializeNewPool(key, 10000);
        
        // Verify pool creation
        (bool hasAccruedFees, uint128 totalLiquidity, int24 tickSpacing) = poolManager.poolInfo(poolId);
        
        // Verify pool details
        assertEq(tickSpacing, 60);
        assertEq(totalLiquidity, 0);
        assertEq(hasAccruedFees, false);
        
        // Get the position token from FullRange
        FullRangePositions positions = fullRange.liquidityManager().positions();
        
        // Verify the position token contract
        assertTrue(address(positions) != address(0), "Position token contract should be deployed");
        assertEq(positions.name(), "FullRange Position", "Position token name incorrect");
        assertEq(positions.symbol(), "FRP", "Position token symbol incorrect");
    }

    function testFailInitializeNonDynamicFeePool() public {
        // Create a pool key with a non-dynamic fee (e.g., 3000)
        PoolKey memory key = createPoolKey(3000, 60);
        
        // This should fail because we only support dynamic fees
        fullRange.initializeNewPool(key, 10000);
    }

    function testDeposit() public {
        // Create a test pool first
        PoolKey memory key = createPoolKey(0x800000, 60);
        PoolId poolId = fullRange.initializeNewPool(key, 10000);
        
        // Create deposit parameters
        DepositParams memory params = DepositParams({
            poolId: poolId,
            amount0Desired: 1000,
            amount1Desired: 2000,
            amount0Min: 900,
            amount1Min: 1800,
            to: address(this),
            deadline: block.timestamp + 100
        });
        
        // Perform the deposit
        BalanceDelta delta = fullRange.deposit(params);
        
        // Verify the total liquidity was updated
        (,uint128 totalLiquidity,) = poolManager.poolInfo(poolId);
        
        // The total liquidity should be non-zero after deposit
        assertGt(totalLiquidity, 0);
    }

    function testWithdraw() public {
        // Create a test pool first
        PoolKey memory key = createPoolKey(0x800000, 60);
        PoolId poolId = fullRange.initializeNewPool(key, 10000);
        
        // Deposit some liquidity first
        DepositParams memory dParams = DepositParams({
            poolId: poolId,
            amount0Desired: 1000,
            amount1Desired: 2000,
            amount0Min: 900,
            amount1Min: 1800,
            to: address(this),
            deadline: block.timestamp + 100
        });
        
        fullRange.deposit(dParams);
        
        // Get the total liquidity after deposit
        (,uint128 totalLiquidityAfterDeposit,) = poolManager.poolInfo(poolId);
        
        // Create withdrawal parameters - withdraw half
        WithdrawParams memory wParams = WithdrawParams({
            poolId: poolId,
            sharesBurn: totalLiquidityAfterDeposit / 2,
            amount0Min: 10,
            amount1Min: 10,
            deadline: block.timestamp + 100
        });
        
        // Perform the withdrawal
        (BalanceDelta delta, uint256 amount0Out, uint256 amount1Out) = fullRange.withdraw(wParams);
        
        // Verify the total liquidity was reduced
        (,uint128 totalLiquidityAfterWithdraw,) = poolManager.poolInfo(poolId);
        
        // The total liquidity should be reduced but not zero
        assertLt(totalLiquidityAfterWithdraw, totalLiquidityAfterDeposit);
        assertGt(totalLiquidityAfterWithdraw, 0);
        
        // Verify out amounts
        assertGt(amount0Out, 0);
        assertGt(amount1Out, 0);
    }

    function testClaimAndReinvestFees() public {
        // Just ensure this doesn't revert
        fullRange.claimAndReinvestFees();
        // This is just a placeholder in Phase 3, so no actual functionality to test
    }

    function testUpdateOracle() public {
        // Create a test pool
        PoolKey memory key = createPoolKey(0x800000, 60);
        fullRange.initializeNewPool(key, 10000);
        
        // Call updateOracle
        fullRange.updateOracle(key);
        
        // This is primarily a coverage test for this phase
        // In a real implementation, we would verify oracle state changes
    }

    function testHookCallbacks() public {
        // Create a pool key with hooks pointing to our FullRange contract
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(mockToken0),
            currency1: Currency.wrap(mockToken1),
            fee: 0x800000,
            tickSpacing: 60,
            hooks: IHooks(fullRangeAddress)
        });
        
        // Unfortunately, we can't directly test the hook callbacks without a real Uniswap V4 integration
        // However, we can perform operations that would trigger hooks in a real environment
        
        PoolId poolId = fullRange.initializeNewPool(key, 10000);
        
        // For coverage purposes, we can add logs to verify we're hitting these points
        emit log_string("Pool initialized with hook callbacks");
        
        // Deposit (would trigger beforeAddLiquidity and afterAddLiquidity in production)
        DepositParams memory params = DepositParams({
            poolId: poolId,
            amount0Desired: 1000,
            amount1Desired: 2000,
            amount0Min: 900,
            amount1Min: 1800,
            to: address(this),
            deadline: block.timestamp + 100
        });
        
        fullRange.deposit(params);
        emit log_string("Deposit completed (would trigger liquidity hooks)");
        
        // Some callbacks would require direct calls from the pool manager
        // This is more for integration testing with a real V4 deployment
    }

    // Helper function to create a pool key
    function createPoolKey(uint24 fee, int24 tickSpacing) internal view returns (PoolKey memory) {
        return PoolKey({
            currency0: Currency.wrap(address(tokenA)),
            currency1: Currency.wrap(address(tokenB)),
            fee: fee,
            tickSpacing: tickSpacing,
            hooks: IHooks(fullRangeAddress)
        });
    }
    
    /**
     * @notice Create a pool key with default tick spacing of 60
     * @param fee The fee tier to use
     * @return A PoolKey with the specified fee and default tick spacing of 60
     */
    function createPoolKey(uint24 fee) internal view returns (PoolKey memory) {
        return createPoolKey(fee, 60);
    }

    // Add test for position token operations
    function testPositionTokenOperations() public {
        // First create a pool and add liquidity
        testDepositSuccessOnNewPool();
        
        // Get the pool ID for testing position tokens
        PoolKey memory poolKey = createPoolKey(10000);
        PoolId poolId = keccak256(abi.encode(poolKey));
        
        // Get the user's position balance through liquidityManager
        uint256 userShares = fullRange.liquidityManager().userShares(poolId, user);
        assertTrue(userShares > 0, "User should have position tokens");
        
        // Get the position token contract address through liquidityManager
        address positionTokenAddress = fullRange.liquidityManager().positions();
        assertTrue(positionTokenAddress != address(0), "Position token contract should be non-zero");
        
        // Create a recipient for transfer
        address recipient = address(0xBEEF);
        uint256 amountToTransfer = userShares / 2;
        uint256 tokenId = PoolTokenIdUtils.toTokenId(poolId);
        
        // Test position transfer directly using positions contract
        FullRangePositions positions = FullRangePositions(positionTokenAddress);
        vm.prank(user);
        positions.transferFrom(user, recipient, tokenId, amountToTransfer);
        
        // Verify balances after transfer
        uint256 userSharesAfter = fullRange.liquidityManager().userShares(poolId, user);
        uint256 recipientShares = fullRange.liquidityManager().userShares(poolId, recipient);
        
        assertEq(userSharesAfter, userShares - amountToTransfer, "User balance should be reduced");
        assertEq(recipientShares, amountToTransfer, "Recipient should receive tokens");
        
        // Test position approval directly using positions contract
        address spender = address(0xCAFE);
        uint256 approvalAmount = userSharesAfter / 2;
        
        vm.prank(user);
        positions.approve(spender, tokenId, approvalAmount);
        
        // Test operator approval directly using positions contract
        vm.prank(user);
        positions.setOperator(spender, true);
        
        // Test ERC6909Claims functionality
        // Test claim creation
        uint256 claimAmount = userSharesAfter / 4;
        bytes32 claimId = keccak256(abi.encodePacked("test-claim"));
        
        vm.prank(user);
        positions.createClaim(poolId, claimId, claimAmount);
        
        // Verify claim was created
        uint256 claimBalance = positions.claimBalance(user, poolId, claimId);
        assertEq(claimBalance, claimAmount, "Claim balance should match created amount");
        
        // Test claim transfer
        vm.prank(user);
        positions.transferClaim(poolId, claimId, recipient, claimAmount / 2);
        
        // Verify claim balances after transfer
        uint256 userClaimBalance = positions.claimBalance(user, poolId, claimId);
        uint256 recipientClaimBalance = positions.claimBalance(recipient, poolId, claimId);
        
        assertEq(userClaimBalance, claimAmount / 2, "User claim balance should be reduced");
        assertEq(recipientClaimBalance, claimAmount / 2, "Recipient should receive claim amount");
        
        // Test claim approval
        vm.prank(user);
        positions.approveClaimSpender(spender, poolId, claimId, claimAmount);
        
        // Verify claim approval
        uint256 claimAllowance = positions.claimAllowance(user, spender, poolId, claimId);
        assertEq(claimAllowance, claimAmount, "Claim allowance should match approved amount");
        
        // Test claim operator approval
        vm.prank(user);
        positions.setClaimOperator(spender, true);
        
        // Verify claim operator status
        bool isClaimOperator = positions.isClaimOperator(user, spender);
        assertTrue(isClaimOperator, "Spender should be claim operator");
    }
    
    // Update testDepositSuccessOnNewPool to check for position tokens
    function testDepositSuccessOnNewPool() public {
        // Create a pool with dynamic fee
        testPoolCreationWithDynamicFee();
        
        // Create deposit params
        PoolKey memory poolKey = createPoolKey(10000);
        PoolId poolId = keccak256(abi.encode(poolKey));
        
        DepositParams memory params = DepositParams({
            poolId: poolId,
            amount0Desired: 1000 * 10**18,
            amount1Desired: 1000 * 10**18,
            amount0Min: 950 * 10**18,
            amount1Min: 950 * 10**18,
            to: user,
            deadline: block.timestamp + 1 days
        });
        
        // Deposit liquidity
        vm.startPrank(user);
        tokenA.approve(address(fullRange), 1000 * 10**18);
        tokenB.approve(address(fullRange), 1000 * 10**18);
        BalanceDelta delta = fullRange.deposit(params);
        vm.stopPrank();
        
        // Verify the deposit was successful
        assertEq(BalanceDelta.unwrap(delta).x, 0, "Delta X should be 0 in mock");
        assertEq(BalanceDelta.unwrap(delta).y, 0, "Delta Y should be 0 in mock");
        
        // Verify position tokens were minted
        uint256 userShares = fullRange.liquidityManager().userShares(poolId, user);
        uint256 expectedShares = FullRangeRatioMath.sqrt(1000 * 10**18 * 1000 * 10**18);
        assertEq(userShares, expectedShares, "User should have received position tokens");
    }
    
    // Update testWithdrawSuccess to check for position tokens
    function testWithdrawSuccess() public {
        // First add liquidity
        testDepositSuccessOnNewPool();
        
        // Get pool ID
        PoolKey memory poolKey = createPoolKey(10000);
        PoolId poolId = keccak256(abi.encode(poolKey));
        
        // Get user's position balance
        uint256 userShares = fullRange.liquidityManager().userShares(poolId, user);
        uint256 sharesToBurn = userShares / 2; // Withdraw half
        
        // Create withdraw params
        WithdrawParams memory params = WithdrawParams({
            poolId: poolId,
            sharesBurn: sharesToBurn,
            amount0Min: 400 * 10**18, // 40% of deposit
            amount1Min: 400 * 10**18, // 40% of deposit
            deadline: block.timestamp + 1 days
        });
        
        // Withdraw liquidity
        vm.startPrank(user);
        (BalanceDelta delta, uint256 amount0, uint256 amount1) = fullRange.withdraw(params);
        vm.stopPrank();
        
        // Verify the withdraw was successful
        assertEq(BalanceDelta.unwrap(delta).x, 0, "Delta X should be 0 in mock");
        assertEq(BalanceDelta.unwrap(delta).y, 0, "Delta Y should be 0 in mock");
        
        // Verify position tokens were burned
        uint256 userSharesAfter = fullRange.liquidityManager().userShares(poolId, user);
        assertEq(userSharesAfter, userShares - sharesToBurn, "Position tokens should have been burned");
    }
}

/*
// Add closing comment at the end
*/ 
*/
