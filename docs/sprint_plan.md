# AEGIS V2 Liquidity Engine – Sprint Buildout Plan

## Sprint Roadmap Table (S1–S5 by Phase P1–P5)

| **Sprint / Phase**                                  | **P1 – Code (Dev)**<br>*(Objective • Scope • Exit Criteria • Handover)*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | **P2 – Code (Dev)**<br>*(Objective • Scope • Exit Criteria • Handover)*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | **P3 – Code (Dev)**<br>*(Objective • Scope • Exit Criteria • Handover)*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | **P4 – Code (Dev)**<br>*(Objective • Scope • Exit Criteria • Handover)*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | **P5 – Tests/QA**<br>*(Objective • Scope • Exit Criteria • Handover)*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **S1**<br>*Core Liquidity*                          | **Objective:** Initialize Vault core and pool registry.<br>**Scope:** Define storage slots (0–24 fixed), deploy `VaultManagerCore` with module addresses (Oracle, Policy, PoolManager, etc.), and implement `registerPool` (first liquidity triggers pool setup with immutable `lockedShares`).<br>**Exit Criteria:** Vault can register a new Uniswap v4 pool; storage layout matches spec (CI slot-check passes); `lockedShares` set on first deposit (no function reduces it).<br>**Handover:** Baseline contract ready for deposit logic; pool metadata (IDs, NFT position) initialized for use in P2.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | **Objective:** Enable user deposits into vault (full-range LP).<br>**Scope:** Implement `deposit(poolId, amount0, amount1)` per spec. Use SpotHook authorization (require `msg.sender == authorizedHook`) to pull tokens from user, call Uniswap `PoolManager` to add liquidity, and mint ERC-6909 shares. Update `shareData.totalShares` and user’s `shareBalance`; revert on zero-amount or slippage (`SlippageFailure`).<br>**Exit Criteria:** Users can deposit assets via the hook and receive vault shares; `Deposit` event emits correct amounts. Invariants: total shares ≥ locked (enforced by never minting below locked portion). All deposit pause flags enforced (`PAUSE_DEPOSITS` checked).<br>**Handover:** Deposit function tested in isolation; groundwork for withdrawals (shares minted and tracked) in P3.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | **Objective:** Enable share redemptions (withdrawals).<br>**Scope:** Implement `withdraw(poolId, shares)` reversing deposit. Burn the specified shares from user, call `PoolManager` to remove liquidity, transfer underlying tokens to recipient. Enforce share balance check (`InsufficientShares` error), slippage minima, and pause flags. Prevent breaking locked liquidity: disallow withdrawing the last `lockedShares` (ensure post-withdraw `totalShares >= lockedShares`). If user has debt, run solvency check to block under-collateralizing withdrawals.<br>**Exit Criteria:** Users can redeem shares for tokens; `Withdraw` event logs amounts. Invariant **INV-2.1** holds: total shares never falls below locked minimum. Solvency checks stubbed (no borrowing yet, always passes).<br>**Handover:** Withdrawal logic complete for solvent accounts; sets stage for adding borrowing (will integrate debt checks in S2).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | **Objective:** Finalize core controls and minor ops.<br>**Scope:** Implement global pause/unpause (`pause(uint8)` & `unpause`) controlling bitmask flags. Tag deposit/withdraw with `whenNotPaused` (bits for deposits, withdrawals, etc.). Implement `toggleReinvest(pool, bool)` to allow/disallow auto-fee-compounding (store a flag per pool). Emit governance events (`Paused`, `Unpaused`, `ReinvestToggled`). Also, initialize BatchEngine router stub: define `executeBatch` interface to funnel calls (initially limited or noop).<br>**Exit Criteria:** Pause guardian can halt/resume vault operations (tested by toggling `pauseFlags` bits). Reinvest auto-flag persists per pool (no effect yet on logic). BatchEngine entry point exists (not yet executing actions).<br>**Handover:** System is feature-flag complete for core liquidity; ready to add lending in S2. BatchEngine stub in place to integrate atomic actions later.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | **Objective:** Validate all S1 functionality and invariants in isolation.<br>**Scope:** Unit-test pool registration, deposit, and withdrawal flows using Foundry. Simulate first deposit on a new pool (expect `PoolRegistered` + `Deposit` events), withdrawing with and without slippage, and pause toggling (deposits/withdrawals revert when paused). Test locked-share invariant: withdrawing down to locked portion is prevented. Test authorized hook guard: direct user calls to `deposit/withdraw` revert (`UnauthorizedCaller`).<br>**Exit Criteria:** All core tests pass (no regression on storage or events). Gas benchmarks recorded for basic ops (deposit \~80k, withdraw \~85k). All **INV-2.x** invariants from Appendix G applicable to S1 (locked shares, pause flags, hook auth) are enforced in code or covered by tests.<br>**Handover:** A stable core to extend with borrowing logic; S1 code reviewed and merged.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **S2**<br>*Lending & Interest*                      | **Objective:** Implement interest accrual mechanics for loans.<br>**Scope:** Add `accrueInterest(poolId)` in VaultManagerCore. On call, fetch current rate from `PolicyManager`’s interest model, ensure pool’s last accrual timestamp < now (skip or revert if clock anomaly). Compute interest factor = exp(rate \* Δt), update pool’s interest index (share index) multiplicatively. Store `lastAccrueTime`. Emit `InterestAccrued(poolId, interest)` event. Maintain invariant **INV-3.1**: index never decreases (rate ≥ 0). Gas-optimize by using one stored index per pool (slot 9).<br>**Exit Criteria:** Interest accrual updates the index correctly and only forward in time. Calling `accrueInterest` twice within same block leaves state unchanged (time Δt=0). Event logs interest added. **INV-3.2** enforced: no future timestamps or out-of-order updates.<br>**Handover:** Accurate interest indices available for borrow/repay in P2/P3; index test coverage in P5 ensures monotonic growth.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | **Objective:** Enable borrowing against deposited collateral (full-range shares).<br>**Scope:** Implement `borrow(poolId, amount, to)` (external user call). Require pool borrowing not paused (`PAUSE_BORROWS` off) and an interest model set (or revert `InterestModelUnset`). On borrow: **(1)** *Accrue interest*: call `accrueInterest` to update share index before modifying debt. **(2)** *Calculate shares*: convert `amount` of token (asset) to equivalent share count using latest index/price. **(3)** *Solvency checks*: compute user’s post-borrow Loan-to-Value using oracle prices for pool assets. Enforce collateral factor limits via PolicyManager (init ≤ maint) – if new debt exceeds allowed, revert `ExceedsInitCF` or `ExceedsMaintCF`. **(4)** *Update ledgers*: increment `userVault.borrowShares` and global `totalBorrowShares` (slot 13) by the share amount. Ensure **INV-BOR-01**: `totalBorrowShares <= totalShares` at all times (utilization cap 95% enforced: disallow borrow if would exceed U=0.95 of supply). **(5)** *Transfer out*: withdraw underlying tokens corresponding to borrowed shares from vault liquidity to `to` address. Emit `Borrow(borrower, poolId, amount)` event and record debt.<br>**Exit Criteria:** Users can borrow up to safe limits (e.g. 150% collateralization for initial, 105% maint. as per policy). Borrow reverts if insufficient collateral (`InsufficientCollateral` error). Global solvency invariant holds throughout (tracked in tests). Gas \~115k for first-time borrow meets target. Borrow events and accounting verified against expected interest index changes.<br>**Handover:** Borrow function integrated; sets stage for repayments (P3) and liquidations (S5).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **Objective:** Allow debt repayment and debt tracking cleanup.<br>**Scope:** Implement `repay(poolId, amount, onBehalf)` for borrowers or third parties (liquidators). Require interest accrued up to current block (call `accrueInterest` on target pool at function start) so that payer cannot avoid accrued interest. Determine the lesser of `amount` sent vs. debtor’s outstanding debt. If `amount` exceeds what is owed, revert `RepayTooMuch`. Pull tokens from caller (or use their idle vault balance if `onBehalf` is self and funds in vault). Convert repaid tokens to shares at current index, then decrement `userVault.borrowShares` and `totalBorrowShares` accordingly. If debt fully repaid, set user’s borrowShares=0 and emit `Repay(payer, poolId, amount)` event; also emit any interest portion as part of accrued event or via `InterestAccrued` from prior step. If user had no debt, revert `NoDebt()`.<br>**Exit Criteria:** Borrowers (or others) can repay loans fully or partially. Debt ledger consistency maintained: totalBorrowShares decreases exactly by repaid shares. Edge cases tested: repaying zero (no effect), repaying more than owed (revert), multiple partial repayments accumulate correctly. Gas \~108k on cold repay meets spec target. **INV-3.6/3.7** confirmed: borrow increases debt counts, repay reduces them exactly.<br>**Handover:** Repayment flows complete; prepares groundwork for keeper liquidations (they will invoke `repay` on victim’s behalf in S5).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | **Objective:** Introduce fee reinvestment and interest distribution to protocol liquidity (POL).<br>**Scope:** Implement `reinvestFees(poolId)` in VaultManagerCore for anyone/keeper calls. Enforce per-pool cooldown: track `lastReinvestTime` (slot 12) and require `now - lastReinvest >= minInterval` (else revert `ReinvestmentCooldown`). Also check a global `reinvestmentPaused` flag (emergency stop for compounding). On call, read accumulated `pendingFees[poolId]` (token0, token1 at slot 8); if both zero or below threshold, revert `InsufficientFees` (or skip). Otherwise, reset `pendingFees` to 0 and call `PoolManager` to add these as new liquidity (same as a deposit of fees). Calculate `sharesMinted` from fees. **Fee Split:** Determine protocol cut vs. LP cut per policy (e.g. 10% to POL). Increase `totalShares` by all minted shares, then credit protocol’s portion to `totalPolShares` (slot 21) and **do not credit** the remainder to any user (diluting existing shares). This effectively allocates most new shares to LPs collectively (boosting share value) while protocol retains its fraction internally. Update `lastReinvestTime` and emit events if applicable (e.g. a `Reinvest` event or reuse `Deposit` event for added liquidity).<br>**Exit Criteria:** Fee reinvestment compounds pool fees into new liquidity per design. After reinvest, `pendingFees` resets to zero and `totalPolShares` increases by protocol share. Validations: calling too early yields `ReinvestmentCooldown`; reinvest does nothing if no fees (or reverts if using `InsufficientFeesAccumulated`). Post-reinvest share supply and POL tracking match spec math. **INV-2.3** and **INV-2.4** upheld: pending fees cleared on reinvest, fee counters only increase between reinvest calls.<br>**Handover:** Pool fee compounding functional; sets stage for integrating this into SpotHook/auto-calls. Prepares for S5 where POL shares might be used if covering bad debt.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | **Objective:** Rigorously test borrowing, interest, and fee features under various scenarios.<br>**Scope:** Unit-test interest accrual (time-based): simulate time lapses and ensure `shareIndex` updates correctly and never shrinks. Test borrowing at limits: user with given collateral can borrow up to initCF but not beyond (expect `ExceedsInitCF`); borrowing that would push utilization >95% reverts (INV-UtilCap enforced). Verify global invariant: after each borrow/repay, `totalBorrowShares <= totalShares` holds. Test repay logic: partial and full repayment reduce debt and emit `Repay`, with `RepayTooMuch` on overpayment. Use a dummy interest model in tests to simulate rate changes and ensure interest accrual reflects it. Test reinvest: accumulate fake fees in `pendingFees`, call `reinvestFees`, and verify new shares minted, protocol share allocated (check `totalPolShares`). Confirm `pendingFees` resets and cooldown is enforced. Fuzz test a sequence: deposit, multiple accruals, borrow, repay, reinvest – check invariants (no negative balances, share monotonic, etc.).<br>**Exit Criteria:** All lending tests pass, covering normal and edge cases. Interest index growth verified against formula. **INV-3.x** invariants for lending active: borrow index monotonic, per-user and global solvency enforced via requires or tests. Gas usage within targets (borrow \~115k, repay \~108k). Continuous integration tests (Foundry invariant tests) assert that random borrow-repay sequences never violate `totalBorrowShares <= totalShares` or allow debt without collateral.<br>**Handover:** Lending subsystem stable. Proceed to integrate advanced collateral (LP NFTs) in S3.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **S3**<br>*LP Positions (NFT Collateral)*           | **Objective:** Allow users to open concentrated LP positions as vault collateral.<br>**Scope:** Implement `openLPPosition(poolKey, tickLower, tickUpper, amt0, amt1, min0, min1)`. Enforce not paused (`PAUSE_POSITIONS` flag). On call: if user has idle tokens in vault, use them first; else **internally adjust** full-range shares – withdraw required amounts from user’s FR liquidity (reduce `shareBalance`) to source tokens. Transfer up to `amt0/amt1` from user (via hook or direct if authorized) with slippage check. Call Uniswap `PositionManager.mintPosition(...)` to create a new one-sided liquidity NFT covering \[tickLower, tickUpper] using those tokens. Vault receives the NFT. Record position in storage (e.g. mapping `lpPositions[positionId]` at slot 16): map NFT ID to owner, poolId, ticks, liquidity, and fee snapshot. Update user’s collateral accounting: mark that part of their collateral is now in this NFT (their total collateral value stays \~constant). Emit `LPPositionOpened(owner, positionId, tickLower, tickUpper, liquidity)` event. If user’s FR shares were reduced, invariant **INV-3.3** (global solvency) still holds since collateral just moved form, not removed.<br>**Exit Criteria:** Users can open an LP-NFT position if they have sufficient tokens or FR shares. The NFT is held by vault and attributed to user (internal records). Slippage or insufficient collateral triggers `SlippageFailure` or `InsufficientCollateral` errors. Opening a position does *not* change net collateral, so no solvency error is raised in isolation. Event `LPPositionOpened` fires with correct parameters. Gas \~170k on open meets budget.<br>**Handover:** Concentrated positions established; proceed to closing logic (P2) and fee collection (P3).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | **Objective:** Enable closing of user LP-NFT positions (free collateral or withdraw it).<br>**Scope:** Implement `closeLPPosition(positionId, recipient)`. Preconditions: position exists in vault records and belongs to caller; if already zero liquidity, revert `NothingToClose`. Fetch position data (pool, ticks, liquidity). If system paused, allow closure in emergencies (users can exit). If user has outstanding debt, *simulate* withdrawal of this collateral: check if removing it would violate maintenance ratio (call `_checkSolvency` after hypothetically removing position’s value). If so, revert `Undercollateralized` (or use `LiquidationNotAllowed` context). Otherwise, use `PositionManager` to remove all liquidity from the NFT (burn it). Received token0, token1 amounts – by default send directly to `recipient` (user) as this is treated as a withdrawal of collateral. Option: if user wants to keep assets in vault, they could call `withdrawFromVault` later, but spec assumes direct outflow on close. Update storage: delete position record, decrement user’s `positionCount`. Emit `LPPositionClosed(owner, positionId, liquidityRemoved)` event and `Withdraw` event if funds leave vault (for tracking).<br>**Exit Criteria:** Users can close LP positions, converting them back to tokens. Closing is blocked if it would leave user undercollateralized with debt (verified by attempting with a high-borrow scenario). Closed NFT is burned and no longer counted in user’s vault. Collateral invariant holds: user’s remaining collateral >= required maintenance (tested via forced attempts to close with active debt). Gas \~150k meets spec target. Event logs correctly indicate closed position and amounts.<br>**Handover:** Users can freely manage LP collateral (open/close). P3 will handle accruing fees on these positions; system ready to incorporate LO and idle assets in S4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | **Objective:** Allow users to claim accrued trading fees from their active LP positions without closing them.<br>**Scope:** Implement `collectLPFees(positionId, recipient)`. Verify position exists and caller owns it. Use Uniswap PositionManager’s `collect` on the NFT (the vault as owner calls it) to retrieve any accumulated fee token0/token1 from that position. Add the collected tokens to the user’s idle balances in vault (`UserVault.token0Claims/token1Claims`) rather than auto-reinvest or send out. This preserves fees as collateral inside the vault (user can withdraw them via `withdrawFromVault`). Emit `LPFeesCollected(owner, positionId, amount0, amount1)` event. If no fees available (all zero), it’s a no-op or emits 0 amounts (no error needed).<br>**Exit Criteria:** Users (or keepers) can trigger fee collection on any open position. After calling, the position NFT’s fee counters reset and the user’s idle token claim balances increase by the fee amounts. Event `LPFeesCollected` confirms transfer. Invariant: **INV-2.4** (fee counters monotonic) remains – fees only ever reset to zero upon collection but never go negative. The collected tokens now count towards the user’s collateral (idle) for borrowing power. Tested by accumulating dummy fees (via simulating trades) and ensuring balances update correctly.<br>**Handover:** Fee collection complete. Users can accumulate yield from LP positions as additional collateral. Next, integrate idle token deposit/withdraw for user convenience (P4) and prepare for limit orders in S4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | **Objective:** Support direct management of idle tokens as collateral and internal accounting adjustments.<br>**Scope:** Implement `depositToVault(poolId, amt0, amt1)` and `withdrawFromVault(poolId, amt0, amt1, to)`. These allow users to add tokens to vault *without* minting LP shares, or withdraw idle tokens, respectively. Enforce pause flags and basic checks: depositToVault transfers tokens from user into vault, increments `UserVault.token0Claims`/`token1Claims`; withdrawFromVault ensures user has sufficient idle balance (`InsufficientLiquidity` error if not) and transfers tokens to `to`, decrementing claims. These maintain invariant that idle assets count 1:1 as collateral. Also in P4, update solvency check (`_checkSolvency`): when evaluating a user’s collateral vs debt, include idle tokens (full value) and active LP positions (use oracle/spot price to estimate position value). This ensures no withdrawal or position closure leaves user with DTR < 100%. No unbounded loops – iterate over user’s positions list (bounded by design, small count) or maintain aggregated values per user. Incorporate any policy haircuts for concentrated positions as needed (e.g. slightly lower collateral factor).<br>**Exit Criteria:** Users can move assets in/out of vault idle balances freely (subject to pause). Idle balances show up in collateral calculations for borrowing (tested by depositing idle tokens and seeing increased borrow capacity). Closing a position or withdrawing idle tokens triggers solvency re-check to prevent violating **INV-COL-02** (no under-collateral debt). Solvency checking now accounts for all collateral forms (full-range shares, finite-range NFTs, idle tokens). Gas impact of iterating positions acceptable (users typically have few positions; no global loops **INV-9.4** upheld).<br>**Handover:** Vault now supports multi-type collateral. S4 will introduce on-chain limit orders leveraging idle tokens and positions. All building blocks (idle token management, NFTs, share accounting) are in place for advanced trading features.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | **Objective:** Ensure all LP position features work in concert with lending and vault invariants.<br>**Scope:** Test opening and closing LP positions under various conditions. Create scenarios: user deposits assets, opens an LP position, then borrows against combined collateral. Verify that closing the position is prevented if it would break collateral ratio (simulate by borrowing to near limit, then attempt close – expect revert `LiquidationNotAllowed`). Test fee collection: simulate fee accrual (mock PositionManager to credit fees), call `collectLPFees`, then confirm user’s vault idle balance increases and can be withdrawn. Test idle token deposit/withdraw functions: deposit idle tokens and ensure they immediately count towards collateral (user can borrow more after depositing idle). Withdraw idle tokens and ensure it’s blocked if user’s remaining collateral would be insufficient (test enforcement of maintenance CF). Verify that all invariants hold with mixed collateral: **INV-3.4** per-user solvency – no allowed action leaves user below maint. collateral factor; **INV-UtilCap** still enforced with additional collateral types (no excessive borrowing). Run an invariant fuzz test: random sequences of open/close positions, deposit/withdraw idle, borrow/repay – confirm no invariant violations (e.g. total assets vs liabilities consistent, no collateral double-count).<br>**Exit Criteria:** All tests pass, confirming LP NFTs and idle tokens function as intended with lending. Events `LPPositionOpened/Closed` and `LPFeesCollected` fire with correct data on each action. The system maintains **all invariants** INV-2.x and INV-3.x across these complex operations (checked via comprehensive invariant tests in Foundry). Gas costs for position ops are within expectations (open \~170k, close \~150k, fee collect \~<100k).<br>**Handover:** Advanced collateral features verified. The vault is ready to add on-chain trading via limit orders and atomic batch processing in S4/S5.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **S4**<br>*On-chain Trading (Limit Orders & Swaps)* | **Objective:** Introduce on-chain limit order support and prepare data structures for order tracking.<br>**Scope:** Expand storage append-only beyond slot 24. Add `mapping(uint256 ⇒ LimitOrder) limitOrders` at next free slot (25) to catalog active LOs, and a `nextOrderId` counter (slot 26). Define `LimitOrder` struct with fields: `id, maker, poolId (PoolKey), isBuy, liquidityOrAmount, tick (price target), expiry`. Ensure new slots are added >=25 (no reuse of 19–22 hard-gap). Implement `placeLimitOrder(poolKey, isBuy, amount, price, expiry)`: Validate not paused (`PAUSE_TRADING` flag). Determine target tick from `price`. Transfer `amount` of input token from user (if isBuy: token1 in pool, aiming to buy token0; if isSell: token0 aiming to sell for token1). Provide all of one token to Uniswap by minting a one-tick-width position at `tick` (tickLower == tickUpper, per **INV-LIM-01**). Use PositionManager to create the limit-order NFT similar to opening a position, but record it separately as a LimitOrder (store `orderId = nextOrderId++`, mapping to {maker, poolId, isBuy, liquidity, tick, expiry}). Do *not* treat this NFT as a long-term collateral position – it’s a pending order. Emit `LimitOrderPlaced(orderId, maker, poolKey, isBuy, amount, price, expiry)` event. If expiry is set, store it; if not, treat as FOK (or no expiry). Ensure tick range = 1 tick (enforce tickLower==tickUpper by code design or assert) to satisfy INV-LIM-01.<br>**Exit Criteria:** Users can place limit orders by locking one asset in a one-tick LP position. Order details are stored and event emitted with correct parameters. The vault’s `limitOrders` mapping now tracks open orders. Placing an order debits user’s tokens (moved into the NFT). Confirm that **no immediate solvency impact** occurs – the locked tokens remain the user’s collateral (similar to idle or LP collateral). If user had debt, placing an order *does not* free them from collateral requirements (tested separately). Order placement reverts on invalid parameters (e.g. zero amount, or tick out of bounds). Expiry is recorded for later enforcement. **Storage remains append-only** – verified that new slot usage starts at 25+ with no overlap. Handover: basic order creation works; next implement execution & cancellation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **Objective:** Allow partial or full execution of limit orders when price conditions meet, realized by keepers or automated triggers.<br>**Scope:** Implement `executeLimitOrder(orderId, fillAmount)` for keepers. Validate: order exists and not expired (if expired, keeper should cancel instead; handle via cancel or revert `OrderExpired(orderId)`). Determine current pool price via Oracle or Uniswap spot – ensure price has crossed the order’s tick such that an execution is possible (if not, revert `OrderNotExecutable`). **Partial fills:** If `fillAmount < order.liquidity` (for partial execution), proceed to remove that portion of liquidity from the order’s NFT: call PositionManager’s `decreaseLiquidity` on the one-tick position, removing `fillAmount` liquidity. This yields a certain amount of output token (the asset the user wanted to receive). Collect the output tokens from the position (PositionManager `collect`). Credit the output to user’s idle balance in vault (e.g. if isBuy order, output is token0 – add to user’s token0Claims). Update the LimitOrder record: reduce stored `liquidity` by `fillAmount`. Emit `LimitOrderExecuted(orderId, fillAmount, fillPrice)` event logging the execution size and price (approx current price). If the order is now fully filled (`liquidity` goes to 0), auto-complete it: mark as filled (could leave record with 0 or remove and treat as filled awaiting cancellation). **Full fills:** If price has moved completely through the tick, the order’s entire liquidity might be filled – in such case, `fillAmount` will equal remaining liquidity, so remove all liquidity and collect all output tokens. Set order record to filled (or remove it) and emit event. The NFT will now have 0 liquidity (effectively burned or burn in cancel).<br>**Exit Criteria:** Keepers can execute orders when appropriate: executing yields output tokens to the user’s vault balance and reduces/cancels the order. Partial execution is reflected in stored order state (with reduced liquidity remaining). Attempts to execute too early or a non-existent order revert with `OrderNotExecutable` or `OrderNotFound`. The system ensures no adverse effect on vault invariants during execution – since tokens remain in vault (idle) post-execution, user’s collateral only changes form. (Test: an order execution that completes should immediately make the received tokens count toward collateral, so the user is not unduly undercollateralized mid-batch). Event logs match executions. Order expiry is not handled here (that goes through cancellation). Handover: final piece is cancellation, and introducing direct swaps.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | **Objective:** Permit direct market swaps via the vault for instant trades without manual order placement.<br>**Scope:** Implement `swap(poolId, zeroForOne, amountIn, amountOutMin, to)` as an atomic vault action (Action code V8). Any user can call (trading not restricted to hooks). Ensure not paused (`PAUSE_TRADING`). On call, if user has idle balance of input asset in vault, use it; otherwise pull `amountIn` from user (approved). Use Uniswap PoolManager’s swap function to swap `amountIn` of token0->token1 or vice versa (depending on `zeroForOne`), aiming to receive at least `amountOutMin` or revert `SlippageFailure`. Transfer the output tokens to `to` address (or to vault if user wants to keep it – in that case, they would specify `to` as vault/self and we credit idle balance). Emit a `Swap` event (or reuse Uniswap’s events or a vault `Swap` event if defined). This action is Phase B neutral (no net collateral change if output kept in vault, or reduces collateral if sent out). Security: use `nonReentrant` guard (swap is external call) and ensure no callback can reenter vault (SpotHook only handles fees).<br>**Exit Criteria:** Users can perform immediate swaps through vault liquidity. Swaps succeed only if pool has enough liquidity (implicitly ensured by Uniswap call) and respect slippage limits. The vault’s state updates appropriately: if output sent out, user’s vault assets decrease (like a withdraw of input); if output kept in vault, assets simply change type (token0 to token1). The swap action is fully tested with scenarios: vault converting one asset to another for a user’s strategy. No invariants are violated – a swap that sends output out is akin to withdrawing one asset and depositing the other, which is covered by normal checks (we ensure the user isn’t borrowing such that removing input asset breaks solvency – but since they simultaneously gain output asset, net value shift is zero, barring price differences). The action code V8 is reserved for swaps and integrated into BatchEngine ordering as neutral/riskless (Phase B by default). Handover: swap function complements limit orders for user trading needs. Proceed to cancellation and final QA.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **Objective:** Allow users (makers) or governance to cancel open limit orders, recovering unfilled collateral or expiring orders.<br>**Scope:** Implement `cancelLimitOrder(orderId)`. Requirements: order exists; if caller is the order’s `maker`, or an authorized governance/guardian (to cancel expired or globally unsafe orders), proceed. Fetch LimitOrder struct. Determine current fill status: if `liquidity` > 0, remove all remaining liquidity from the corresponding NFT (PositionManager remove all liquidity). Collect both token0 and token1 from the position. Because a one-tick order can result in partial fills, the user might now receive a mix of tokens: whatever portion wasn’t swapped remains of the original asset, plus any output asset from partial fill. Transfer all collected tokens back to user’s idle balances in vault (so they can withdraw or reuse). Mark the order as canceled: remove from `limitOrders` mapping and consider the NFT burned. Emit `LimitOrderCancelled(orderId)` event. **Solvency consideration:** If the user has outstanding debt, canceling an order returns collateral (tokens) to them, which *increases* immediately available collateral (does not harm solvency). However, if the order was partially filled (meaning user already effectively had some output tokens in vault), canceling just consolidates assets – user’s total collateral should not decrease. There is an edge case: if the user’s strategy relied on the order being illiquid (e.g., they borrowed against the fact that those tokens were locked and not volatile?), but generally returning assets to idle can only help collateralization. Thus, we do not expect cancel to ever violate solvency; nonetheless, run a `_checkSolvency` after cancel as a safeguard (if somehow the asset type change affects collateral factors, e.g., if one asset has a lower factor than the other, cancel could slightly worsen LTV – if so, handle via revert `WouldBecomeUndercollateralized` as a defensive measure). Expiry: if current time > order.expiry, allow anyone (or specifically guardian) to cancel as “expired” (no maker permission needed), still emitting same event.<br>**Exit Criteria:** Makers can cancel their orders at will, retrieving remaining tokens. Expired orders can be canceled by guardian to clean up. Cancelled orders are removed from tracking and cannot be executed thereafter. All user collateral from the order is safely returned to vault balances. Tested scenarios: cancel an unfilled order returns the original amount (minus no fees) – user’s idle balance increases exactly by what was locked; cancel a partially filled order returns the leftover of input asset plus already acquired output asset – user ends up with both tokens whose total value equals original collateral (minus any fees or slippage during partial fill). If cancellation could drop collateral quality, our check prevents it (e.g., if user has debt and asset A and B have different collateral factors, verify no breach). Events and mapping state confirm proper cleanup. **T8 Selector Guard:** Mark `cancelLimitOrder` (and `executeLimitOrder` and `liquidate`) as non-batchable if needed, to avoid complex reentrancy in a single batch – BatchEngine will blacklist those selectors.<br>**Handover:** All trading operations (place, execute, cancel, direct swap) are implemented. System ready for final integration testing and BatchEngine assembly in S5.                                                                                                                                                                                                                                                  | **Objective:** Comprehensive testing of limit orders, swaps, and integration with vault operations.<br>**Scope:** Test placing limit orders and executing/canceling them under realistic conditions. Use a price simulation: e.g., for a buy-order, simulate price drop below the tick and call `executeLimitOrder` – verify partial fills yield correct token output to user and order remains open with reduced amount. Simulate full fill (price crosses completely) and ensure execute closes order and delivers all output. Test cancellation by maker: unfilled order returns original assets; partially filled order returns remaining assets (user’s total asset value conserved). Check that cancel or execute on expired orders behaves correctly (expired cannot execute, but can cancel via guardian – simulate by fast-forwarding time and calling cancel from a governance address, expect success). Test direct `swap`: user swaps token0 for token1 using vault – ensure they receive at least `amountOutMin` and vault balances update (if output to vault, user’s idle balance increases in token1 and decreases in token0). Test swaps in combination with borrowing: user with debt swaps one collateral asset to the other – ensure this doesn’t bypass collateral checks (should be fine as net value unchanged). **Invariant checks:** use Foundry’s invariant test across trading actions: random sequence of deposits, place LOs, execute partial fills (perhaps by injecting price moves), cancels, swaps, etc., interleaved with accrual and borrow/repay. Assert that throughout, no invariant is violated: total shares ≥ totalBorrowShares, no user ends with negative or excessive debt vs collateral, fee invariants hold, etc. Also verify **INV-2.6** remains – only SpotHook/router call core liquidity funcs (in tests, we respect that by using batch or hook proxies for those calls). BatchEngine ordering rules tested via dry-runs (will fully test in S5).<br>**Exit Criteria:** All tests pass for limit orders and swaps. Action codes V6–V8 function as specified: events `LimitOrderPlaced/Executed/Cancelled` and `Swap` (if defined) fire correctly. The trading subsystem does not introduce any new invariant regressions – fuzz tests show stability. Gas costs are recorded: placing LO \~ slightly above LP open, executing \~ similar to partial close, cancel \~ similar to close, swaps \~ a bit above direct Uniswap call due to vault logic (acceptable). The system is feature-complete except for batch atomicity, which comes next. Handover: proceed to integrate BatchEngine and finalize QA in Sprint 5. |
| **S5**<br>*Finalization & Risk Management*          | **Objective:** Enable partial liquidations to handle accounts that are under-collateralized but still have collateral value remaining (DTR near but not far over 100%).<br>**Scope:** Implement `liquidate(poolId, borrower, repayAmount, to)` for keepers (Action V9). Preconditions: target’s DTR ≥ 1 (>=100%) meaning undercollateralized or exactly at brink (maintenance margin \~98% per REQ-F-11). If borrower’s debt ratio is below liquidation threshold (still healthy), revert `LiquidationNotAllowed()`. On call: **(1)** Accrue interest on pool to include latest debt. **(2)** Determine a safe `repayShares` amount from `repayAmount` (in tokens) – typically the keeper will aim to repay enough debt to bring DTR back to a safe level (e.g. target 85-90%). If `repayAmount` is not specified or more than needed to fully fix, cap it to an amount that would take borrower just below initial collateral factor. **(3)** Calculate equivalent debt shares and ensure `repayShares <= borrower.borrowShares`. **(4)** Transfer in the required tokens from liquidator (they pay the debt). Use `repayShares` logic to reduce borrower’s debt by that amount. **(5)** Compute collateral to seize: per REQ-F-11, seize *debt value + 10%* from borrower’s collateral. This means collateral worth `1.1 * repayAmount` in underlying value. Remove that collateral from borrower’s vault: preferentially take idle tokens and FR shares (since those are easiest to transfer). For FR shares, burn the calculated share amount from borrower’s balance and withdraw corresponding tokens from pool. If they also have LP positions, optionally choose to seize some (though implementation may keep it simple by focusing on fungible collateral first). **(6)** Transfer seized tokens to `to` (liquidator). Emit `Liquidation(liquidator, borrower, poolId, repaidDebt, seizedCollateral)` event. The borrower remains with reduced debt and reduced collateral. Ensure **no** bad debt in partial: we only seize 110% of what was repaid, so debt is fully covered. Any excess collateral beyond that remains with borrower.<br>**Exit Criteria:** Keepers can perform partial liquidations on unhealthy vaults. After partial liquidation: borrower’s debt is lower, collateral ratio is improved above maintenance (tested by scenario). Liquidator receives a 10% bonus in collateral for the service (verified by comparing value of seized vs repaid). Borrower still has some collateral and some debt remaining. The event logs the exact shares repaid and collateral seized. The invariant **INV-3.4** (no undercollateralized position) is enforced by the fact that liquidation wouldn’t execute unless borrower was at or over limit, and after execution borrower should be back under limit – tested by ensuring borrower’s DTR is >98% before and drops to e.g. 85% after. Gas costs for partial liquidation are acceptable (includes a repay and a withdraw – roughly <130k).<br>**Handover:** Partial liquidation logic complete; next handle full liquidation for cases of severe shortfall. | **Objective:** Handle full liquidations when a borrower’s collateral is insufficient to cover their debt (DTR >> 100%).<br>**Scope:** Extend `liquidate` to full liquidation mode (Action V12). Trigger condition: borrower’s collateral value *< debt* (DTR > 100%, e.g. insolvency). If detected, perform a full liquidation: **(1)** Accrue interest, then determine total debt (all borrowShares \* sharePrice). **(2)** Seize all borrower’s collateral (all idle tokens, all FR shares, and all LP positions). Compute total collateral value *X*. **(3)** Calculate the portion of debt the liquidator needs to repay: per REQ-F-12, liquidator pays an amount equal to 90% of collateral value (thus getting a 10% discount). Let `payDebt = 0.9 * X`. If `payDebt > totalDebt` (rare, meaning collateral actually covered debt – not truly full liquidations scenario), then just repay totalDebt (liquidator pays all debt, and the small difference means borrower had excess – treat as partial or give remainder to borrower, though in full mode this likely doesn’t happen). Otherwise, liquidator pays `payDebt` (if this exceeds their available, they likely wouldn’t attempt – assume keeper knows X). **(4)** Use liquidator’s tokens to repay `payDebt` worth of debt shares (reduce borrower’s debt accordingly). There will remain `badDebt = totalDebt - payDebt` that is unbacked by collateral. **(5)** Seize all collateral X and transfer **90% of it** to liquidator. The remaining 10% of collateral is effectively retained by protocol (could be sent to Treasury or insurance fund) to offset the shortfall. In practice, since we already only made them pay 90% of X, they get 100% of X here (they paid less), and the protocol covers the shortfall, which is equivalent to taking that 10% loss. The event `Liquidation(liquidator, borrower, ... repaidDebt, seizedCollateral)` will report `repaidDebt = payDebt` and `seizedCollateral = X` (liquidator got all collateral). **(6)** Set borrower’s debt to 0 and mark vault as liquidated (could remove borrower’s vault struct or mark flag). The leftover bad debt (`totalDebt - payDebt`) is recorded for later coverage. Increment a `badDebtPool[poolId]` counter or emit `BadDebtCovered` event to signal the need (see below). The borrower is now fully liquidated (no collateral, no debt, but possibly some unfilled bad debt at system level).<br>**Exit Criteria:** The worst-case scenario is handled gracefully: liquidator only pays what collateral justifies (90%), receives all collateral, and protocol shoulders 10% debt shortfall (to be covered by insurance or treasury). The borrower is wiped out (no assets, no debt). The event reflects the action and amounts clearly. The system remains solvent for remaining users; any bad debt is isolated. Tests: construct a case where collateral value is, e.g., 50% of debt – ensure liquidator pays 45% (0.9\*50%) of debt, gets 50% collateral, and 55% debt is left as bad debt flag. Confirm that after marking bad debt, `totalBorrowShares` still reflects only the covered portion (we subtract the repaid shares; the rest could either remain in totalBorrow as ghost until covered, or we subtract it and mark separately – our implementation will subtract to not violate global invariant, and account that in badDebt counter). The **INV-BOR-01** (totalBorrow <= totalShares) holds after we account for removing all collateral (totalShares drops) and subtracting repaid portion – any remaining debt not covered by shares means totalBorrowShares might temporarily exceed totalShares until cover (we handle by not subtracting those borrowShares yet, effectively marking them separately). This invariant breach is only momentary and expected to be resolved by coverBadDebt. Handover: proceed to cover bad debt and final testing. | **Objective:** Provide mechanisms for the protocol to manage and cover bad debt and maintain system integrity.<br>**Scope:** Implement an **Insurance Fund** and bad debt handling. Add `insuranceBalance` (or use `totalPolShares` and idle assets as implicit insurance). Implement `depositInsurance(amount)` and `withdrawInsurance(amount)` restricted to Governance/Treasury: these transfer stable assets into/out of the vault’s insurance reserve (could simply track as idle tokens under a special account or a dedicated storage). Emit `InsuranceFundUpdated(caller, delta)` event for transparency. For covering bad debt, implement `coverBadDebt(poolId, amount)` (governance-only). When called, transfer `amount` of tokens from insurance (or treasury) into the vault and use it to reduce the pool’s recorded bad debt. If bad debt was tracked in a counter, decrement it. If we left the bad debt as an excess in totalBorrowShares, here we would burn the corresponding borrow shares or inject equal collateral shares. Emit `BadDebtCovered(poolId, amount)` event. As an alternate path, if we had protocol-owned liquidity (POL shares), governance could choose to allocate some POL to cover debt by burning protocol’s own shares to cancel out debt – but that complexity is beyond spec, so we assume direct token injection. Ensure that after covering, global invariants are restored (totalBorrow <= totalShares again) and pool metrics reflect no shortfall. Additionally, implement a periodic **Metrics Snapshot** function (keeper or anyone): `recordVaultMetrics()` that emits `VaultMetrics(totalAssets, totalLiabilities, totalCollateral)`. It reads aggregate values (summing across pools: totalAssets = total liquidity value + idle, totalLiabilities = total debt owed, totalCollateral = perhaps totalAssets since system is balanced plus any POL/insurance) for monitoring. This has no state impact, just an event for off-chain observers (phase7 feature).<br>**Exit Criteria:** The protocol has tools to address insolvency. In a full liquidation test scenario with bad debt flagged, calling `coverBadDebt` with the correct shortfall amount results in a `BadDebtCovered` event and resets bad debt counter to zero. The insurance fund balance is debited accordingly (if pre-funded by `depositInsurance`). Conversely, if insurance was insufficient, multiple calls or a direct treasury infusion can be tested. The `VaultMetrics` event outputs expected totals reflecting the system state at various points (checked against known test values). These governance operations are tested with proper access control (only governor can call). No regular user action can directly create or cover bad debt (ensuring **INV-3.3** remains conceptually – any temporary breach is only resolved by governance). At this point, all system invariants are either automatically enforced or can be restored via governance actions. Handover: final step is to finalize the BatchEngine for atomic ops and run full-system QA. | **Objective:** Finalize atomic batch execution and ensure the system operates as designed when actions are combined in single transactions.<br>**Scope:** Complete the **BatchEngine Router** implementation (`executeBatchTyped(Action[] calldata actions)`). This function (in the BatchEngine contract or integrated in VaultManager as router) will parse an array of encoded actions (code + data) and execute them in a safe, deterministic order. **Ordering (Phase A vs B):** Before execution, classify each action by risk: look up action code in a Phase table (from spec Table 5.7.a). Reorder so that all Phase A actions (risk-reducing or neutral) execute before Phase B (risk-increasing), preserving relative order within each group. Example: a repay (A) will be executed before a withdraw (B) even if user provided withdraw first. **Execution:** Loop through the sorted list and for each `Action code`: call the corresponding internal function in VaultManagerCore (e.g., code V0→ `_depositFullRange`, V3→ `_repay`, etc.). Use `nonReentrant` guard on VaultManager to prevent any reentry mid-batch. After each sub-action, run invariant checks: critical checks include collateral solvency (no intermediate action can push account insolvent – if it does, revert `WouldBecomeUndercollateralized`) and pool utilization (no borrow that breaks cap). If any sub-action reverts or an invariant fails, **rollback entire batch** (ensure state changes are reverted by using standard solidity `revert`). **Selector blacklist (T8):** Before executing, ensure no disallowed actions are in the batch: compare each action’s function selector against a blacklist (e.g., liquidations and coverBadDebt may be forbidden in user batches) – if any found, revert batch upfront. **Events:** Emit `BatchExecuted(caller, actionsCount, success)` event after attempting all. Also, the VaultManager’s own events from each sub-action will have been emitted in order, which off-chain systems can use to reconstruct batch activity.. Also provide `simulateBatch(actions)` which performs the same logic in a read-only manner (via `staticcall`) and returns a `BatchPreview` (e.g., final balances) – this reuses internal functions with no state change. Integrate all batch functionality behind the scenes: going forward, the external user-facing entry point is `executeBatchTyped` and direct calls to VaultManagerCore (except by authorized modules) can be restricted or deprecated as per REQ-F-13.<br>**Exit Criteria:** Users can atomically execute multi-step operations in one transaction with guaranteed invariant safety. For example, a batch consisting of \[repay, withdraw] will succeed where separate calls might fail (since repay first improves solvency). Fuzz tests confirm that for any random batch of actions, the outcome equals sequential single calls, or the batch reverts safely if any intermediate step would violate an invariant (no partial effects). Verified deterministic ordering: risk-reducing actions always move before risk-increasing. Blacklist works: adding a forbidden action (liquidate within a user batch) causes immediate revert (tested by attempting a self-liquidation batch – not allowed). The `simulateBatch` returns accurate previews (tested against actual execution). **REQ-F-14** is satisfied: `executeBatchTyped` is atomic and enforces all checks. **REQ-F-18** satisfied: Phase A actions reordered before Phase B. With BatchEngine in place, all user-facing functions (deposit, withdraw, borrow, etc.) are now invoked via batch router (the direct calls can be limited to internal or guardian use). The system passes full integration testing under batch usage. |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

## Spec-to-Phase Traceability Matrix

Below we map each specified Action (V0–V14) and Invariant (INV-x.x) to the sprint phase where it is implemented and/or tested.

### Batch Action Codes (V0–V14) Implementation Phases

| **Action Code** <br>(*Description*)      | **Implementation Phase** <br>(*Enforced / Tested*)                                                                                                                                                                                               |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **V0** – *Deposit Full-Range*            | **S1 – P2** (Code: `deposit()` logic to add liquidity; share minting) <br> **S1 – P5** (Unit tests for deposit event & share credit)                                                                                                             |
| **V1** – *Withdraw Full-Range*           | **S1 – P3** (Code: `withdraw()` to remove liquidity; enforce lockedShares) <br> **S1 – P5** (Tests for withdraw slippage, `InsufficientShares` error)                                                                                            |
| **V2** – *Borrow FR Shares*              | **S2 – P2** (Code: `borrow()` implemented with collateral checks) <br> **S2 – P5** (Tests for borrow limits, `ExceedsInitCF/MaintCF` errors)                                                                                                     |
| **V3** – *Repay FR Shares*               | **S2 – P3** (Code: `repay()` function with interest accrual) <br> **S2 – P5** (Tests for partial/full repay, `RepayTooMuch` revert)                                                                                                              |
| **V4** – *Mint CR Position* (Open LP)    | **S3 – P1** (Code: `openLPPosition()` uses PositionManager) <br> **S3 – P5** (Tests for opening NFT collateral, event `LPPositionOpened`)                                                                                                        |
| **V5** – *Burn CR Position* (Close LP)   | **S3 – P2** (Code: `closeLPPosition()` to remove NFT liquidity) <br> **S3 – P5** (Tests for closing collateral, solvency check on close)                                                                                                         |
| **V6** – *Place Limit Order (LO)*        | **S4 – P1** (Code: `placeLimitOrder()` implemented with one-tick LP mint) <br> **S4 – P5** (Tests for LO placement event `LimitOrderPlaced`)                                                                                                     |
| **V7** – *Cancel Limit Order*            | **S4 – P4** (Code: `cancelLimitOrder()` to remove LO liquidity) <br> **S4 – P5** (Tests for maker and guardian cancellations, event `LimitOrderCancelled`)                                                                                       |
| **V8** – *Market Swap via Vault*         | **S4 – P3** (Code: `swap()` function calling Uniswap pool swap) <br> **S4 – P5** (Tests for direct swaps respecting `amountOutMin`)                                                                                                              |
| **V9** – *Liquidate Vault (Partial)*     | **S5 – P1** (Code: partial `liquidate()` logic for healthy but risky accounts) <br> **S5 – P5** (Tests for partial liquidation outcomes, event `Liquidation`)                                                                                    |
| **V10** – *Claim Position Fees*          | **S3 – P3** (Code: `collectLPFees()` implemented to credit user claims) <br> **S3 – P5** (Tests for fee collection event `LPFeesCollected`)                                                                                                      |
| **V11** – *Close Vault (Repay+Withdraw)* | **S5 – P1/P2** (Covered by combination of repay + withdraw logic in liquidation flows; no separate user fn, use batch of V3+V1) <br> **S5 – P5** (Integration tested via batch: full debt repay then withdraw in one batch equals vault closure) |
| **V12** – *Liquidate Vault (Full)*       | **S5 – P2** (Code: full liquidation branch in `liquidate()` covers insolvency) <br> **S5 – P5** (Tests for full liquidation scenario, bad debt handling)                                                                                         |
| **V13** – *Poke Positions (Accrual)*     | **S5 – P4** (Code: `pokePositions()` implemented within BatchEngine as maintenance action; triggers interest/fee refresh without state change) <br> **S5 – P5** (Tested indirectly via batch simulate and invariant checks)                      |
| **V14** – *(Reserved for future)*        | **Not implemented in V2** – placeholder code kept unused (ensures action code space for future expansion).                                                                                                                                       |

### Invariants (INV) Enforcement & Testing Phases

| **Invariant** (from Spec)                                                                                          | **Implemented / Tested in Phase**                                                                                                                                                                                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **INV-2.1** – *Total Shares ≥ Locked* – The vault never allows withdrawing the last `lockedShares`.                | **S1 – P3**: Enforced in `withdraw()` (require totalShares ≥ locked after withdraw). <br>**S1 – P5**: Tested by attempting to withdraw below locked (expect revert).                                                                                                                                                            |
| **INV-2.2** – *Locked Shares Never Decrease* – Once set on first deposit, `lockedShares` is immutable.             | **S1 – P1/P2**: `registerPool()` sets lockedShares on first deposit; no code path to reduce it. <br>**S1 – P5**: Verified by design (no function to lower lockedShares) and reviewed in audit.                                                                                                                                  |
| **INV-2.3** – *Pending Fees Cleared on Reinvest* – `pendingFees` reset to 0 after reinvest.                        | **S2 – P4**: Enforced in `reinvestFees()` implementation (set counters to zero on success). <br>**S2 – P5**: Tested by simulating fee accrual then reinvest (ensure `pendingFees` becomes 0).                                                                                                                                   |
| **INV-2.4** – *Fee Counters Monotonic* – `pendingFees` only ever increase (except when reset).                     | **S2 – P4**: Maintained by SpotHook integration (fees only accumulate); reinvest is the only reset point. <br>**S2 – P5**: Covered in tests by ensuring no function decrements `pendingFees` other than setting to 0 on reinvest (which is allowed).                                                                            |
| **INV-2.5** – *Share Price Non-Decreasing* – Vault share value never drops (no dilution without new assets).       | **S2 – P4**: Reinforce via fee reinvest design – new shares are only minted when adding equivalent value, so share price stays same or rises. <br>**S2/S4 – P5**: Observed in tests: operations like borrow/reinvest can only increase or maintain pool asset value per share (no arbitrage loss).                              |
| **INV-2.6** – *Authorized Hook Only* – Only the official Uniswap V4 hook can call deposit/withdraw.                | **S1 – P2/P3**: Enforced by `require(msg.sender == authorizedHookAddress)` in deposit/withdraw functions. <br>**S1 – P5**: Tested by calling deposit/withdraw from an EOA (expect `UnauthorizedCaller` error).                                                                                                                  |
| **INV-2.7** – *Emergency Pause Halts Ops* – Global/pool pause flags stop risky actions.                            | **S1 – P4**: Enforced by `whenNotPaused` modifiers on all state-mutating functions (e.g., deposits, borrows) and checks in SpotHook for pool emergencies. <br>**S1 – P5**: Verified by toggling `pauseFlags` bits and confirming actions revert (`ContractPaused` error).                                                       |
| **INV-3.1** – *Borrow Index Monotonic* – Interest index (`shareIndex`) never decreases.                            | **S2 – P1**: Enforced by math in `accrueInterest` (multiplicative factor ≥1). <br>**S2 – P5**: Tested by accruing interest with positive/zero rates and verifying index only rises or stays same (never drops).                                                                                                                 |
| **INV-3.2** – *Accrual Time Consistent* – `lastAccrueTime` never set to future; accrual calls in order.            | **S2 – P1**: Enforced in `accrueInterest`: skip or revert if current time ≤ lastAccrueTime (no back-in-time updates). <br>**S2 – P5**: Tested by calling accrue twice in same block (second call makes no change, time check prevents update).                                                                                  |
| **INV-BOR-01 (3.3)** – *Global Solvency* – Total borrowed shares ≤ total supply shares (vault not over-borrowed).  | **S2 – P2**: Enforced in `borrow()`: require `totalBorrowShares + newBorrowShares <= totalShares * utilCap` (95%). Also any withdraw reduces borrow headroom. <br>**S2 – P5**: Continuously checked via invariants test after random sequences; any violation causes test failure (never observed).                             |
| **INV-COL-02 (3.4)** – *Per-User Solvency* – No user can have debt exceeding collateral \* maint. factor.          | **S2 – P2/P3**: Enforced in `borrow()` (require collateral ≥ debt\*initCF) and `withdraw()`/`closePosition()` (call `_checkSolvency` if user has debt). LiquidationEngine monitors this too. <br>**S5 – P5**: Fuzz-tested: no sequence of actions allows a user to end a block undercollateralized without being liquidated.    |
| **INV-3.5** – *Collateral Factor Bounds* – initCF ≤ maintCF ≤ 100%.                                                | **Implicit via PolicyManager**: The PolicyManager’s `setCollateralFactors` ensures ordering (enforced in its own module). <br>**S2 – P5**: Assumed by vault logic; tested indirectly by using realistic factors (no vault function can violate this since factors come from PolicyManager).                                     |
| **INV-3.6** – *Borrow Increases Debt* – Calling borrow increments user and system debt by exactly that amount.     | **S2 – P2**: Implemented in `borrowShares`: we add exactly `shares` to `userVault.borrowShares` and `totalBorrowShares`. <br>**S2 – P5**: Verified in tests: after borrow, user’s recorded debt and global debt increased by the expected share count (no more, no less).                                                       |
| **INV-3.7** – *Repay Reduces Debt* – Calling repay decrements debt counters by exactly repaid amount.              | **S2 – P3**: Implemented in `repayShares`: subtract repaid shares from both user’s `borrowShares` and `totalBorrowShares`. <br>**S2 – P5**: Tested by full repay bringing both user and global borrow to zero, and partial repays reducing both consistently.                                                                   |
| **INV-3.8** – *ShareMultiplier Monotone* – Global interest factor never decreases (draft status).                  | **S2 – P1**: Achieved via `shareIndex` update logic (multiplicative factor ≥ 1). No mechanism to lower the index. <br>**S2 – P5**: Confirmed through interest accrual tests (the factor either increases or stays constant if rate=0).                                                                                          |
| **INV-WCLedger** – *Worst‑Case Ledger* – Net A/B ≥ Worst-case A/B (collateral accounting for extreme price moves). | **Design Consideration (draft)**: Not explicitly coded in V2 (would require dynamic worst-case calc). <br>**S3/S4 – P5**: Addressed via conservative collateral factors and invariant checks. Future improvement stubbed (no user loops, position values evaluated on close).                                                   |
| **INV-UtilCap** – *Utilization ≤ 95%* – Pool utilization capped at 95%.                                            | **S2 – P2**: Enforced in `borrow()`: require `(totalBorrowShares + new) <= 0.95 * totalShares` (utilization cap). <br>**S2 – P5**: Tested by attempting to borrow out more than 95% of liquidity (reverts). Also monitored in fuzz tests to never exceed threshold.                                                             |
| **INV-LIM-01** – *Limit Order = 1 Tick* – Limit orders must be one-tick wide.                                      | **S4 – P1/P2**: Enforced by construction: `placeLimitOrder` always uses `tickLower == tickUpper` (only one tick provided) – code assertion and comment. <br>**S4 – P5**: Verified by trying to manipulate ticks via contract call (not possible due to interface design). Any non-1-tick call would be rejected or not compile. |
| *INV-9.1* – *Paused State Halts Risky Actions* (legacy; unified in 2.7).                                           | *Covered by INV-2.7 above.* All pause invariants unified and active.                                                                                                                                                                                                                                                            |
| *INV-9.2* – *Timelock on Gov Actions* (off-chain policy).                                                          | *Governance process enforced off-chain via Timelock (48h delay) – not a code invariant.* Governance module (Timelock) ensures this.                                                                                                                                                                                             |
| *INV-9.3* – *Module Upgrade Safety* – New modules must be storage/interface compatible.                            | **S5 – P4**: Ensured by using append-only storage for upgrades and verifying interface IDs on new modules (e.g. checking `supportsInterface` on external modules if needed). Manual review and CI checks in place (slot collision check).                                                                                       |
| *INV-9.4* – *No Unbounded Loops* – All on-chain loops are bounded by design.                                       | **Throughout (design)**: Loops over user positions or actions are bounded by small N (e.g., positions count, batch action count). <br>**S5 – P5**: Confirmed via code review and tests that no function can iterate over unbounded list of users or global structures (liquidations handled one vault at a time).               |

## Risk & Accommodation Ledger

**Storage Layout – Append-Only & Reserved Slots:** Vault storage remains strictly append-only to preserve upgrade safety. All variables up to slot 24 match V1 layout and are untouched. We introduced new storage starting at slot 25 (e.g., `limitOrders` mapping) in V2, leaving slots 19–22 hard-reserved as per spec. Soft-gap slot 5 and 15 also remain unused in V2 (reserved for future if needed). A CI “storage collision” check ensures no slot shifting occurred. This adheres to the append-only rule – any new state (order book, etc.) was placed in higher slots, and we documented these in **Appendix A: Storage Layout** for audit traceability.

**Action Code Immutability:** The Batch action codes V0–V13 remain fixed and semantics aligned with V1.2.1 spec. We did not repurpose any action codes – for example, V8 still represents a swap, V9 partial liquidation, etc., exactly as defined. Code V14 is kept as a no-op placeholder for future expansion. This guarantees that external integrations or signed payloads referencing action codes remain valid in V2. The `selectors.json` (action selectors) is updated only to include new function selectors and to blacklist certain selectors (see below) per T8 rule.

**Pause Flags & Emergency Controls:** The `pauseFlags` 96-bit bitmap (slot 0 offset 160) continues to govern emergency halts. We allocated new pause bits for newly added functionalities: e.g., a `PAUSE_BORROWS` bit (used in borrow function checks), `PAUSE_POSITIONS` for LP position opens/closes, and `PAUSE_TRADING` for swaps and limit order actions. All user-facing state changes check the appropriate flag (and also the global `PAUSE_ALL` bit 0) before proceeding. This ensures that in an emergency (e.g., an exploit or oracle failure), governance or the Pause Guardian can immediately stop deposits, borrowing, or even limit-order execution as needed. We preserved the mapping of bits as documented in Table 7-1 of the spec (bits 0–9 defined) – for instance, bit 0 = pause all, bit 1 = pause deposits, etc. – and extended it in a consistent manner (additional bits for new features) so auditors can trace each bit’s effect.

**Selector Blacklisting (Minimal Exposure T8):** As a safety accommodation, the BatchEngine implements a **selector guard** to blacklist high-risk function selectors from user batches. Per Tenet T8, we marked `liquidate(...)` (V9) and `coverBadDebt(...)` as non-batchable by regular users. These operations require sequential, isolated execution and are restricted to keepers/governance. If a user attempts to include such selectors in a batch, the BatchEngine will revert the entire batch before execution. This prevents complex reentrancy or abuse scenarios (e.g., self-liquidation in the same batch as borrowing). The blacklist is maintained in a config (`selectors.json`) and enforced on each batch run. This measure aligns with the spec’s “Minimal Exposure” guideline, ensuring only safe combinations of actions execute atomically.

**Upgradeable Modularity (Delegate-Call Hooks T9):** To accommodate future upgrades in complex logic (especially mathematical computations), we followed Tenet T9 by structuring certain calculations to allow external library delegate-calls. For example, if the interest rate model or pricing formula needs adjustment, the VaultManager can delegate-call to an updatable math library (with a stored address) instead of hard-coding logic. In our implementation, core math (like interest index update or swap simulation) is encapsulated such that it could be moved to a library contract and invoked with `DELEGATECALL`. We have not fully activated this in V2 (no immediate need to swap math modules), but the groundwork is in place: the architecture diagram shows VaultManager calling out to Math libraries for heavy calculations. We reserve an upgrade path to insert a delegate-call for, say, a new interest formula without changing storage or interfaces, thus meeting the upgrade modularity invariant (INV-9.3) through design.

**Integration with External Modules:** We assumed Oracle (`TruncGeoOracleMulti`), PolicyManager, and SpotHook modules are stable and accurate. Nonetheless, we built in accommodations for integration: e.g., VaultManager calls `oracle.getSpotPrice(poolId)` only via a view (no state dependency) and guards against oracle reentrancy by the overall `nonReentrant` lock. The PolicyManager is consulted for collateral factors and interest rates – if it returns out-of-range values, VaultManager will revert on invalid collateral factor ordering (ensuring INV-3.5) or skip accrual if rate is zero. SpotHook is the only contract allowed to initiate deposits/withdrawals, enforced by `authorizedHookAddress`. We also left an `authorizedRouter` option (BatchEngine address) to call core functions – in V2, BatchEngine uses internal calls so this isn’t separate, but we could whitelist a batch router contract if needed, via the same hook mechanism. These measures ensure external module calls do not compromise vault state, and any required changes (e.g., a new oracle address) can be done via governance without contract upgrades.

**Worst-Case Scenarios & Recovery:** We identified and accommodated key worst-case situations: if an asset price plummets (making some collateral near worthless), the **Worst-Case Ledger** invariant (INV-WCLedger) is conceptually handled by liquidations – the design assumes timely liquidation of such positions rather than a separate enforcement in code. We provided generous buffers (init vs maint collateral factors) to give keepers time. In code, after each potentially risk-increasing action (withdraw, position close), we call `_checkSolvency` which uses current oracles to approximate worst-case. For truly catastrophic drops within one block, the system may temporarily violate per-user solvency, but the next keeper call will liquidate and the invariant will be restored. We also prepared the insurance fund mechanism to handle accumulated bad debt if liquidations can’t fully cover (e.g., an asset went to zero). Governance can refill the system via `coverBadDebt` using Treasury funds – this is cited in spec and we fire events for transparency. Additionally, cross-chain re-entrancy (governance attacks via L2 proposals) is mitigated by the Timelock and `nonReentrant` guards as noted in the spec – essentially, no cross-chain call can bypass the 48h delay or the one-at-a-time execution guard.

**Testing & Invariant Enforcement:** Every invariant (**INV-2.x**, **INV-3.x**) from the spec is either enforced in smart contract code or covered by the test suite. For instance, the **total vs. borrowed shares** condition is checked both in-code before borrowing and continuously in a Foundry invariant test that runs random sequences of actions, failing if `totalBorrowShares > totalShares` ever holds. We included stub invariant checks in code paths (like `_checkSolvency` after certain actions) even if they should never fail under correct usage, to act as internal assertions – for example, after a batch executes, we assert the global solvency invariant one more time (this would only trigger if there’s a bug). These invariant checks map back to spec tags (we commented the code with references to INV IDs where applicable). All tests reference spec requirements by ID (e.g., REQ-F-11 partial liquidation logic matches the Liquidation test verifying 110% seizure) to ensure traceability. This diligent approach to testing and enforcement guarantees that V2 upholds the intended design constraints at runtime, and any deviation is caught in QA before deployment.

## Per-Phase Work-Item Lists (Issues & Complexity Estimates)

Below is a breakdown of development tasks per phase, with each item linked to spec references and assigned a Complexity Unit (CU) score (average of estimated SLOC and cyclomatic complexity on a 0–10 scale). We balanced each sprint’s phases P1–P4 to within ±10% CU, and ensured P5 (Testing/QA) is roughly one-quarter of the sprint’s total effort.

### Sprint 1 – Core Vault & Pool Setup

* **Phase 1:** *Vault Core Scaffolding & Pool Registration*

  * [ ] **(CU=4)** Define **VaultManagerCore storage** structure up to slot 24 (match V1 layout). Include owner, pauseFlags, module addresses (Oracle at slot2, PoolManager slot3, etc.). *Spec ref:* Storage table Appendix B.
  * [ ] **(CU=5)** Implement **`registerPool(PoolKey)`**: allocate a new `PoolId`, store initial pool data (initialize ShareInfo with `totalShares=0` and set `lockedShares` once first deposit happens). Emit `PoolRegistered` event on first activation.
  * [ ] **(CU=3)** Initialize **governance roles** and addresses: set vault owner (Timelock) and pause guardian; link PolicyManager, PositionManager, Treasury addresses in state. *Spec ref:* Roles mapping.
  * [ ] **(CU=5)** **CI Storage Check**: Run slot layout comparison (against V1) to confirm no shifts in slots 0–24. Document any new slot usage (none in S1). *Exit:* VaultManagerCore deployed with correct storage; pool registration ready for use.

* **Phase 2:** *Implement Deposit Logic (Full-Range)*

  * [ ] **(CU=6)** Code **`deposit(poolId, amount0, amount1)`** in VaultManagerCore: transfer tokens in (via `safeTransferFrom` from `msg.sender` – which will be SpotHook in prod); call PoolManager’s `addLiquidity` to vault’s FR position; calculate `sharesMinted` from liquidity. Revert if both amount0 and amount1 are zero or if `msg.sender` not authorized (Hook).
  * [ ] **(CU=4)** **Slippage check**: incorporate `minShares` or `amount0Min/amount1Min` logic – if actual minted shares < expected, revert `SlippageFailure` (per spec). Use current pool price from Oracle for estimation if needed.
  * [ ] **(CU=4)** **Update state**: increment `shareData[pool].totalShares` and `userVaults[pool][user].shareBalance` by shares minted. If this is first deposit in pool (pre totalShares=0), set `lockedShares = shareBalance` (immutable). Emit `Deposit(caller, asset, amount, recipient)` event.
  * [ ] **(CU=4)** **Pause & auth enforcement**: add `notPaused(PAUSE_DEPOSITS)` modifier and require `msg.sender == authorizedHook`. Test internal: calling deposit when paused or by EOA should revert with `ContractPaused` or `UnauthorizedCaller`. *Exit:* Deposits correctly credit shares and adhere to invariants (no locked share violation, no unauthorized access).

* **Phase 3:** *Implement Withdraw Logic (Full-Range)*

  * [ ] **(CU=5)** Code **`withdraw(poolId, shares, to)`**: ensure `shares > 0` and user’s `shareBalance >= shares` (else revert `InsufficientShares`). Calculate expected token amounts via PoolManager’s `removeLiquidity` (or use share-to-liquidity conversion). Call PoolManager to withdraw that proportion of FR liquidity to vault.
  * [ ] **(CU=4)** **Slippage check**: accept `amount0Min, amount1Min` parameters (from batch action encoding) – after withdrawal, if tokens received < mins, revert `SlippageFailure`. Use events or return values from PoolManager to get withdrawn amounts.
  * [ ] **(CU=4)** **Update state**: decrement `userVault.shareBalance` and `shareData.totalShares` by `shares`. If new `totalShares` would fall below `lockedShares` and user still wants to withdraw, revert (preserve INV-2.1). Transfer out tokens to `to` address. Emit `Withdraw(caller, asset, amount, recipient)` event.
  * [ ] **(CU=4)** **Solvency & pause**: if user has any debt (`userVault.borrowShares > 0`), call `_checkSolvency(user, pool)` – ensure after withdrawing these shares, user’s collateral still >= debt\*maintCF (else revert `Undercollateralized`). Also gate with `notPaused(PAUSE_WITHDRAWALS)`. *Exit:* Withdrawals burn shares and transfer tokens correctly, and blocked when violating lockedShares or solvency.

* **Phase 4:** *Finalize Core Controls (Pause, Reinvest Flag, Batch Stub)*

  * [ ] **(CU=3)** Implement **`pause(uint8 flags)` / `unpause(uint8 flags)`** for owner/guardian: set/unset bits in `pauseFlags`, emit `Paused(caller, flags)` or `Unpaused` events. Bits defined as per Table 7-1 (bit0 global, bit1 deposits, etc.). Ensure only governance roles can call (use Ownable or AccessControl as appropriate).
  * [ ] **(CU=2)** **Global Guards**: Add `whenNotPaused(PAUSE_ALL)` to all external mutative functions (so any pause halts them). Also, in SpotHook (off-chain config), ensure it checks `VaultManager.pauseFlags` for pool-specific flags (already specified in Spot design).
  * [ ] **(CU=4)** Implement **`toggleReinvest(poolId, bool enabled)`**: Only governor can call. Store a bool in pool’s ShareInfo or a separate mapping `reinvestEnabled[pool]`. Flip it and emit `ReinvestToggled(poolId, enabled)`. VaultManagerCore will consult this flag later to decide if fees should auto-reinvest or accumulate.
  * [ ] **(CU=4)** **BatchEngine interface stub**: Add a placeholder function `BatchEngine.executeBatchTyped(Action[] memory actions)` in VaultManagerCore (or deploy a separate BatchEngine contract with reference to Vault). For now, it can simply loop and call VaultManager’s functions directly in order (no reordering yet) or even do nothing (just to allow integration testing). Mark all user-exposed funcs (deposit, borrow, etc.) as `onlyBatchOrHook` in the future; for now just note that direct calls are allowed during dev. *Exit:* Core contract supports pausing, and governance toggles. Reinvest flag exists (no functional impact yet). Batch stub allows basic multi-call usage for testing (though final ordering logic comes in S5).

**Sprint 1 Complexity Heatmap:** P1: 16 CU | P2: 18 CU | P3: 17 CU | P4: 13 CU | **P5: 24 CU**. *The dev phases are balanced within \~10%, and testing effort is \~25% of Sprint 1.*

### Sprint 2 – Interest & Lending Functions

* **Phase 1:** *Interest Accrual Implementation*

  * [ ] **(CU=5)** Implement **`accrueInterest(poolId)`**: read `lastAccrueTime` and current `block.timestamp`. If no time passed, no update. Otherwise fetch `ratePerSecond` from interest model (PolicyManager). Compute interest factor = `r * Δt` (or use exponential for precise compound, small Δt so linear approx is fine). Update `shareIndex = shareIndex * (1 + r*Δt)` (or exp). Cap or check overflow (use 64.64 fixed point perhaps for precision). Set `lastAccrueTime = now`.
  * [ ] **(CU=3)** **Event and logging**: emit `InterestAccrued(poolId, interestAmount)` where interestAmount = incremental interest in underlying (could calculate as `totalBorrowShares * (factor-1) * sharePrice`). This gives transparency.
  * [ ] **(CU=4)** **Invariant enforcement**: ensure `block.timestamp >= lastAccrueTime` before update (if not, skip or revert – handles clock sync issues). Also ensure interest rate model is set: if `PolicyManager.getRate(poolId)` returns 0 address or invalid, revert `InterestModelUnset` (so governance must configure each pool).
  * [ ] **(CU=4)** **Gas optimize**: store `shareIndex` in a mapping (slot9) or within ShareInfo if size allows; avoid iterating users (global index times user shares yields accrued interest individually). Use a fixed-point factor (e.g., index scaled by 1e27) to accumulate interest precisely without rounding per user until repay/borrow. *Exit:* AccrueInterest updates indices correctly, preparing groundwork for borrow/repay to use global index.

* **Phase 2:** *Borrow Function & Solvency Checks*

  * [ ] **(CU=6)** Implement **`borrow(poolId, amount, to)`**: require `amount > 0`. **Accrue interest** on the pool first (ensures up-to-date index). Convert `amount` (token) to `sharesToBorrow`: `shares = amount / currentSharePrice` (sharePrice = underlying per share = function of pool liquidity / totalShares). Alternatively, maintain an interest index: easier to track debt in shares directly. If using interest index method: we simply treat `amount` as “shares” because our shares already are invariant units (since assets are in Uniswap LP, share accounting is used for debt too). *Spec uses share-based borrowing, so assume amount = shares user wants to borrow.*
  * [ ] **(CU=5)** **Collateral check**: compute user’s *effective collateral* in this pool (and possibly across pools if cross-collateral, but design is per-pool). Get `collateralValue = user.shareBalance * sharePrice + idleToken balances + value of any LP positions`. Use PolicyManager’s collateral factors: `initCF` (e.g., 150%) and `maintCF` (e.g., 115%). Calculate post-borrow debt = currentDebt + amount. If `postDebt > collateralValue * (initCF)` then revert `ExceedsInitCF`. If `postDebt > collateralValue * (maintCF)` (which really should always be true if it exceeds initCF, since init<=maint) then also revert, possibly with a different error `ExceedsMaintCF` for clarity. Essentially user must remain above initCF after borrow.
  * [ ] **(CU=4)** **Update balances**: increment `userVault.borrowShares` by `sharesToBorrow` and `totalBorrowShares` by same. Also increment `userVault.lastBorrowTime` (if using for cooldown) or any tracking needed. Transfer underlying tokens out: ideally, withdraw from vault’s FR liquidity. We have two ways: (a) If vault has idle reserves (from fees or prior deposits), use those first; (b) else, withdraw `sharesToBorrow` worth of liquidity from Uniswap (reduce `totalShares` accordingly, effectively the vault is lending out part of LP). We ensure not to exceed utilization cap below. Send resulting tokens to `to` address. Emit `Borrow` event.
  * [ ] **(CU=4)** **Utilization cap & invariants**: After updating, enforce `totalBorrowShares <= utilCap * totalShares` (utilCap e.g. 0.95). If exceeded, revert `UtilizationExceeded` (spec INV-UtilCap) – though we checked before, do again to be safe if concurrent operations. Also ensure **INV-BOR-01**: vault never lends non-existent liquidity (the cap ensures 5% of liquidity stays). Pause guard: `notPaused(PAUSE_BORROWS)`. *Exit:* Borrow functionality complete – tested via upcoming QA tasks; errors thrown for no collat or too much borrow.

* **Phase 3:** *Repay Function & Debt Accounting*

  * [ ] **(CU=5)** Implement **`repay(poolId, amount, onBehalf)`**: allow `onBehalf` so third-party liquidator can repay someone’s debt. Require `amount > 0`. **Accrue interest** on pool first (to charge latest interest before reducing debt). Determine borrower = `onBehalf` (if onBehalf != msg.sender, require msg.sender authorized keeper or no restriction if we allow anyone to repay others). Calculate `sharesToRepay`: if using share-denominated debt, we can convert token amount to shares via current sharePrice (or just treat amount as shares if interest index is internal). Likely easier: track debt in shares; when repaying, convert token payment to shares = tokens / sharePrice. Slight complication: sharePrice changes with pool liquidity, but interest index scaling should handle interest portion.
  * [ ] **(CU=4)** **Update debt**: reduce `userVault.borrowShares[borrower]` by sharesToRepay (capped at their current borrowShares). If `amount` is more than outstanding debt in tokens, revert `RepayTooMuch` (or simply cap amount to exact debt and refund excess, but spec prefers revert). Decrease `totalBorrowShares` similarly. Transfer tokens from msg.sender to vault (to actually settle the debt). We don’t necessarily add to liquidity; simplest: immediately use tokens to add back to vault’s FR position – but that’s an expensive operation each repay. Instead, hold repaid tokens as idle liquidity or a buffer. However, to maintain invariant totalBorrow<=totalShares, probably best to **burn** an equivalent amount of debt shares by *minting* FR shares internally: effectively, when repaying, we could add the tokens to vault’s liquidity position (increasing totalShares). Implement by calling PoolManager to add liquidity with repaid tokens (auto-compounding lenders’ pool). Alternatively, treat it as protocol-owned liquidity increase. We do whichever is simpler: for now, just assume repaid assets stay in vault (increasing vault’s idle or rebalances FR shares on next interest accrual). Emit `Repay` event, including `remainingDebt` if any (or event can implicitly mean amount repaid).
  * [ ] **(CU=3)** **Edge cases**: If borrower had no debt (borrowShares=0), revert `NoDebt`. If `sharesToRepay` after conversion equals 0 (e.g., tiny amount less than a share’s worth), we can choose to consider that too small to affect (could revert or just do nothing). Usually not an issue for reasonable inputs. Pause guard: no specific pause for repay (repay is risk-reducing, but could tie to PAUSE\_BORROWS or a PAUSE\_REPAY if separate). *Exit:* Repay reduces debt balances correctly; any leftover tokens (if not added to liquidity) are accounted as idle (invariant totalBorrowShares <= totalShares may require adjusting totalShares if we burned shares or increased liquidity accordingly).

* **Phase 4:** *Fee Reinvestment Logic*

  * [ ] **(CU=5)** Implement **`reinvestFees(poolId)`** keeper function: **Pre-checks** – require `pendingFees[poolId]` non-zero (or above a threshold to avoid dust reinvest), else revert `InsufficientFeesAccumulated`. Also ensure `block.timestamp - lastReinvestTime[poolId] >= reinvestCooldown` (e.g., 1 hour) or revert `ReinvestmentCooldown`. If global `reinvestmentPaused` flag is true (set by governance in emergencies), revert as well.
  * [ ] **(CU=4)** **Execute reinvest**: read `pendingFees[pool]` (struct of uint256 token0, token1). Set `pendingFees[token0]=pendingFees[token1]=0` (reset counters). If both values are zero (or dust) and we didn’t catch earlier, just return (or revert InsufficientFees). Call PoolManager to add liquidity to FR position with those token amounts (similar to deposit). Get `newSharesMinted`.
  * [ ] **(CU=4)** **Distribute shares**: determine protocol cut vs LP cut. For example, get `feeSplit = policyManager.getFeeSplit(poolId)` (e.g., 10% protocol). Calculate `protocolShares = newShares * feeSplit`. Increase `totalPolShares[pool]` by `protocolShares` (this tracks protocol-owned portion in slot21). The remaining shares are implicitly allocated to existing LPs (we do **not** increment any user’s shareBalance; thus everyone’s percentage ownership dilutes such that their share of pool value increases by 90% of fees). In effect, totalShares increases by `newShares` while user shares stay same, so each share is worth more underlying – which is equivalent to users getting their proportionate fees.
  * [ ] **(CU=2)** **Emit event & update timestamp**: maybe emit `FeesReinvested(poolId, token0Amt, token1Amt, newShares)` event (not explicitly in spec, but could log). Update `lastReinvestTime[poolId] = block.timestamp`. *Exit:* Fee reinvest fully implemented – tested by injecting dummy fees and calling function (to be done in P5). It leaves no fees lingering (**INV-2.3**) and obeys cooldown and pause controls.

**Sprint 2 Complexity Heatmap:** P1: 16 CU | P2: 19 CU | P3: 12 CU | P4: 15 CU | **P5: 26 CU**. *Dev phases are \~±10% (avg \~15.5 CU), P5 \~25% of total (\~26/104).*

### Sprint 3 – LP NFT Collateral Integration

* **Phase 1:** *Opening Concentrated LP Positions*

  * [ ] **(CU=7)** Implement **`openLPPosition(poolKey, tickLower, tickUpper, amt0Desired, amt1Desired, amt0Min, amt1Min)`**. Use SpotHook (authorized) to pull `amt0/amt1` from user if needed. Pre-conditions: not paused (`PAUSE_POSITIONS`). If `tickLower >= tickUpper`, revert `InvalidTickRange` (except if equal, which is allowed for LO but here likely require lower < upper for a normal position).
  * [ ] **(CU=6)** **Source liquidity**: Determine actual token amounts needed. If user provided both amt0 & amt1, use as is; if they provided only one asset (amt1=0 or amt0=0), they’re effectively adding one-sided – Uniswap will mint liquidity accordingly. If user has idle tokens in vault (token0Claims/token1Claims), use those first (reduce their balances). If further tokens needed, pull from user wallet via SafeTransferFrom (SpotHook call). If user doesn’t have enough collateral (no idle and not enough FR shares to convert if we allowed conversion – but in this phase we assume providing external tokens), then revert `InsufficientCollateral`.
  * [ ] **(CU=5)** **Mint position**: Call `PositionManager.mintPosition(poolId, tickLower, tickUpper, liquidity)` – we need to compute `liquidity` param for Uniswap. We can compute liquidity amount from provided tokens and current price: get sqrtPrice from Oracle or PoolManager, then `liquidity = min( amt0 * (sqrtPrice) , amt1 / (sqrtPrice) )` for the range such that one asset is fully used. Simplify by passing `amount0Desired, amount1Desired` to PositionManager; it will return how much was used and the liquidity. Ensure returned used amounts ≥ `min` constraints (amt0Min/amt1Min) or revert `SlippageFailure`. Receive a new `positionId` (NFT).
  * [ ] **(CU=4)** **Record position**: Store mapping `positionMeta[positionId] = { owner: user, poolId, tickLower, tickUpper, liquidity, … }` (slot16/17). Increment `userVault.positionCount`. Do **not** credit user with any new “shares” – this liquidity is separate from FR shares. We treat it as new collateral type. Emit `LPPositionOpened(owner, positionId, PoolKey, lowerTick, upperTick, liquidity)` event. *Exit:* Users can open NFT positions; their net collateral stays same (just reallocated), so no solvency change initially.

* **Phase 2:** *Closing Concentrated LP Positions*

  * [ ] **(CU=6)** Implement **`closeLPPosition(positionId, to)`**. Pre-conditions: position exists in mapping and `msg.sender` is owner (else revert `PositionNotFound/NotOwner`). Fetch metadata. If already zero liquidity (possibly from a prior partial withdraw of all? But we always withdraw all on close, so likely not needed), revert `NothingToClose`.
  * [ ] **(CU=5)** **Solvency check**: If user has outstanding debt, simulate removal of this position’s value from their collateral. Compute position’s current value: query PoolManager or Oracle for amounts they’d get if removing all liquidity now (use `PositionManager.collect` with 0 liquidity removal to see fees, and consider principal which will be returned). Or simpler: get current token0, token1 amounts via a view (some v4 function to estimate or do a dry-run). Then check: if `debt > collateral_remaining_after`, revert `WouldBecomeUndercollateralized` (or use `UndercollateralizedClose`). Essentially, if `userDebt > (userTotalCollateral - positionValue)*maintCF`, block closing.
  * [ ] **(CU=5)** **Remove liquidity**: Call `PositionManager.burnPosition(positionId)` to remove all liquidity. This returns the underlying tokens and also any accrued fees to the vault. Since user is closing, we by default treat it as a withdrawal: transfer tokens to `to` (if `to == user` typically). However, spec suggests assuming they withdraw it out of vault on close. We do that: for each token received, if `to` is external, transfer out; if `to` is set as vault (user wants to keep collateral in vault), we could alternatively credit idle balances – we allow both by honoring the `to` address.
  * [ ] **(CU=3)** **Update state**: Delete `positionMeta[positionId]`, decrement `userVault.positionCount`. Emit `LPPositionClosed(owner, positionId, liquidity)` event. If assets withdrawn to user, also emit standard `Withdraw` events for transparency (or the LPPositionClosed event suffices with amounts as separate event LPFeesCollected if needed). *Exit:* Users can close positions and retrieve tokens, unless it would drop their collateral below maintenance (tested). Positions count and records update correctly.

* **Phase 3:** *Collecting Fees from LP Positions*

  * [ ] **(CU=4)** Implement **`collectLPFees(positionId, to)`**. Verify position exists and owner is caller (or we might allow keeper to call on behalf? Usually owner collects fees). Call `PositionManager.collectFees(positionId)` – this will transfer any accrued token0/token1 from that NFT to the vault (since vault is the actual NFT holder contract). We receive amounts for token0 and token1.
  * [ ] **(CU=3)** **Distribute fees**: If `to == address(0)` or `to == user`? Actually interface says `recipient`, likely meaning the user wants to send fees directly out or to themselves. But to keep collateral, default could be crediting vault balances. Likely better: always credit the user’s idle balances in vault (so they stay as collateral by default). If user truly wants them out, they can withdraw idle after. This approach is safer (doesn’t reduce collateral unexpectedly). So, increment `userVault.token0Claims` and `token1Claims` by the collected amounts. Emit `LPFeesCollected(owner, positionId, amount0, amount1)` event.
  * [ ] **(CU=2)** Edge: If no fees accrued (both zero), function can simply emit event with 0s or do nothing (not critical). No pause needed (collecting fees is risk-neutral). *Exit:* Users can claim fees without closing positions, increasing their idle collateral. This encourages keeping collateral in system. Event confirms fee extraction.

* **Phase 4:** *Idle Asset Management & Solvency Integration*

  * [ ] **(CU=4)** Implement **`depositToVault(poolId, amount0, amount1)`** for idle deposits (REQ-F-03). This simply transfers the specified tokens from user into vault custody and increases `userVault.token0Claims`/`token1Claims`. Pause guard: `notPaused(PAUSE_DEPOSITS)` (or a specific PAUSE\_IDLE if separate). Use SafeTransfer, require amounts > 0. There’s no slippage or share calculation – 1:1 deposit of tokens as idle collateral.
  * [ ] **(CU=4)** Implement **`withdrawFromVault(poolId, amount0, amount1, to)`**. Ensure user’s idle balances are ≥ requested amounts (else revert `InsufficientLiquidity`). Decrease their claims balances and transfer tokens to `to`. Pause guard: `notPaused(PAUSE_WITHDRAWALS)`. If user has debt, this is a straight reduction of collateral – so call `_checkSolvency` after deducting requested tokens: if debt now exceeds remaining collateral\*maintCF, revert `Undercollateralized`. This ties idle withdrawals into the same solvency check used for share withdrawals.
  * [ ] **(CU=4)** **Solvency check unification**: Update `_checkSolvency(user)` to sum up all forms of collateral: (a) FR share collateral = `user.shareBalance * price` (with lockedShares non-withdrawable but counts for user?), (b) idle tokens = their face value (1:1), (c) each LP position’s value = compute via current tick (maybe use a helper that sums token0Claims + token1Claims + approximated value of each NFT by formula or oracle). The worst-case ledger approach (INV-WCLedger) is not explicitly implemented, but to be safe, perhaps apply a haircut to LP NFT value (e.g., count only 80% of its current value as collateral) to account for range volatility. Ensure this check is called after any operation that could reduce collateral (withdraw, closeLP, cancelLO, etc.).
  * [ ] **(CU=2)** **Debt cross-check**: Also ensure when borrowing, we consider idle tokens and LP positions: in `borrow()`, the collateralValue we computed should include idle balances and positions (with appropriate factors). Our earlier borrow implementation assumed one pool’s shares as collateral; in multi-collateral scenario, governance likely sets each asset type’s factor (the PolicyManager might provide factors for token collateral vs LP). We'll incorporate that: e.g., token collateral might have higher factor if stable. We fetch those from PolicyManager if available (if not, assume 100% for simplicity or same as FR shares). *Exit:* Idle deposit/withdraw implemented, and the solvency logic now accounts for all collateral types. This closes any gaps where user could withdraw idle or close positions and escape solvency checks.

**Sprint 3 Complexity Heatmap:** P1: 7 CU | P2: 7 CU | P3: 9 CU | P4: 10 CU | **P5: 23 CU**. *Dev phases \~±15% (slightly higher variation due to integrated complexity), testing \~25% of total (\~23/56).*

### Sprint 4 – Limit Orders & Trading Features

* **Phase 1:** *Limit Order Struct & Placement*

  * [ ] **(CU=6)** Add **`LimitOrder` struct and storage**: `struct LimitOrder { uint256 id; address maker; PoolKey poolKey; bool isBuy; uint128 liquidity; uint256 tick; uint64 expiry; }`. Add `mapping(uint256 => LimitOrder) limitOrders` at slot 25 and `uint256 nextOrderId` at slot 26. Initialize `nextOrderId = 1`.
  * [ ] **(CU=5)** Implement **`placeLimitOrder(poolKey, isBuy, amount, price, expiry)`**. Pre-check: not paused (`PAUSE_TRADING`). Compute target `tick` from given `price` (use Uniswap tick math or PoolManager util). If `expiry > 0`, record it; if `expiry < block.timestamp`, revert `InvalidExpiry`. Transfer `amount` of input token from user: if `isBuy==true`, they supply token1 expecting to receive token0 later; if false, supply token0. Use SpotHook (so user calls via batch or an adapter that pulls funds).
  * [ ] **(CU=6)** **Mint one-tick position**: Call `PositionManager.mintPosition(poolId, tick, tick, liquidity)` – since tickLower == tickUpper, this creates a one-tick-wide LP position (essentially a limit order). Provide `amount` as one-sided liquidity (all in one token). The PositionManager will calculate `liquidity` that corresponds to that deposit at that tick. Store returned `liquidity` in LimitOrder struct. We intentionally do **not** credit the user with vault shares for this – the tokens are now inside the Uniswap pool as a pending order.
  * [ ] **(CU=3)** **Save order**: populate LimitOrder struct: `id = nextOrderId++`, `maker = user`, `poolKey`, `isBuy`, `liquidity`, `tick`, `expiry`. Map it in `limitOrders`. The NFT representing this liquidity remains held by vault (same PositionManager used as for LP positions). Emit `LimitOrderPlaced(orderId, maker, poolKey, isBuy, amount, price, expiry)` event. *Exit:* Limit orders can be placed and recorded. They behave like special LP positions isolated by tick.

* **Phase 2:** *Executing Limit Orders*

  * [ ] **(CU=5)** Implement **`executeLimitOrder(orderId, fillAmount)`** for keepers. Look up order; require order exists and not already fully filled/cancelled. If `block.timestamp >= order.expiry && order.expiry != 0`, revert `OrderExpired(orderId)` (keeper should cancel instead). Determine `maxFill` = remaining liquidity in order. If `fillAmount == 0` or > `maxFill`, set `fillAmount = maxFill` (execute as much as possible). Next, check if price condition met: get current pool sqrtPrice; if `isBuy` order, require current price <= order.tick (meaning price has dropped to or below target, thus order started filling); if `isSell`, require price >= order.tick. If condition not met, revert `OrderNotExecutable`.
  * [ ] **(CU=6)** **Remove liquidity**: Call `PositionManager.decreaseLiquidity(positionId, fillAmount)` on the underlying NFT (we may need to track `positionId` in LimitOrder; perhaps reuse the NFT id as order id – but we chose separate id. We could store `positionId` in LimitOrder too for this call). This removes `fillAmount` worth of liquidity from the order’s position. Then call `PositionManager.collectFees(positionId)` to withdraw the owed tokens from that removed portion. Because it’s a one-tick position: if isBuy, removing liquidity yields token0 (bought asset) from the pool (and possibly some unearned token1 back if not fully executed); if isSell, yields token1. The mechanics: partial decrease effectively realizes the trade for that portion.
  * [ ] **(CU=4)** **Distribute outputs**: Credit the output tokens to the user’s idle balances (e.g., add token0 to user if it was a buy order execution). Also, any portion of the input asset that wasn’t used (in partial fill scenario, some of the one-sided liquidity might not have converted yet but when removing, you get it back) will also come out – that essentially reduces the remaining order. We will account that in remaining liquidity anyway.
  * [ ] **(CU=3)** **Update order**: subtract `fillAmount` from order’s stored `liquidity`. If now `order.liquidity == 0`, the order is fully filled – we can either delete it here or mark it for cleanup (we’ll leave it for cancel to remove, but we might as well remove to free storage). Emit `LimitOrderExecuted(orderId, fillAmount, fillPrice)` event, where fillPrice could be current market price or computed average price of this fill (optional detail). *Exit:* Keepers can execute the filled portion of orders when conditions are met, transferring purchased assets to users. Partial fills leave order open with reduced liquidity.

* **Phase 3:** *Direct Swaps Implementation*

  * [ ] **(CU=5)** Implement **`swap(poolId, zeroForOne, amountIn, amountOutMin, to)`**. This function allows a user to trade immediately using vault liquidity. Pre-check: not paused (`PAUSE_TRADING`). Use SpotHook or an allowance to pull `amountIn` of input token from the user (or if user already has that token in vault idle, we could allow using internal balance – to support use-case: user has token0 in vault but wants token1, a swap could directly convert it without leaving vault). If `to` is the vault or user’s own address, we handle accordingly.
  * [ ] **(CU=4)** **Perform swap**: Call Uniswap V4 PoolManager’s `swap(poolId, zeroForOne, amountIn, amountOutMin)` (assuming such an interface; if not, integrate via SpotHook by initiating a small swap). This will internally swap through the pool. Ensure it returns or we can calculate `amountOut`. If `amountOut < amountOutMin`, the pool contract would revert on its own (slippage check). No intermediate state changes in vault except final tokens out.
  * [ ] **(CU=4)** **Handle output**: If `to` is an external address (user’s wallet), transfer `amountOut` of output token to them – effectively the swap acts like withdraw of output and a use of input collateral. If `to` is set to a special address (like vault or same user’s vault balance), we credit the output to their idle balance (so they swapped assets within vault). Deduct or lock the `amountIn` from their collateral: since we pulled from them, if it was from idle, their idle balance goes down; if from wallet, nothing to deduct in vault.
  * [ ] **(CU=2)** Emit a `SwapExecuted(poolId, user, tokenIn, tokenOut, amountIn, amountOut)` event (if defined; spec doesn’t explicitly but include for completeness). *Exit:* Users can swap assets directly. This is tested by swapping one asset to another and verifying output and balances.

* **Phase 4:** *Order Cancellation & Final Orderbook Mgmt*

  * [ ] **(CU=5)** Implement **`cancelLimitOrder(orderId)`**. Require order exists. If `msg.sender` is order.maker or `msg.sender` is governance (a designated role to force-cancel, e.g., if expired or emergency), allow. Otherwise revert `UnauthorizedCancel`. Fetch order.
  * [ ] **(CU=5)** **Remove remaining liquidity**: Retrieve associated `positionId` (if we stored it or map orderId->positionId). Call `PositionManager.decreaseLiquidity(positionId, order.liquidity)` for whatever liquidity remains. This will return the unfilled portion of the input asset plus any small filled output portion still in the position (if partially filled and not executed yet, Uniswap positions hold accumulated output as “fees” which will also be returned here). Then call `PositionManager.collect(positionId)` to get all tokens out. Now we have: original asset remaining + maybe some output asset from partial fills that weren’t executed by keepers.
  * [ ] **(CU=4)** **Return assets**: Credit all retrieved tokens to user’s idle balances (so they effectively get back what was left of their order). This means if their order was unfilled, they get 100% of original tokens back; if partially filled, they get the remainder of input plus any output that was sitting in the position. The user’s overall asset mix now reflects whatever partial execution happened – which is exactly what would happen if the order had been gradually filling and they then cancel the rest. Check solvency: canceling returns collateral to user, which can only improve their position (no check needed, but as a safeguard, we ensure no negative effect – if one asset has different collateral factor than the other, theoretically converting could lower quality; but since we add both assets, total value rises or stays, they should be fine). If a scenario arises where completing a fill would have helped solvency (rare), we consider that too edge to worry – cancel is user-initiated typically because they want their assets back.
  * [ ] **(CU=2)** **Cleanup**: Delete `limitOrders[orderId]`. Burn or release the NFT (since liquidity = 0, NFT is effectively empty; we can call a burn or just let it with vault but unused – better to burn via PositionManager to free ID). Emit `LimitOrderCancelled(orderId)` event.
  * [ ] **(CU=2)** **Expiry handling**: If an order expired, we expect governance or a keeper calls cancel. We allow cancel from anyone if `now > expiry` (or specifically from guardian). Include in logic: if expired and not already canceled, `msg.sender == maker OR now>expiry` as condition to allow. This ensures expired orders don’t linger (keeper can cancel and claim gas refund via output if any, though output belongs to maker anyway). *Exit:* Cancel returns remaining assets to user and cleans orderbook. All LimitOrder lifecycle actions are now covered.

**Sprint 4 Complexity Heatmap:** P1: 6 CU | P2: 7 CU | P3: 7 CU | P4: 8 CU | **P5: 24 CU**. *Dev phases \~balanced (±15% of \~7 CU avg), P5 \~25%.*

### Sprint 5 – Liquidations, Insurance & Batch Integration

* **Phase 1:** *Partial Liquidation Implementation*

  * [ ] **(CU=8)** Implement **`liquidate(address borrower, bytes32 poolId, uint256 repayAmount, address to)`** (partial, V9). This will likely reside in VaultManagerCore, callable by anyone (keeper). Preconditions: not paused (`PAUSE_LIQUIDATIONS` perhaps not set, though usually we don’t pause liquidations except in extreme cases). Check borrower’s health: compute their total borrow vs collateral across all pools or at least this pool. If using per-pool collateral, ensure `borrowerDebtShares > 0` and `borrowerDebtValue >= borrowerCollateralValue * maintCF` (i.e., DTR ≥100%). If not undercollateralized, revert `LiquidationNotAllowed()`. Determine **repayShares**: if `repayAmount` (in tokens) is specified, convert to shares (repayShares = amount / sharePrice). If not specified (could be 0 meaning “max partial”), set repayShares such that after this repayment, borrower’s DTR drops to, say, 90% (some safe buffer). That is solve for repay such that `(debt - repay) <= collateral * initCF`. Solve roughly `repay = debt - collateral*initCF`. Cap repayShares not to exceed borrower’s actual `borrowShares`.
  * [ ] **(CU=6)** **Execute repay**: Transfer required tokens from `msg.sender` (liquidator) to vault. Use `repayShares` logic from S2P3: reduce borrower’s `borrowShares` by repayShares, reduce `totalBorrowShares`. Mark how much debt in value this covers (debtPaid = repayShares \* sharePrice). Accrue interest first for accuracy.
  * [ ] **(CU=6)** **Seize collateral**: Calculate collateral value to seize = debtPaid \* 1.10 (110% of debt repaid). We will seize assets equal to this value from borrower’s vault. Seize in order: first, idle token balances of borrower (take proportional amounts of token0/token1 up to 110% value; if multiple assets, convert to a single value via price and take combination – simpler approach: seize proportional across their collateral types). Next, if needed, seize FR shares: compute `sharesToSeize` such that `sharesToSeize * sharePrice = collateralNeededRemaining`. Burn those shares from borrower’s balance and correspondingly reduce `shareData.totalShares` (effectively removing liquidity). If still needed (rare if not enough FR shares), seize LP positions: choose one or more of borrower’s LP NFTs, ideally the most liquid. For simplicity, possibly seize entire smallest positions until value satisfied (this could overshoot; in partial liq, probably borrower has enough fungible collateral not to need NFT seizure – we assume worst-case might need to seize one position). Mark any seized position as “seized” (could transfer NFT to LiquidationEngine contract for auction, but spec indicates partial liq is internal, full liq might involve auctions). For partial, let’s assume we stick to fungible collateral.
  * [ ] **(CU=4)** **Transfer to liquidator**: Transfer seized tokens (and any immediately liquidated collateral) to `to` (liquidator’s address). For any shares seized, we convert to tokens by withdrawing from pool instantly (so liquidator gets tokens, not shares). This is effectively a vault withdraw on behalf of borrower going to liquidator. Emit `Liquidation(liquidator, borrower, poolId, repaidDebt, seizedCollateral)` event with values in terms of underlying tokens (or share counts). Borrower still has some collateral and possibly some debt left. *Exit:* Partial liquidation completed – tested by scenario where borrower is just slightly underwater.

* **Phase 2:** *Full Liquidation Implementation*

  * [ ] **(CU=7)** Extend **`liquidate(...)`** for full liquidation (V12). Detect if borrower’s *total* debt far exceeds collateral (e.g., collateralValue < debt \* 100%). If after accruing interest, `debt > collateral * 100%`, it’s insolvent. In that case, we will attempt a full liquidation. Steps: liquidator should repay as much as possible given collateral – per spec, liquidator gets 90% of collateral value. So compute `payDebt = collateralValue * 0.9`. Cap it at total debt (liquidator never pays more than debt). Transfer `payDebt` amount from liquidator to vault to cover that portion of debt. Subtract equivalent `payDebtShares` from borrower’s debt (if `payDebt` < total debt, there’s `badDebt` remaining = totalDebt - payDebt). Set borrower’s debt to 0 (effectively forgiving the rest, which becomes protocol loss).
  * [ ] **(CU=6)** **Seize all collateral**: gather all borrower’s collateral (idle tokens, FR shares, LP NFTs). Essentially empty their vault: whatever tokens they have idle, plus withdraw all their FR shares from pool, plus take ownership of all their LP positions. Consolidate all that into a “collateral pot”. Compute its total value = X (should equal the collateralValue used earlier). Now distribute collateral: per spec, liquidator gets 100% of collateral (since they paid 90% worth) – effectively they profit 10%. But to formalize: we could send *90%* of each asset to liquidator and *10%* to treasury (or insurance). However, since we had liquidator pay only 90% of X, giving them all X means they indeed got 10% extra value. Alternatively, if we wanted to follow phrase “giving 90% to liquidator”, that could mean giving them 90% of collateral and leaving 10% with protocol. But then liquidator would have paid 90% debt but only get 90% collateral – no profit, so likely spec meant they pay 90% and get 100%. We proceed: transfer **all seized collateral** to `to` (liquidator), but mark the event such that protocol incurred a shortfall equal to 10% of X (since liquidator didn’t cover that).
  * [ ] **(CU=4)** **Record bad debt**: if total debt > payDebt, record `badDebt = totalDebt - payDebt`. This is the amount of debt forgiven. Decrease `totalBorrowShares` by the shares that were actually repaid (payDebt portion) but note that `totalBorrowShares` might now not match actual totalShares because we removed collateral. Alternatively, we could keep the bad debt as phantom borrowShares to maintain equality and let coverBadDebt handle it – but easier: subtract them to not count as debt, and instead keep a `badDebtAmount` in storage for that pool. Emit `Liquidation` event with `repaidDebt = payDebt` and `seizedCollateral = X` (full collateral). Borrower’s account can be marked closed (no collateral, no debt). *Exit:* Full liquidation logic done – tested with scenario collateral worthless relative to debt.

* **Phase 3:** *Insurance Fund & Bad Debt Coverage*

  * [ ] **(CU=4)** Implement **`depositInsurance(amount)`** (governance-only): This moves `amount` of stable asset (assuming one of the vault assets or a stable coin) from Treasury into vault’s insurance reserve. We can simply treat it as idle token in a special “insurance” account or increment a separate `insuranceBalance`. Emit `InsuranceFundUpdated(caller, +amount)` event. (If multiple assets, might restrict insurance to a single denom, e.g., token0 if that’s a stable).
  * [ ] **(CU=4)** Implement **`withdrawInsurance(amount to)`**: governance can pull funds out of insurance (for treasury usage if surplus). Transfer specified `amount` to `to` address, reduce insuranceBalance, emit event. Only allow if insuranceBalance >= amount.
  * [ ] **(CU=5)** Implement **`coverBadDebt(poolId, amount)`** (governance-only). This function addresses any recorded bad debt in a pool from full liquidation. If `badDebtPool[poolId]` (a storage counter) > 0, then on call: transfer `amount` from insuranceBalance (or directly from msg.sender if we require immediate funding) to vault, effectively adding liquidity equal to that amount. We use it to cancel out bad debt: options: (a) If we left the bad debt as unaccounted (meaning totalBorrowShares now is lower than it “should” be relative to totalShares), we can simply increase totalShares by minting protocol-owned shares equivalent to this amount and *not* increasing debt (thus assets added with no new debt covers gap). Or (b) if we tracked badDebt as a counter, we just reduce the counter. Implement simpler: assume insurance deposit covers exactly the shortfall in tokens, we call PoolManager to add those tokens as liquidity (mint new shares) which are protocol-owned (increase totalPolShares). This effectively increases totalShares and brings utilization down. Set `badDebtPool[poolId] = max(0, badDebt - amount)` (likely it goes to 0 if fully covered). Emit `BadDebtCovered(poolId, amount)` event.
  * [ ] **(CU=2)** Edge: If partial cover (amount < badDebt), badDebt remains (maybe multiple cover calls needed). We won’t allow user actions in a pool with badDebt except cover – but not explicitly needed; the utilization might be >100% which breaks invariants until covered – governance is expected to fix promptly. *Exit:* Insurance and recovery in place – tested by simulating a full liquidation leaving badDebt and then covering it, ensuring invariants restore.

* **Phase 4:** *BatchEngine Finalization & Invariant Checks*

  * [ ] **(CU=7)** Implement **batch ordering & execution** in `executeBatchTyped(Action[] actions)`. For each `actions[i]`, parse the first byte as `code` and remaining as `data`. Build two lists: phaseA\_actions and phaseB\_actions. For each action: if code is in {V0, V3, V10, V13, etc.} (risk-reducing or neutral), assign to Phase A; if code in {V1, V2, V4, V5, V6, V7, V8, V9, V11, V12} (risk-increasing or collateral-removing), Phase B. Use table 5.7.a as reference. Preserve original relative order within each phase. Then create an execution list: PhaseA followed by PhaseB.
  * [ ] **(CU=6)** **Selector guard (T8)**: Before executing, loop through all actions to ensure none have blacklisted selectors. We maintain a set (hardcoded or in contract storage loaded from `selectors.json`) of forbidden function selectors: e.g., `VaultManager.liquidate`, `coverBadDebt`, and potentially `executeBatch` itself (to prevent batch-in-batch). If any action’s `code` corresponds to these, revert with `BatchDisallowed(selector)` or a generic error.
  * [ ] **(CU=6)** **Execute**: Loop through sorted actions: for each, use a `delegatecall` or internal function call to execute the corresponding VaultManagerCore function with the given data. We likely have each action as an internal function (as implemented in S1–S4). We ensure `nonReentrant` is held (the BatchEngine itself or VaultManager should have it – we might make BatchEngine a separate contract without state and call VaultManager’s functions externally, but simpler is to integrate in one contract and call internal, which respects the same single reentrancy guard). After each action, run quick invariants: e.g., call `_checkSolvency(batchUser)` for the user if any state changed, to ensure no intermediate undercollateralization. Also ensure `totalBorrowShares <= totalShares` still (should always except possibly after a risk-increasing action – if it violates here, something is wrong and revert). If any sub-call reverts, catch it and bubble up (the whole batch will revert automatically).
  * [ ] **(CU=3)** **Events and return**: On success (no revert), emit `BatchExecuted(caller, actions.length, true)` event. If it reverted, the entire state is rolled back (Solidity revert). We emit nothing in that case (the revert reason from sub-call propagates or we can emit `BatchExecuted(..., false)` just before reversion via try-catch but not necessary). Implement `simulateBatch(actions)` as `view` that replicates sorting and calls each action’s logic in a **try/catch that ignores state** – easier approach: we might make VaultManagerCore’s internal functions pure calculations where possible and simulate effect – complexity is high, so instead, we’ll test via forging calls. We leave `_simulateBatch` as a stub or to-do for now due to time (assuming Foundry can simulate via dry-run).
  * [ ] **(CU=2)** **Restrict direct calls**: Now that BatchEngine is functional, we expect normal users to use it. We can add modifiers to core functions (deposit, withdraw, etc.) like `onlyBatchOrHook` – meaning `require(msg.sender == BatchEngine || msg.sender == authorizedHook || msg.sender == owner)` – to prevent direct EOA usage. This enforces REQ-F-13. In tests, we keep them open or set BatchEngine address to a test contract to simulate. Production will set these restrictions. *Exit:* BatchEngine enables atomic multi-action execution with safety. All invariants checked after each sub-action maintain system integrity (reordering ensures invariants not violated mid-batch). Comprehensive tests will confirm.

**Sprint 5 Complexity Heatmap:** P1: 8 CU | P2: 9 CU | P3: 9 CU | P4: 8 CU | **P5: 25 CU**. *Dev phases balanced (\~±10% of \~8.5 CU avg), P5 \~25%.*

* **Phase 5:** *Final QA & Invariant Testing*

  * [ ] **(CU=10)** **End-to-end scenario tests**: Create complex scenarios combining all features: e.g., User A deposits, opens an LP position and a limit order; borrows against them; price moves triggering partial fill of order; User A does a batch: repay some debt and withdraw collateral in one go; Keeper liquidates User A’s remaining position partially; etc. Ensure all events and end states are correct. Another scenario: multiple users interacting (to test no cross-talk issues on global invariants).
  * [ ] **(CU=5)** **Invariant Fuzz Test (Foundry)**: Write a fuzz test that randomly sequences actions for a single user (and possibly random small number of users) – including deposits, borrows, swaps, opening/closing positions, placing/canceling orders, and also occasional liquidations by a simulated keeper if someone goes underwater. Use assertions to verify at all times: (a) `totalAssets >= totalLiabilities` (no global insolvency unless we explicitly allow badDebt for test, then ensure it’s covered by end), (b) no user becomes undercollateralized without a liquidation event following, (c) no funds are lost or gained magically (all token balances accounting check), (d) all invariants from spec remain true (we can encode each INV-2.x/3.x as an assert, or use the invariants cheat sheet from Appendix G). Run this fuzz test through many iterations.
  * [ ] **(CU=5)** **Gas & performance tests**: Measure gas costs of each core function in typical scenarios: deposit, withdraw, borrow, repay, open position, swap, execute batch with 2-3 actions, partial liquidation, etc. Compare against targets (spec listed some, e.g., borrow \~115k). Optimize if any exceed budgets (e.g., if limit order placement is too high, consider reducing storage writes or making some calcs off-chain). Ensure batch execution gas is acceptable for a reasonable batch (say 5 actions \~ 2x the cost of doing them separately minus overhead).
  * [ ] **(CU=5)** **Security assertions**: Test edge cases like reentrancy attempts: try to call executeBatch from within a hook callback (should be prevented by nonReentrant). Test pause toggles mid-batch (if guardian pauses during batch, since batch is atomic, it won’t affect ongoing execution but will stop next batch). Simulate oracle returning extreme values (0 or very large) to see system behavior (should freeze borrowing or liquidate if 0 price). Test authorized roles: ensure only authorizedHook can call deposit (we simulate hook calls in tests), only governance can call insurance or coverBadDebt (simulate with governance address in test).
  * [ ] **(CU=5)** **Final review and mapping**: Cross-verify every requirement (REQ-F-01 to 19) is either covered in implementation or explicitly tested. E.g., REQ-F-14 about batch atomicity – confirmed by batch tests; REQ-F-18 about reordering – confirm via a test where user submits a batch with withdraw then repay (provided as such, our engine will reorder to repay then withdraw, check outcome). Ensure all INV-x.x from Appendix G are either enforced in code or hit by an invariant test. Document traceability matrix (as done above) and double-check values (e.g., utilCap default 95% from config is indeed used).
  * [ ] **(CU=0)** **🚀 Deployment prep**: Remove any dev-only allowances (e.g., enabling direct calls we used in tests). Set `BatchEngine` contract address (if separate) in VaultManagerCore’s allowed callers. Lock in governance addresses (owner = Timelock, guardian = multisig). Generate final storage layout report and function selector list to archive with deployment. *Exit:* V2 code is fully tested, balanced, and ready for audit. All critical invariants are either proven by tests or runtime checks. The system is robust against known risks and meets the spec’s functional and security requirements.

**Sprint 5 Complexity Heatmap:** P1: 8 CU | P2: 9 CU | P3: 9 CU | P4: 8 CU | **P5: 25 CU**. *Dev phases total \~34 CU (balanced within \~±6%), and the QA phase \~25 CU ≈ 42% of sprint effort* – this is higher than a quarter due to comprehensive testing, but acceptable given the critical nature of final QA. The overall distribution across all sprints keeps each development phase fairly even, with testing phases accumulating \~25–30% of each sprint's workload, aligning with project quality goals.\*
