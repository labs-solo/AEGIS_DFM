Updating Contracts for Uniswap V4 Compatibility

Updating the FullRangePoolManager and FullRangeLiquidityManager to work with a deployed Uniswap v4 AMM requires changes to align with Uniswap v4’s PoolManager architecture and new best practices. Below we outline the key updates needed in the contracts and the test suite:

Integration with Uniswap V4’s PoolManager

Uniswap V4 Architecture: Uniswap v4 uses a single PoolManager contract to manage all pools, instead of individual pool contracts per pair. Each pool is identified by a PoolKey (token pair, fee tier, tick spacing, and hook address) rather than a unique address. Our contracts should use the IPoolManager interface for pool operations (initialize, modifyLiquidity, swap, etc.) and handle the new flash accounting model (delayed settlement of token transfers until end of transaction).

Callback Validation: In Uniswap v4, certain operations (like flash swaps or batched actions) use callbacks into the caller’s contract. We must implement and strictly validate these callbacks to ensure only the genuine Uniswap V4 PoolManager can trigger them. For example, if our contract implements IUnlockCallback or similar, the first line in the callback function should verify msg.sender is the authorized PoolManager address ￼. This is analogous to Uniswap v3’s practice of requiring the call originate from the correct pool contract, and prevents malicious actors from calling our callback directly. In practice:
	•	Store the PoolManager’s address (passed in or known for the deployment network) and use it in a require check in each callback. For instance: require(msg.sender == address(poolManager), "Only PoolManager can call");. This ensures proper callback validation, rejecting any unexpected calls. (The Uniswap v4 integration guide uses a similar OnlyPoolManager check in callbacks ￼.)

Using PoolManager APIs: Update any direct pool interactions to go through poolManager. For adding liquidity, use poolManager.modifyLiquidity(poolKey, params, hookData) instead of calling a pool contract. For swaps, use poolManager.swap(poolKey, params, hookData). Make sure to construct the PoolKey (tokens, fee, tick spacing, hook) correctly and pass an empty hookData if no custom hooks are used. If the FullRangePoolManager previously assumed a separate pool contract, refactor it to work with the singleton. For example, remove any usage of a Uniswap v3 factory to derive pool address; instead, rely on poolManager and the PoolKey structure.

Token Handling and Settlement: Uniswap v4 introduces flash accounting, which means token transfers can be deferred until after operations complete ￼ ￼. To accommodate this, when adding liquidity or swapping via our contracts, ensure that token transfers to the pool happen via the new settlement functions. For example, after calling poolManager.modifyLiquidity or swap, obtain the BalanceDelta return values. If the delta indicates our contract owes tokens (negative delta), call poolManager.settle(currency) after transferring the owed tokens from our contract to the PoolManager (for ERC20, use SafeTransferLib.safeTransferFrom to send tokens to PoolManager, then call settle; for ETH, send value in the call to settle) ￼ ￼. If the delta indicates the pool owes tokens to us (positive delta), use poolManager.take(currency, to, amount) to withdraw them ￼. This explicit settlement process replaces the implicit callback token transfer from Uniswap v3 and must be handled correctly for the contracts to work with the real PoolManager.

Gas Efficiency Improvements

Optimizing gas usage will make our liquidity operations cheaper and align with Uniswap v4’s emphasis on efficiency. Key changes include:
	•	Use Solmate’s Gas-Optimized Libraries: Replace heavier utility libraries with Solmate equivalents for common operations. For example, use Solmate’s SafeTransferLib for ERC-20 transfers instead of OpenZeppelin’s SafeERC20. Solmate is “specifically designed to provide gas-efficient implementations of common Solidity operations.” ￼ In practice, SafeTransferLib.safeTransferFrom(token, from, to, amount) uses lower-level calls and inlines error checks, saving up to ~1300 gas per transfer compared to OpenZeppelin’s version. Similarly, use Solmate’s FixedPointMathLib or other utilities if performing math-heavy computations, as they often use unchecked arithmetic for lower gas cost where safe.
	•	Minimize Storage Access: Cache frequently used state variables in local memory within functions. For example, if the contract stores the PoolManager address or token addresses in storage, read them into a local variable at the start of the function and use the local variable for multiple operations. This avoids repeated SLOAD instructions. Also mark immutable values as immutable (or constant if truly constant) to enable compile-time or cheaper access.
	•	Batch Operations to Save Gas: Where possible, batch multiple operations into a single PoolManager interaction to leverage flash accounting. Uniswap v4 allows grouping of actions under one lock/unlock so that token transfers happen once at the end ￼. For example, if our FullRangeLiquidityManager needs to add liquidity and immediately stake or move funds, consider wrapping them in a single poolManager.lock(...) call so they execute within one callback and share one settlement. This reduces redundant calls and transfers. Ensure our lockAcquired (or unlockCallback) function is optimized and does only necessary work.
	•	Unchecked Arithmetic and Fixed Point Ops: Use unchecked { ... } for arithmetic operations that cannot overflow (Solidity 0.8’s overflow checks cost gas). For instance, when calculating liquidity amounts or fees, if we know the values are within safe ranges (e.g., based on balances), do calculations in an unchecked block. Similarly, prefer bit shifting or fixed-point libraries for multiplying/dividing by constants like 1e18 to avoid excessive division operations.
	•	Solmate ERC20/Ownable: If the contracts use OpenZeppelin’s ERC20 or Ownable for managing liquidity tokens or admin access, consider switching to Solmate’s implementations (e.g., ERC20 in Solmate or Owned for a simple owner pattern). Solmate’s contracts omit unnecessary features (like allowances events or tiered roles) and are more gas-efficient. For instance, Owned uses a single storage slot and has a simple owner and authority system, saving gas on deployment and access checks.

Security Hardening and Best Practices

Security is paramount, especially when interacting with a live AMM. We will strengthen the contracts against reentrancy, front-running, and slippage risks, and incorporate other best practices:

Reentrancy Protection

Integrate a reentrancy guard in state-changing functions to prevent malicious reentry attacks. Even though Uniswap v4’s design uses controlled reentrancy for flash operations, we must prevent unexpected reentrancy into our own contract. Use the Solmate ReentrancyGuard (or OpenZeppelin’s) to decorate functions like adding/removing liquidity, swaps, or claiming fees. This adds a simple mutex that “prevents reentrancy during certain functions.” ￼

For example, add nonReentrant to depositLiquidity and withdrawLiquidity functions. Internally, the guard uses a storage flag check that makes any nested call to a nonReentrant function revert. This ensures that even if an external call (e.g., token transfer callback or a PoolManager hook) calls back into one of these functions, it will fail rather than execute twice.

Note: When using reentrancy guards with Uniswap v4’s callbacks, carefully structure the logic. The intended pattern is to call poolManager.lock or poolManager.unlock from a nonReentrant function, which will invoke our callback (lockAcquired/unlockCallback). Inside the callback, we may want to perform actions and settle balances. Because the callback is an external call from PoolManager into our contract, the guard will prevent re-entering the guarded function improperly. Design the functions so that the external callback function itself is not guarded (allowing it to execute as needed), but it calls internal functions or performs transfers in a way that doesn’t violate the guard (e.g., use internal functions for core logic that assume the guard is already held by the original call).

Additionally, follow the checks-effects-interactions pattern: perform all necessary state updates (like recording the new liquidity position or updating an internal accounting of shares) before calling out to the PoolManager or transferring tokens. This way, if a reentrant call is attempted via an external token callback or hook, our state is already consistent and the guard will block harmful reentry.

Front-Running Resistance and Slippage Safeguards

Protect users from price manipulation and slippage when they interact through our contracts. Because transactions are public before execution, a malicious actor could try to manipulate pool state or prices right before our transaction executes (a sandwich attack or price bait scenario). To mitigate this:
	•	Slippage Checks: Introduce parameters for acceptable slippage on any price-dependent action. For swaps executed through FullRangePoolManager, require the caller to provide a minAmountOut (for sell trades) or maxAmountIn (for buy trades). After performing poolManager.swap, check that the result meets the constraint, e.g. require(actualOutput >= minAmountOut, "Slippage too high") ￼. If the condition fails (meaning the price moved against the user beyond their tolerance), revert the transaction. This guarantees the user doesn’t get an unfairly low output due to front-running. Similarly, for adding liquidity, require the user to specify the maximum token amounts they are willing to contribute. Compute the actual amounts of token0 and token1 that will be deposited (based on current pool price and liquidity delta), and ensure neither exceeds the user’s specified maximums ￼. For example, if a user is adding liquidity with at most 100 TokenA and 100 TokenB, and due to a price shift the pool now needs 105 TokenA for the same liquidity, the contract should revert rather than taking more. By forcing users to specify these bounds, we eliminate the chance for an attacker to “bait” the user into providing more tokens than intended in a last-minute price move.
	•	Deadline Enforcement: Include a uint256 deadline on user-facing functions (like Uniswap’s periphery does). Before proceeding with a swap or liquidity add, do require(block.timestamp <= deadline, "Transaction expired");. This prevents transactions from hanging in the mempool indefinitely where they could be executed at a very different price. Users will sign transactions with a reasonable deadline, and if miners/validators delay it beyond that, it will abort. This is a simple but effective front-running safeguard.
	•	Preventative Measures for Price Baiting: Uniswap v4’s flexible hooks could allow complex pool behaviors. While our FullRange managers likely use no custom hooks (just full-range constant product behavior), it’s wise to guard against time-of-check to time-of-use inconsistencies. Wherever our contract reads a value from the pool (price, liquidity, etc.) and then uses it to decide an action, try to execute in the same transaction immediately or re-check after the action. For instance, if we read the current price to calculate token proportions for full-range liquidity, the modifyLiquidity call itself will return how many tokens were actually used; prefer using that output for final logic rather than the pre-calculation alone. This way, even if the price changed just before execution, our post-check (or the revert on slippage) will catch it.
	•	Permissioned Actions and Access Control: If the FullRangePoolManager contract has administrative functions (like setting fees or withdrawing excess tokens), restrict them to an authorized address (e.g., use Owned from solmate to manage an owner). This prevents unauthorized users from manipulating parameters in a way that could facilitate front-running or siphon funds. Also consider using Pausable (OpenZeppelin or a simple custom toggle) to halt operations in emergencies (for example, if a vulnerability is discovered, owners can pause new liquidity adds or swaps).

Additional Security Hardening
	•	Validate Pool Parameters: When interacting with a real PoolManager, always use correct pool keys. Ensure the token addresses, fee tier, and tick spacing passed to PoolManager match an existing pool or a pool you intend to initialize. If the pool is uninitialized, call poolManager.initialize() with proper parameters before adding liquidity, and handle the return (initial tick). Avoid inadvertently creating pools with wrong parameters by validating inputs (e.g., reject zero addresses for tokens or unsupported fee tiers).
	•	Use NoDelegateCall (if applicable): Uniswap v4 uses a NoDelegateCall modifier on critical functions in PoolManager to prevent them from being called in the context of a delegatecall (which could bypass security checks) ￼. If our contracts are not meant to be used via delegatecall (for example, if they might be deployed as implementation logic in a proxy), consider adding a similar guard on functions like callbacks. This is a more advanced protection and may involve inheriting or replicating Uniswap’s NoDelegateCall utility to mark functions that should revert if delegate-called. This ensures the integrity of our pool interactions even in proxy setups.
	•	Event Emissions: While not explicitly asked, it’s a good practice to emit events on critical actions for transparency and monitoring. For instance, emit a LiquidityAdded(address provider, uint256 amount0, uint256 amount1) event when liquidity is added, and a LiquidityRemoved event on removal. This doesn’t directly affect security, but it aids in auditing and debugging interactions with the live PoolManager.

Updating and Expanding Foundry Tests

With the contract changes above, the Foundry test suite must be updated to validate the contracts against an actual Uniswap v4 environment. The goals are to ensure all interactions with the real PoolManager succeed and to improve coverage for edge cases and security.

Setting Up a Realistic Test Environment
	•	Deploy Uniswap V4 Core in Tests: Leverage Foundry to deploy a fresh instance of Uniswap v4’s PoolManager and related contracts (or use a known deployed address if testing on a fork). This may involve importing the Uniswap v4 core code as a dev dependency. In the setup portion of the tests, deploy the PoolManager contract, two test ERC-20 tokens (for token0 and token1), and then initialize a pool via poolManager.initialize(poolKey, sqrtPriceX96). The poolKey should specify token0, token1, a fee (e.g. 0.3% = 3000), a tick spacing (per fee tier), and the address of a hook (use address(0) or a minimal no-op hook if required by PoolManager). Make sure to handle any special cases like native ETH: Uniswap v4 represents ETH with address(0) wrapped in the Currency type, so tests might include one ERC20 and one Currency.wrap(address(0)) to simulate an ETH pair.
	•	Integrate FullRange Contracts: Deploy the updated FullRangePoolManager and FullRangeLiquidityManager within the test. Configure them with the addresses of the deployed PoolManager and the tokens. For example, set the PoolManager address in a constructor or initializer of our contract, and ensure the contract knows the pool key it should interact with (perhaps store the PoolId or pool key for the token pair it manages). If the FullRangePoolManager is designed to manage a single pool (likely for a specific token pair), pass that configuration in the test.
	•	Token Approvals and Funding: In tests, mint initial token balances to test users (or to the FullRangeLiquidityManager if it will hold tokens on users’ behalf). Approve the FullRange contract to transfer tokens from users if the contract pulls funds, or have the contract itself approve the PoolManager if it will directly supply tokens. For instance, if our contract holds user liquidity, it might need to call IERC20(token).approve(poolManager, type(uint256).max) so that the PoolManager can pull tokens during settlement (or we call poolManager.settle after transferring, as discussed). Ensure any required approval is done in the test setup before executing core functions.

Test Cases for Core Functionality
	•	Adding Full-Range Liquidity: Write tests that call the FullRangeLiquidityManager’s function to add liquidity (e.g. addLiquidity(uint256 amount0, uint256 amount1, uint256 minAmount0, uint256 minAmount1, uint256 deadline)). Assert that the function returns or emits expected results and that the PoolManager’s state is updated. You can check the Pool’s reserves or liquidity via PoolManager queries (if accessible) or by performing a swap after adding liquidity to see if it executes at the expected price. Also verify the BalanceDelta returned by modifyLiquidity: it should indicate the amounts of token0 and token1 the FullRange contract had to supply. Assert that these amounts are exactly as expected and do not exceed the maxAmount parameters given (the transaction should revert if they would).
	•	Removing Liquidity: If the contracts support removing liquidity (burning the position), test this by first adding liquidity, then calling the remove function. Ensure that the contract receives back the appropriate amounts of token0 and token1 (plus any fees earned). You might need to call poolManager.modifyLiquidity with a negative liquidity delta to remove, and then handle the returned delta (which likely will be positive balances to take). The test should assert the user’s token balances increase by roughly the amount deposited (accounting for any fees or minor differences due to tick rounding). Also test removal of full-range liquidity after some swaps have occurred to accumulate fees: the returned amounts should include fee revenue.
	•	Swap Through FullRangePoolManager: If the FullRangePoolManager contract offers a swap function (perhaps to swap using its liquidity or on behalf of a user), write tests for that. Provide input amount and slippage tolerance, execute the swap, and verify that the output amount is within expected range and the user’s balances have changed correctly. Use the real pool to execute an opposing swap directly (via PoolManager in the test) to simulate price movement and ensure our contract’s slippage check works. For example, try to swap with a very tight minAmountOut that will fail if the price moves slightly, then manipulate the pool price in the test (by swapping directly on PoolManager) just before calling our contract’s swap, and confirm it correctly reverts with a slippage error.
	•	Callback and Reentrancy Testing: Specifically test the callback validation and reentrancy guard:
	•	Attempt to call the contract’s Uniswap callback function directly from the test (as a malicious actor might). For instance, call FullRangePoolManager.unlockCallback(...) or lockAcquired(...) from an address that is not the PoolManager. The call should revert immediately with the “Only PoolManager” requirement. Use vm.expectRevert with the expected revert message to verify this protection. This validates that our require(msg.sender == poolManager) is effective ￼.
	•	Ensure that when the PoolManager legitimately calls our callback, it does not revert. This happens as part of normal operation (e.g., when we call poolManager.lock in the contract, Foundry will execute lockAcquired callback). The test should cover a full transaction where lock is called and our lockAcquired (or unlockCallback) runs. Inside that callback, ensure no reentrancy guard blocks it. Essentially, confirm that our guard is only preventing unexpected reentries, not the intended Uniswap callback itself. If necessary, adjust the placement of nonReentrant modifiers in the contract and test again until the intended Uniswap flow succeeds.
	•	You can also simulate a reentrancy attack by writing a malicious contract in the test that tries to re-enter our contract. For example, a hook or a custom ERC20 token that calls back into the FullRange contract during transfer. Given our precautions, such reentry should either have no effect or be prevented. Use vm.prank and custom contract to attempt this and assert that the state doesn’t become inconsistent (or the call is reverted).
	•	Front-Running and Slippage Scenarios: Use Foundry’s ability to manipulate state within a single test to simulate a sandwich attack. One approach:
	1.	Have user A add liquidity through our contract with certain slippage bounds.
	2.	Just before that transaction (in the same test, we can’t truly front-run, but we can simulate a sudden price change), execute a large swap on the PoolManager directly to change the price significantly.
	3.	Then call our add liquidity and expect it to revert due to slippage safeguards (if the price move made the required token amounts beyond the user’s max).
	4.	Conversely, test that if the price change is within tolerance, the add still succeeds and uses the updated price.
Similarly, for swaps, simulate that between the time a user constructs parameters and the execution, the price in pool changes. We can do this by calling poolManager.swap in the test right before calling our contract’s swap. Verify that if the change is too large, our contract’s require(amountOut >= minOut) kicks in and reverts the swap (protecting the user). This kind of test ensures our front-running resistance logic actually works under dynamic conditions.
	•	Gas Usage (Optional): While unit tests don’t measure gas by default, you can use Foundry’s gasMetering or logs to ensure that the use of Solmate libraries indeed lowers gas. For instance, one could write two versions of a dummy transfer function (one using SafeERC20 from OpenZeppelin, one using SafeTransferLib from Solmate) and compare gas in a fuzz test. However, since the question is more about correctness, this might not be necessary to assert in tests. Instead, review the bytecode or use Foundry’s forge inspect to ensure the calls map to the expected efficient routines (for example, no extra SLOADs or extcodesize checks beyond what SafeTransferLib does).
	•	Edge Cases and Error Conditions: Add tests for scenarios like:
	•	Adding zero liquidity (should revert with a clear error, since liquidityDelta cannot be 0 for add).
	•	Removing more liquidity than available (should revert or do nothing). For example, call remove twice in a row and ensure the second fails because there’s no liquidity left.
	•	Using incorrect pool parameters: if the FullRangePoolManager supports multiple pools, test that providing a wrong PoolKey or poolId is handled (our contract might restrict to one pool; if not, ensure it checks that the given poolKey matches the expected tokens).
	•	Test the use of salt in ModifyLiquidityParams: if our contract uses a fixed salt (e.g., 0) for full-range positions, adding liquidity twice should accumulate in one position. If it uses unique salts per add, then two adds create separate positions. Write tests to confirm the intended behavior. For instance, add liquidity twice and then remove in one go – if a single position was used, the full amount is removed; if not, perhaps the contract tracks multiple positions (though likely it uses one full-range position for simplicity).
	•	Testing Fee Withdrawal (if applicable): If FullRangePoolManager is responsible for collecting fees from the Uniswap pool, simulate fee accumulation by performing swaps that cross the spread. Then call whatever function in our contract is meant to collect fees (this could be a zero-liquidity modifyLiquidity call or a dedicated function). Verify that the fee amounts are correctly transferred to the appropriate party (either added to liquidity or sent to an owner or distributed to liquidity providers). This ensures our contract correctly interacts with modifyLiquidity when liquidityDelta = 0 (which should trigger a fees-only collection per Uniswap v4 design ￼).

Ensuring Test Success and Coverage

After implementing the above changes, run the entire test suite to ensure all tests pass with the real PoolManager integration. Increase the coverage by adding the new tests discussed so that we cover both success paths and failure paths (reverts for unauthorized access, slippage, etc.). Key success conditions to assert in tests:
	•	The contracts properly add and remove liquidity from an actual Uniswap v4 pool (verify by checking pool state or balances).
	•	Security measures work: unauthorized calls are reverted, and allowed calls succeed as expected.
	•	Gas usage is within reasonable bounds (no unforeseen gas spikes, which you can gauge by looking at trace logs or gas reports from Forge).
	•	The test suite should also print or log relevant events (you can use emit in contracts and then use Foundry’s expectEmit to ensure they fire correctly, if you added events).

By updating the contracts with correct Uniswap v4 interactions and reinforcing them with these gas and security best practices, and by rigorously testing with a real PoolManager contract, we ensure the FullRangePoolManager and FullRangeLiquidityManager are robust, efficient, and secure in a Uniswap v4 environment. All these changes collectively align our implementation with industry best practices — from callback verification and reentrancy guards to slippage control — making the system safer against known attack vectors and mismatches ￼ ￼. The Foundry tests, once updated, will give confidence that the integration is correct and that the contracts behave as expected in all scenarios.