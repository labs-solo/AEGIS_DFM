# 8 Security & Invariants

## 8.1 Threat Model & Assumptions

The **threat model** assumes a maximally adversarial on-chain environment: any user (or **EOA**/smart contract) may attempt to manipulate state, call functions out of order, or exploit economic edge cases for profit. Key **actors** include liquidity providers (LPs) who can add/remove liquidity freely, borrowers who may try to over-leverage, and keeper bots (liquidators, fee reinvest triggers) seeking rewards. Governance is constrained by a timelocked multi-sig, so **no instant malicious upgrades** are possible – any critical parameter or code change requires a delay, giving the community time to react (this is an assumed invariant enforced off-chain via the timelock contract).

### Scope
- `simulateBatchTyped` is read-only; invariant checks run but **no storage mutates**. (See INV‑2.3 Pending Fees Cleared.)

**Trust boundaries** are minimized: all price and liquidity data come from on-chain Uniswap V4 pools (no external oracles), so price manipulation requires providing large amounts of liquidity or volume on-chain, which the dynamic fee mechanism makes expensive. The VaultManagerCore contract is the single entry point for state changes; only authorized modules can call its sensitive functions. For example, the Uniswap **Spot Hook** is the *only* contract permitted to initiate user deposits/withdrawals in the vault (enforced by an access control check). This means users cannot bypass the intended pathways (e.g. calling vault functions directly) – they must go through the validated interface (Spot or BatchEngine). **Keepers** operate via public functions (`liquidate()`, `accrueInterest()`, `reinvestFees()`) that anyone can call, but these actions either succeed safely or do nothing if not needed; they cannot violate invariants even if called at arbitrary times. All state-mutating functions employ **reentrancy guards** and check global pause flags upfront, preventing complex attacks like reentrancy loops or cross-function call exploits. Additionally, all loops are bounded by per-user or per-pool data sets, with no unbounded iteration over all users (thus no risk of block gas exhaustion). We assume honest but rational behavior for governance and the Pause Guardian – e.g. that emergency pauses will be used to mitigate true threats (like oracle malfunctions) and not for malicious censorship. Under these assumptions, the system's design ensures that **no single actor** (outside of timelocked governance) can steal funds or compromise solvency without economic cost or being subject to automatic countermeasures.

**Circuit Breakers & Safety Switches:** The protocol incorporates multiple "circuit breakers" to halt or dampen activity under abnormal conditions. Governance or the designated Pause Guardian can set global and per-pool **pause flags** to instantly halt operations (e.g. `PAUSE_ALL` stops *all* vault actions system-wide). There are also finer-grained flags (see Appendix C) for specific functions: e.g. pausing only borrows, or only a particular pool's liquidity ops. These ensure that if a vulnerability or oracle failure is detected, the protocol can be frozen into a safe state for investigation. Additionally, **sanity caps** are enforced on critical parameters: for instance, each pool has a maximum utilization (debt-to-deposits) cap (default 95%) so that borrowing cannot completely exhaust available liquidity. If a withdrawal or borrow would push utilization above this threshold, the action is reverted with a `UtilizationTooHigh` error. This guarantees a buffer of liquidity remains and acts as a circuit breaker against bank-run scenarios. Similarly, the liquidation logic implements a **price deviation guard**: if the Uniswap-based price oracle is deemed stale or off by a wide margin (beyond preset tolerances), liquidations can be temporarily paused (`PAUSE_LIQUIDATIONS`) to avoid executing based on bad data. These measures, combined with conservative risk parameters, mean the system will **fail safe** (revert or pause) rather than enter an unsafe state under extreme conditions.

## 8.2 Invariant Catalogue by Subsystem

Throughout development, a series of **invariants** has been established to formalize the above safety properties. These invariants are assertions that must *always* hold true in the system state. Many are enforced explicitly by contract code (via require/assert checks), while others are guaranteed by design and architecture. The full invariant catalog is grouped below by subsystem for clarity, with each invariant labeled `INV-#.#` (or similar) corresponding to its time of introduction. For each invariant we note its enforcement mechanism (with references to Appendix C runtime checks) and rationale. All invariants have been rigorously tested via a combination of unit tests, fuzzing, and symbolic analysis to ensure no adversarial sequence of actions can break them (see §8.4).

**Liquidity & Share Accounting Invariants:** These ensure the integrity of LP share accounting and prevent share manipulation.

* **INV-2.1: Total Shares ≥ Locked Shares** – The total liquidity shares in any pool (`totalShares`) can never fall below the **locked** minimum share amount. A small portion of shares is permanently locked upon the first deposit to each pool (to prevent division-by-zero and price manipulation). This invariant guarantees that even if all users withdraw, `totalShares` stays at the non-zero locked value. It is enforced by disallowing any withdrawal that would dip totalShares below the `lockedShares` constant – in practice, the vault never assigns locked shares to users, so they cannot be withdrawn. (See `VaultManagerCore.registerPool` on first deposit, which mints the minimum locked shares and thereby preserves this invariant.)
* **INV-2.2: Locked Shares Never Decrease** – Once set for a pool, the `lockedShares` amount is immutable and never lowered. This prevents anyone (even governance) from reducing the minimum liquidity requirement. There is no function to reduce `lockedShares`, and by design no operation affects this field after initialization, so the invariant holds trivially. Together, INV-2.1 and INV-2.2 ensure a pool's share price can't be artificially inflated by withdrawing all liquidity – a tiny fraction always remains, anchoring the pool's value. (In Uniswap V4 terms, this mirrors the classic minimum liquidity constant.)

**Fee & Reinvestment Invariants:** These invariants cover the accumulation and handling of swap fees in the vault.

* **INV-2.3: Pending Fees Cleared on Reinvest** – Swap fees accrue in a `pendingFees` buffer for each pool. Whenever fees are reinvested into the pool's liquidity, the pending fee counts are **reset to zero** for that pool. This invariant ensures no "double counting" of fees: once fees have been turned into new shares, the pending accounting is wiped. Enforcement is in `VaultManagerCore.reinvestFees` which, after adding the fees to the pool, zeroes out or subtracts the reinvested amounts from `pendingFees`.
* **INV-2.4: Fee Monotonicity** – Pending fee counters only ever **increase** between reinvest events. In other words, as trades happen, the recorded fees for a pool go up, and never down, until reinvestment (at which point they reset per INV-2.3). There is no code path that subtracts from `pendingFees` except reinvest (which is a deliberate reset rather than a random decrement). The Spot hook's fee notification simply adds to the counters. This invariant prevents any possibility of fees "vanishing" or being drained except by the intended reinvest conversion to shares.
* **INV-2.5: Non-Decreasing Share Price** – see [Lemma 5.2-A](05_Functional_Specs.md#lemma-5-2-a) for proof the per-share value never falls.
**Access Control & Pause Invariants:** These protect the system from unauthorized access and allow emergency halts.

* **INV-2.6: Authorized Hook Only** – Only the designated **Spot Hook** contract (and the BatchEngine router, which is granted a similar role) can call certain sensitive functions in `VaultManagerCore`, such as `deposit()` and `withdraw()`. If any other address calls these, the vault reverts with an *Unauthorized* error. This invariant ensures users cannot bypass safety checks by calling the vault directly – they must go through the controlled flow (which includes oracle price checks, slippage limits, etc.). Enforcement is via an internal modifier or role check on vault functions: the vault verifies `msg.sender == authorizedHookAddress` (or has the `POOL_HOOK_ROLE`), so any call from an unapproved contract or EOA is rejected. This was tested by trying direct calls from a random address and confirming they revert.
* **INV-2.7: Emergency Pause Enforcement** – If a pool is marked in an **emergency state** or a global pause is active, user operations are blocked. In practice, the system has a `pauseFlags` bitmap (see Appendix C) and per-pool `emergencyState`. When a pause flag is set (e.g. `PAUSE_DEPOSITS`) or a pool is frozen, the corresponding functions will `revert` with a `Paused` or `PoolEmergency` error. For example, if `emergencyState[poolId]=true`, the Spot module will reject any deposit/withdraw for that pool. This invariant guarantees that during emergencies, no new risky actions (like adding or removing liquidity, or initiating borrows) can be taken, which buys time for intervention. It was validated in tests by toggling emergency mode and observing that all protected calls fail. (Governance can still allow certain "safe" calls like repayments or withdrawals of **excess** collateral during pauses – those do not compromise safety.)

**Interest Accrual Invariants:** These ensure the lending interest calculations are time-consistent and non-manipulable.

* **INV-3.1: Monotonic Borrow Index** – The cumulative interest index for each pool's borrow balance (denoted `shareIndex`) is **non-decreasing**. Each time interest is accrued, this index either stays the same (if no time has passed or rate is zero) or increases to reflect additional interest. It never goes down, meaning the protocol will not forgive interest or lose track of accrued interest. This is enforced in `accrueInterest(poolId)`: the code calculates a factor ≥1 (based on time elapsed and rate) and multiplies the index by this factor. If called multiple times in the same block or with no time delta, it simply returns early without reducing anything. Thus `borrowIndex` only moves upward. A Foundry fuzz test was run advancing time by random intervals and confirming `indexAfter >= indexBefore` always.
* **INV-3.2: Time-Ordered Accrual** – The timestamp of last interest accrual (`lastAccrueTime`) for each pool always updates to the current block time and never leaps backward or beyond the current time. This ensures the system cannot "time-travel" with interest (e.g. crediting interest in the future or re-accruing past interest twice). The `accrueInterest` function enforces: if called with `currentTime <= lastAccrueTime`, it does nothing, and otherwise sets `lastAccrueTime = block.timestamp` at the end. The invariant holds by construction that after each accrual, `lastAccrueTime` equals the block time of execution (which is monotonic in Ethereum).

**Solvency & Collateral Invariants:** These are critical safety checks ensuring loans remain backed by sufficient collateral.

* **INV-3.3: Global Solvency** *(alias INV-BOR-01)* – **Total outstanding debt shares ≤ total liquidity shares** in each pool at all times. This invariant means the vault cannot lend out more shares than exist in the pool – effectively a conservation of assets. Every time someone borrows shares, those shares are immediately *removed* from the pool's available total (by burning or transferring them as debt) so the sum of debt shares never exceeds the supply of shares. The code maintains this by incrementing `totalBorrowShares` when shares are borrowed and decrementing `shareData.totalShares` when liquidity is removed to fund the borrow, keeping the inequality intact. Similarly, on repay or liquidation, debt shares are canceled before any new shares could be added. In practice, even under extreme scenarios (all LPs withdraw leaving only lockedShares while some debt remains), an invariant check prevents the last withdrawal if it would violate `totalBorrowShares <= totalShares`. This was verified with invariants tests fuzzing random sequences: the check `vault.getTotalBorrowShares(pool) <= vault.shareData(pool).totalShares` never failed.
* **INV-3.4: Per-User Solvency** *(alias INV-COL-02)* – Every user's **borrow position stays fully collateralized**: for each user, at all times `borrowValue <= collateralValue * (maintenance factor)`. In other words, no user can have a loan that exceeds their posted collateral's value (adjusted by a safety margin). The maintenance collateral factor (e.g. 80%) dictates the minimum ratio. This invariant is enforced on each state-changing operation that could affect solvency. For example, on a borrow, the vault requires the post-borrow `<borrowValue> <= <collateralValue> * maintFactor` (or stricter init factor if it's a new borrow) or else reverts. On withdrawals, the BatchEngine performs a similar check – if a user tries to withdraw collateral that would make their remaining collateral insufficient for their current debt, the withdrawal is blocked (reverted with `ExceedsMaintCF`). These checks leverage the `_getCollateralValue` and `_getBorrowValue` helpers to compute up-to-date values and compare against policy thresholds. As a result, any action that would create an under-collateralized position is preemptively stopped. The test suite includes random action sequences and confirms that no account ever ends up with `debt > collateral * maintFactor` unless they are immediately liquidatable.

**Collateral Factor & Risk Parameter Invariants:**

* **INV-3.5: Collateral Factor Bounds** – The risk parameters for collateralization are well-ordered: the **initial collateral factor** for any asset ≤ the **maintenance factor**, and neither exceeds 100%. (For example, you might need 50% collateral for a new loan but only 80% to avoid liquidation on an existing loan; and neither can be >100% which would imply infinite leverage or no margin.) This invariant is enforced at the governance level: when updating collateral factors for a pool/asset type, the `PoolPolicyManager.setCollateralFactors` function requires `initBps <= maintBps <= 10000` (bps = basis points). Any attempt to set an invalid combination is rejected (errors `InitBpsTooHigh` or `BpsRange`). Thus the system will never operate with an illogical or unsafe collateral factor configuration.

**State-Change Consistency Invariants:** These ensure that core state variables change in expected, balanced ways with no bookkeeping errors.

* **INV-3.6: Borrow Increases Debt** – When a user borrows, their debt (measured in share units) increases exactly by the amount borrowed. There are no hidden fees or missing shares – the user's `borrowShares` and the pool's `totalBorrowShares` go up by the same `shares` amount that was taken out as a loan. This invariant is inherent in the implementation of `VaultManagerCore.borrowShares()` – after passing collateral checks, it simply increments the counters and transfers out the underlying assets. A corresponding invariant test calls `borrowShares()` and asserts that the difference in debt equals the input shares.
* **INV-3.7: Repay Reduces Debt** – Conversely, when a user repays, their debt shares decrease by exactly the amount repaid. On `repayShares(poolId, N, ...)`, the vault collects the underlying tokens for the `N` shares and then subtracts `N` from both the user's `borrowShares` and `totalBorrowShares`. No debt phantom remains and no over-repayment is allowed (the function checks you cannot repay more shares than you owe). A unit test covers this by tracking a user's debt before and after a partial repay and confirming the difference is exactly the repaid amount. These two invariants (3.6 & 3.7) guarantee a coherent accounting: every share borrowed or repaid is reflected one-for-one in the system's state, preventing the accrual of ghost debt or the occurrence of unexpected debt forgiveness.

**Limit Order Invariant:**

* **INV-LIM-01: Single-Tick Limit Orders** – Any "limit order" position in the system is **encoded as a one-tick-wide LP position**. In practice, a limit order in AEGIS V2 is implemented by depositing liquidity confined to a single price tick (using the Uniswap V4 positions mechanism). The invariant ensures that what is accounted as a limit order is never multi-tick liquidity (which would behave like a normal LP position). This is more of a design rule than a runtime check: the `openLimitOrder()` function (part of later feature set) only ever mints liquidity with `tickLower == tickUpper`, and the vault treats such positions separately from full-range collateral. The invariant is upheld by construction of the order-handling logic and was reviewed in an earlier specification draft. It prevents any ambiguity between active LP liquidity and passive limit order funds – thus avoiding double counting of collateral or fee mis-accounting. (Limit order funds are excluded from free collateral until the order is executed or canceled, as noted in extended invariants.)

## 8.3 Enforcement Point Mapping

The table below maps each invariant to its primary **enforcement point** in the code (specific contract function or check). For detailed code references, see the annotated diffs in **Appendix C**. Inline anchors (【C】) in the table link to the relevant code snippet in Appendix C for convenience.

| **Invariant** (Tag)                   | **Enforcement Point** (Contract.Function)                                                                                                                                                                                       |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **INV-2.1**  Total Shares ≥ Locked    | `VaultManagerCore.withdraw` – Checks that resulting `totalShares` ≥ `lockedShares` (ensured by never assigning locked shares to users)                                                                                          |
| **INV-2.2**  Locked Shares Immutable  | `VaultManagerCore.registerPool` – Sets `lockedShares` on first deposit; no function to decrease it (one-time assignment)                                                                                                        |
| **INV-2.3**  Pending Fees Cleared     | `VaultManagerCore.reinvestFees` – After adding fees to liquidity, sets `pendingFees[pool] = 0`                                                                                                                                  |
| **INV-2.4**  Fees Monotonic           | `SpotHook.afterSwap` – Increments `pendingFees[pool]` counters only (no decrements)                                                                                                                                             |
| **INV-2.5**  Share Price Non-Decrease | *Implicitly enforced by design:* `VaultManagerCore.reinvestFees` mints shares proportionally, and `VaultManagerCore.withdraw` burns shares proportional to assets withdrawn (preserving or increasing share price)              |
| **INV-2.6**  Hook-Only Access         | `VaultManagerCore.deposit/withdraw` – `require(msg.sender == authorizedHook)` (or has `POOL_HOOK_ROLE`)                                                                                                                         |
| **INV-2.7**  Pause / Emergency        | `VaultManagerCore` – `whenNotPaused(...)` modifiers on all mutative functions; `Spot` – checks `emergencyState` before forwarding calls                                                                                         |
| **INV-3.1**  Borrow Index Monotonic   | `VaultManagerCore.accrueInterest` – multiplies `shareIndex` by ≥1 factor; never a decreasing operation                                                                                                                          |
| **INV-3.2**  Accrual Time Order       | `VaultManagerCore.accrueInterest` – ignores calls where `block.timestamp <= lastAccrueTime` (no backward jump) and then updates `lastAccrueTime = block.timestamp`                                                              |
| **INV-3.3**  Global Solvency          | **VaultManagerCore** – Borrows: `totalBorrowShares` increased while equal amount of shares removed from pool (via internal `_withdrawUnderlying`); Withdrawals: require leaving ≥ lockedShares and solvency check (see INV-3.4) |
| **INV-3.4**  User Solvency            | `VaultManagerCore.borrowShares` – requires new `borrowValue` ≤ `collateralValue * factor` (init or maint); `VaultManagerCore.withdraw` – similar check via `_checkSolvency` (reverts `ExceedsMaintCF`)                          |
| **INV-3.5**  Collateral Factor Bounds | `PoolPolicyManager.setCollateralFactors` – requires `initBps <= maintBps <= 10000`                                                                                                                                              |
| **INV-3.6**  Borrow Increases Debt    | `VaultManagerCore.borrowShares` – increments user's `borrowShares` and `totalBorrowShares` by exactly the borrowed amount                                                                                                       |
| **INV-3.7**  Repay Reduces Debt       | `VaultManagerCore.repayShares` – decrements user's `borrowShares` and `totalBorrowShares` by exactly the repaid amount                                                                                                          |
| **INV-LIM-01**  Single-Tick Order     | `VaultManagerCore.openLPPosition` (part of later feature set) – enforced via parameters: for limit orders, sets `tickLower == tickUpper` (no multi-tick range allowed)                                                                            |

## 8.4 Verification & Testing

All the above invariants have corresponding tests in the Foundry test suite, including both **direct checks and continuous invariant monitoring**. During development, an `InvariantTest` contract was used to randomly simulate complex sequences of actions and assert that key conditions hold after each operation. For example, fuzz tests advanced time by random intervals to ensure the interest index never decreased, and random borrow/repay sequences were tried to confirm no user could bypass collateral limits. We also conducted an **Echidna fuzzing campaign** on critical functions: Echidna was configured to call deposit, withdraw, borrow, repay, etc. in arbitrary order with random inputs, and to flag any sequence that violated the invariants (none did). Moreover, for mathematical invariants like interest accrual, we performed informal **formal analysis**: e.g. proving that the interest index update formula is always ≥1 (given non-negative rates and time). The invariant "assertion" functions (as listed in earlier spec documents) were run extensively on random scenarios, providing a high degree of confidence in safety. The system was tested against adversarial conditions such as extreme price swings, partial liquidations, and block re-ordering to ensure that invariants hold in all cases or the protocol gracefully reverts. In summary, both **static checks and dynamic testing** indicate that the specified invariants are robust. Any violation of these invariants in production would imply a critical bug, hence the protocol's extensive test coverage and the availability of emergency pause switches as a last resort.

## 8.5 Changes from Earlier Drafts & Legacy Notes

The above invariant catalogue consolidates and updates the original invariant set, with all **INV-2.x invariants** remaining **active** in the current system. None of those original invariants were removed or made obsolete in subsequent iterations – every original safety property still holds, though a few have been broadened. For instance, INV-2.6 (hook authorization) now also covers the BatchEngine's role (the BatchEngine is granted permission to invoke vault actions as needed, under the same checks), and INV-2.7 (pause flags) was expanded into a comprehensive pause matrix in a later iteration. These evolutions strengthen the original invariants but do not invalidate them.

*Change-log:* A notable adjustment is that the **"Emergency and Governance" invariants from earlier drafts** (previously labeled INV-9.x in the old specification) have been **folded into the above framework**. For example, the old *INV-9.1 (Paused State Halts Risky Actions)* is now covered by INV-2.7 and the pause flag system; *INV-9.2 (Timelock Delay on Critical Changes)* remains a **governance assumption** – the timelock mechanism is external to the contracts but is an integral part of our security model (we document it here as an assumption rather than a contract invariant). *INV-9.3 (Module Upgrade Safety)* is ensured through interface checks and the immutable core architecture (upgrades cannot arbitrarily change storage or logic without passing compatibility checks), and *INV-9.4 (No Unbounded Loops)* was an architectural principle now evidenced by code (all loops are bounded as discussed). In short, all legacy invariants either persist in the current design or have been superseded by equivalent or stricter guarantees.

*Deprecation Note:* The security analysis and invariant descriptions in the previous draft specification ("**specification.md**" Section 9) are now **archived**. Section 8 of this Unified Specification supersedes the older security section, providing an up-to-date and canonical source for all invariants and their enforcement. Any invariant numbering from older documents (e.g. INV-9.x) should be considered deprecated in favor of the INV-2.x / 3.x scheme used here. Future audits and reviews should refer to this Section 8 and Appendix G for the definitive list of security invariants in AEGIS V2.
