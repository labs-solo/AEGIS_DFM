# 4. Data Model & Storage

**VaultManagerCore's storage layout is now final and frozen through slot 24.** All state variables up to slot 24 remain fixed in position and type – no existing slot has been repacked or repurposed across upgrades. This ensures that data from earlier iterations retains the same storage slot (e.g. the `userVaults` mapping stays at slot 7). Any new variables **must be added at slot 25 or higher** to obey Solidity's append-only invariant. Slots 0–24 are therefore canonical and audit-locked. A planned *limit-order nonce* field was not added, leaving slots 19–22 unused and reserved.

## 4.1 Design & Packing Rationale

* **Upgrade-Safe Ordering:** The layout was pre-planned to accommodate future features without shifting existing slots. New versions only **append** slots or activate pre-reserved fields, preventing any storage collisions.
* **Hot Fields in Low Slots:** Frequently accessed fields are kept in low-numbered slots for gas efficiency. For example, the governance `owner` address (160 bits) and global `pauseFlags` (96 bits) share slot 0, so a single warm SLOAD fetches both the owner and pause status. This warm-access pattern (EIP-2929) cuts gas for repetitive reads.
* **Packed Scalars:** Small flags and counters are tightly packed into 256-bit words wherever possible. The owner & flags in slot 0 is one example; similarly, two 128-bit counters (`nextVaultId` and `globalNonce`) were packed together in an earlier design (slots now reallocated). Packed storage minimizes unused space and reduces SLOAD count.
* **Isolated Hash Slots:** Large dynamic structures (mappings/arrays) each consume a full slot as a hash root. All per-pool or per-user mappings are placed at distinct slot indices (mostly 6–10 and 12–18) to avoid any unintended overlap. Grouping these mappings in contiguous slots also improves Keccak-256 caching for key lookups.
* **Single-Word Structs:** New composite structures introduced in later phases were designed to fit in a single 32-byte slot when possible. For instance, the `TimelockConfig` (governance parameters) and `MetricsAccumulator` (aggregated metrics) are each exactly 256 bits and occupy one slot each, keeping any `SSTORE` or `SLOAD` for them efficient. This in-place approach avoids an extra hashing indirection that a larger struct or mapping would require.
* **Gas Optimization:** The final layout meets gas targets for all core operations. For example, a warm borrow consumes roughly 125 k gas, thanks in part to the packed and cache-friendly storage design (e.g. reusing slot 0 in multiple checks).

### 4.2 Reserved Gaps & Upgrade Rules

To maintain upgrade flexibility, the layout includes both *soft* and *hard* reserved slots:

* **Soft Gaps:** Slots 5 and 15 are reserved but considered *reusable* in a future major version, subject to careful audit. These were placeholders that ended up unused in the current deployment.
* **Hard Gaps:** Slots 19–22 are a contiguous block reserved for anticipated features like order-book state or time-weighted average price buffers. These four slots are marked *hard-reserved*, meaning **they should never be reused** in-place in any upgrade. Using them for new variables would risk confusion with any deployments that expected them to remain empty. Only a full storage migration (e.g. deploying a new contract and transferring state) would allow repurposing slots 19–22.
* **Append-Only Rule:** All future additions **must start at slot 25 or above**. Under no circumstances should a new variable be inserted into slots 0–24 or into the middle of any existing struct. Moreover, any new multi-field word should pack its fields from the least-significant bits upward (right-to-left) without altering the higher-order bits of that slot.
* **Verification:** A storage layout diff tool (CI "slot-collision" check) is run before each deployment or merge to ensure compatibility. Any deviation from the expected layout (e.g. a moved or resized variable) is treated as a critical error. This enforces that upgrades cannot accidentally overwrite existing data. Manual review of the Solidity `--storage-layout` compiler output for VaultManagerCore is also part of the audit process to guarantee alignment with this specification.
