> v1.2.1-rc3 – T4 T8 T9 Alignment

# 5. Functional Specification

This section details the functional behavior of the AEGIS V2 Unified Vault across all core features. It covers user and protocol operations introduced from Phase 1 through Phase 7 (including the final batch-processing extension), integrating liquidity management, fee handling, lending, advanced position types, liquidation, and atomic batching. For each topic (§5.1–§5.7), the relevant state variables (see **§4 Storage Layout**) and module interactions (see **§3 Architecture**) are cross-referenced to provide a complete understanding.

## 5.1 Liquidity Flows

**Full-Range Deposit & Withdrawal:** Users provide liquidity to Uniswap v4 pools via the vault’s **full-range position**. The VaultManager holds a single Uniswap **ERC-6909 share token** representing the entire liquidity position for each pool, and users own fractions of it tracked internally. When a user **deposits** assets, the Spot hook (the authorized Uniswap v4 hook module, stored in `authorizedHookAddress` at slot 1) calls `VaultManager.deposit(...)` on their behalf. Key steps in a deposit:

1. **Pool Registration:** If it’s the first time liquidity is added to a given pool, the vault **registers the pool** (via `registerPool`) to initialize its state. This assigns a **primary position NFT** (ID stored in `positionIds` at slot 10) and prepares accounting (e.g. sets `shareData[poolId].totalShares`).
2. **Transfer & Mint:** The VaultManager checks deposits aren’t globally paused (`PAUSE_DEPOSITS` flag) and pulls the specified `amount0`/`amount1` from the user (the Spot hook already has the tokens approved). It then calls the Uniswap **PoolManager** (address stored in slot 3) to add these tokens to the full-range liquidity position. Uniswap in turn **mints ERC-6909 LP share tokens** to the VaultManager, increasing the pool’s `totalShares`. The VaultManager credits the user’s share balance (`userVaults[poolId][user].shareBalance`) with the number of shares minted. Slippage protections are enforced: if the actual liquidity minted would result in fewer shares than expected (`minShares` or proportional to `amount0Min/amount1Min`), the deposit reverts with a `SlippageExceeded` error.
3. **Accounting:** The user’s `UserVault` (stored in the nested `userVaults` mapping at slot 7) is updated: `shareBalance` increases, and their `token0Claims`/`token1Claims` remain unchanged (since assets went into the pool). The `shareData.totalShares` for the pool increases by the same amount, preserving `totalShares >= sum(user shareBalances)`.
4. **Events:** A `Deposit` event is emitted with the deposited amounts and shares minted. If it was the first deposit, a `PoolRegistered` event is emitted from `registerPool`.

On **withdrawal**, a symmetric process occurs via `VaultManager.withdraw(poolId, shares, ...)`. The user specifies how many **shares** to withdraw (must be ≤ their `shareBalance` or it fails with `InsufficientShares`). The VaultManager burns those shares (reducing `userVaults[poolId][user].shareBalance` and the pool’s `totalShares`) and withdraws the corresponding token amounts from the Uniswap pool via the PoolManager. The withdrawn amounts are transferred to the specified recipient (`to` address). Slippage checks ensure the amounts received are at least `amount0Min/amount1Min` or the transaction reverts. After updating balances, a `Withdraw` event logs the outcome. The user’s share balance and the pool’s total shares are reduced accordingly.

**Internal Mechanics:** In V2, the VaultManager directly interfaces with Uniswap’s `IPoolManager` for minting/burning liquidity, eliminating the Phase 2 **FullRangeLiquidityManager** intermediary. (Phase 6 integrated this logic into VaultManagerCore, using `poolManager` at slot 3 to manage liquidity). The design takes advantage of Uniswap v4’s in-place liquidity management: by holding a single full-range position per pool, deposit/withdraw operations simply increase or decrease that position’s liquidity. This avoids frequent NFT minting and allows **fee auto-compounding** (fees stay in the position as ERC-6909 claims). The ERC-6909 share token semantics ensure deposits and withdrawals incur minimal gas overhead and no unnecessary token transfers.

**Direct Vault Token Balance:** Users may also deposit assets **directly into the vault** without adding to liquidity, via `depositToVault(poolId, amount0, amount1)`. This transfers tokens into the vault and credits the user’s `token0Claims`/`token1Claims` balances (part of `UserVault` struct). These balances (stored in the same UserVault mapping) represent idle tokens that can serve as extra collateral or await conversion (e.g. from limit order execution). They can be withdrawn at any time using `withdrawFromVault(poolId, amount0, amount1, to)`, which sends the specified amounts to the user and debits their claims balances. Direct vault deposits/withdrawals are subject to pause flags and balance checks (`InsufficientLiquidity` if the user doesn’t have the tokens). This mechanism is used internally (e.g. to hold proceeds from limit orders or closed positions) and by users who want to pre-position assets as collateral.

> **Storage & Modules:** Full-range liquidity shares are tracked in `shareData[poolId]` (slot 6) and each user’s `UserVault` (slot 7). Pending fees from trading accrue in `pendingFees[poolId]` (slot 8) – see §5.2. All pool liquidity operations go through the Uniswap V4 **PoolManager** (slot 3) and **PositionManager** (slot 4); the Spot hook module (slot 1) is the only contract authorized to initiate user deposits/withdrawals. This ensures vault entry points are called only in the correct context (Uniswap hook or governance). Reentrancy is prevented by modifiers (`nonReentrant`) on state-changing functions, and global and per-pool pause flags (bitmask in `pauseFlags` at slot 0) guard each operation (e.g. `notPaused(PAUSE_DEPOSITS)` on deposits). The invariant that **total shares ≥ total borrowed shares** is always maintained, so withdrawals will be disallowed (reverted) if they would violate solvency (checked via `UserVault` balances and collateral factors – see §5.3 and §5.6).

## 5.2 Fee Reinvestment

As trades occur in a pool, the vault’s full-range position earns swap fees. Thanks to Uniswap v4’s design, these fees accumulate as ERC-6909 claimable tokens in the vault’s position (tracked off-chain by Uniswap, and reflected in the vault’s `pendingFees` mapping until reinvested). The **fee reinvestment** mechanism (introduced in Phase 2) periodically converts those accrued fees into additional liquidity, compounding returns for liquidity providers.

**Accumulation:** Each pool’s `pendingFees[poolId]` (struct of token0 and token1 amounts, at storage slot 8) keeps track of un-reinvested fees. Whenever a swap happens, the Spot hook intercepts a portion of the swap fee and retains it in the vault (instead of immediately transferring to LPs). It updates `pendingFees` for the pool accordingly. No ERC-20 transfers occur at swap time – fees are just accounted, which saves gas and defers token movement (per ERC-6909 design).

**Triggering Reinvestment:** Anyone can call `VaultManager.reinvestFees(poolId)` to reinvest the accumulated fees into the pool’s liquidity. In practice, the Spot hook will call this automatically at the end of a swap if the fee amount exceeds a configured threshold (to bundle the reinvest with the swap transaction). Reinvestment is subject to a **cooldown**: the vault enforces a minimum interval between reinvestments per pool (`lastReinvestment[poolId]` at slot 12 stores the timestamp of the last action). If called too soon, it reverts with `ReinvestmentCooldown`. Also, a global flag `reinvestmentPaused` (slot 11) can disable reinvestments entirely in emergencies.

**Execution:** When `reinvestFees` is invoked, the VaultManager checks that there are indeed fees to reinvest (if below a dust threshold or zero, it fails with `InsufficientFeesAccumulated`). It then reads the pending fee amounts for token0 and token1, resets `pendingFees` to zero, and calls the Uniswap PoolManager to **mint liquidity** equal to those amounts into the full-range position. Essentially, the vault is adding those fee earnings back into the pool as if it were a fresh deposit. This yields new LP shares (`sharesMinted`) representing the added liquidity.

**Fee Distribution:** The newly minted shares from reinvestment are **split between the liquidity providers and the protocol** according to the configured fee split policy. By default, a small fraction of fees (e.g. 10%) is allocated as **Protocol-Owned Liquidity (POL)**, and the rest effectively boosts LP positions. In implementation, this is achieved by crediting a fraction of the newly minted shares to the protocol’s own balance and leaving the remainder to increase the value of all existing shares (since total shares increases while user share counts remain the same). Specifically, the vault’s `totalPolShares[poolId]` (slot 21) is increased by the protocol’s share of the minted liquidity, and the protocol’s portion is recorded internally (the vault itself holds those shares on behalf of the “insurance fund”). The rest of the shares effectively belong to users collectively – rather than being assigned individually, they dilute the pool such that each user’s share represents a slightly smaller fraction of the pool, but since the pool’s total liquidity grew by the fees, the **absolute value of each user’s stake increases**. In other words, users see their share of the pool worth more tokens, and the protocol takes a cut as POL. For example, if 1000 new shares are minted and policy dictates 10% to POL, then `totalPolShares` increases by 100 and the remaining \~900 shares worth of liquidity benefit the LPs (their share balances stay constant, but totalShares increases, so each share now corresponds to more underlying assets).

After adding liquidity, an event `FeesReinvested(poolId, amount0, amount1, sharesMinted)` is emitted. Off-chain, one can infer how many of those `sharesMinted` went to POL by checking the fee split configuration (set in the PoolPolicyManager, see **§3**). The vault updates `lastReinvestment[poolId]` to the current timestamp to enforce the cooldown going forward.

**Benefits:** This automated fee compounding mechanism ensures that liquidity providers’ earnings are continually redeployed for growth. It operates within Uniswap’s hook gas constraints — typically, the Spot hook triggers reinvestment at swap end when incremental, to avoid heavy logic during the swap. If too much gas might be consumed, reinvestment can also be called separately by keepers. The vault’s design ensures that reinvestment maintains all invariants: it never withdraws user funds, only adds; it respects pause flags; and it cannot run if the pool is in an emergency state.

> **Storage & Policy:** Fee accumulation lives in `pendingFees` (slot 8) per pool. Reinvestment logic checks `reinvestmentPaused` (bool at slot 11) and uses `lastReinvestment` (slot 12) for timing. The share split ratios (what % goes to POL vs to LPs) are configured in the **PoolPolicyManager** (see `polSharePpm`, `lpSharePpm` in PolicyManager, default 10% POL). When POL shares are minted, `totalPolShares` (slot 21) is incremented; this reflects cumulative protocol liquidity added. (There is a corresponding `insurancePolShares` at slot 22 for tracking the subset of POL from liquidations – see §5.6.) A key invariant is that **`insurancePolShares <= totalPolShares`** always. Reinvestments only affect `totalPolShares` (fee-derived POL) and leave `insurancePolShares` unchanged. The vault’s events and the `VaultMetrics` periodic event include these figures to allow external monitoring of how much POL the protocol has accumulated.

## 5.3 Lending & Interest Model

Phase 3 expanded the vault into a lending protocol by allowing users to **borrow against their liquidity**. The vault implements a share-based borrowing model: users can take an advance on the underlying tokens by burning some of their LP shares (or other collateral) as debt, and later repay to regain their shares. Interest accrues on outstanding debts over time. This section describes the borrowing/repayment functions, the interest rate model integration, and risk controls via collateral factors.

**Borrowing Shares:** A user initiates a borrow by calling `borrowShares(poolId, shareAmount, to)`. This is typically done through the front-end (with the Spot hook facilitating if needed, though borrowing can be an independent tx). The vault requires that borrowing for the pool is not paused (`PAUSE_BORROWS` flag off) and that an **interest rate model** is set for the pool (or it reverts `InterestModelUnset`). It then **accrues interest** on the pool’s debt up to the current block (ensuring the most up-to-date interest index, see below). Next, it computes the _underlying token amounts_ corresponding to the requested `shareAmount` – essentially how much token0 and token1 the burned shares represent at current pool prices. Using Uniswap’s spot or TWAP price (via the Spot hook’s oracle or pool reserves), the vault determines the dollar value of `shareAmount` in terms of token0 and token1. Those tokens are then **pulled from the pool** (by burning the vault’s LP shares) and transferred out to the borrower’s address (`to`). Internally, the user’s `borrowShares` balance increases by the amount borrowed, representing the debt in share units.

**Collateral Checks:** Every borrow is subject to strict **collateralization requirements**. The vault computes the user’s total collateral value vs. their total debt after the new borrow. Collateral includes the user’s remaining LP shares, any idle token balances (`token0Claims`, `token1Claims`), and any custom positions (see §5.4), each multiplied by an approved collateral factor. Debt is the new total `borrowShares * current share price`. Two collateral factor thresholds are enforced: an **initial collateral factor** (for opening a new debt position) and a slightly higher **maintenance collateral factor** (for existing debt). If the user had no prior debt (`borrowShares=0` before this action), the stricter initial factor applies; otherwise, the maintenance factor applies. For example, if the collateral factors for full-range LP shares are init=50% and maint=80%, a first-time borrower can only borrow up to 50% of their collateral value, but subsequent top-ups could extend towards 80%. These checks prevent users from taking on too much debt initially and ensure a buffer before liquidation. The contract uses `getCollateralFactors(poolId, positionType)` from the PoolPolicyManager to fetch the relevant percentages (positionType 0 for full-range shares, 1/2 for token balances, etc.) and requires:

- **Init check (if new debt):** `borrowValue * 10000 <= collateralValue * initBps` (else revert `ExceedsInitCF`).
- **Maint check (if existing debt or subsequent borrow):** `borrowValue * 10000 <= collateralValue * maintBps` (else `ExceedsMaintCF`).

These conditions must hold after the borrow. If they fail, the transaction reverts and no debt is created. On success, the user’s `borrowShares` is increased and `totalBorrowShares[poolId]` (slot 13) is incremented by the same amount. A `Borrow` event is emitted with details.

**Repaying Debt:** To repay, a user calls `repayShares(poolId, shareAmount, from)`. This function similarly checks it’s not paused (`PAUSE_REPAY` flag) and immediately **accrues interest** for the pool to update the debt amount. The user (or someone on their behalf) must provide the underlying tokens equivalent to the `shareAmount` of debt being repaid. The VaultManager calculates the current token value of that `shareAmount` (using the latest price/index). It then **transfers in** those tokens from the `from` address to the vault (if the user had tokens sitting in their vault balances, they could specify `from = address(this)` to use those). After receiving the tokens, the vault reduces the user’s `borrowShares` by the specified amount and decrements `totalBorrowShares` accordingly. It effectively “mints” the equivalent LP shares internally and returns them to the pool’s full-range position, paying down the debt. The user’s collateral (LP shares or other) that was implicitly burned is restored proportionally because less of their share of the pool is now debt. A `Repay` event is emitted with the details. Users can repay in part or in full; if they repay more shares than their debt, the function reverts `RepayTooMuch`.

**Interest Accrual:** Interest on all outstanding loans accrues continuously based on a per-pool interest rate. The vault employs a **cumulative index model**: each pool has a `BorrowIndex` (slot 9) with `lastAccrueTime` and `shareIndex` (a high-precision ray value). When `accrueInterest(poolId)` is called (automatically at each borrow/repay, or manually by keepers/Governance), the VaultManager computes the time elapsed since the last accrual and queries the pool’s **InterestRateModel** (external contract set in `interestRateModel[poolId]`, slot 14) for the current interest rate. The interest model typically provides an interest per second (based on pool utilization or other factors). The vault then updates the `shareIndex` by multiplying it by (1 + rate\*dt) (using ray math for precision). The `lastAccrueTime` is set to now. This index represents the growth factor of debt: if it increases by 5%, it implies all borrowers’ owed amounts effectively grew 5%. The vault doesn’t iterate over loans; instead, the next time each borrower interacts, their owed tokens are calculated using the ratio of the new index to the snapshot of the index when they last borrowed. (A per-user `borrowIndex` field is reserved in `UserVault` for future use to optimize this calculation, but in the current design, the system uses the global index and a simplified approach where interest is charged upfront on each operation). An `InterestAccrued(poolId, interestFactor, newShareIndex)` event is emitted whenever the index is updated.

**Interest Rate Model:** The interest rate model (set by `setInterestRateModel(poolId, addr)` by governance) implements the logic for variable interest. Typically it will follow a utilization curve (low rates when utilization is low, higher as the pool’s borrowed shares approach total shares). The VaultManager simply trusts this model’s `ratePerSecond(poolId)` output. This modular design allows upgrading the rate strategy without changing vault logic. All interest paid by borrowers effectively goes to liquidity providers (it increases the value of remaining shares) or to the protocol if a reserve factor is configured (in the current design, interest feeds directly into the pool, analogous to how Compound’s model increases lender asset value).

**Invariants & Gas:** The lending subsystem is built to maintain **solvency invariants at all times**. It is invariant that the total borrowed shares never exceed total supply of shares – the vault won’t lend out more liquidity than exists. Every user’s position must stay above maintenance margin or the contract will not allow further borrowing and will flag them for liquidation. Collateral factor ordering is enforced: initial factor ≤ maintenance factor ≤ 100%, ensuring no division by zero or negative equity scenarios. The share-based model guarantees that as interest accrues, `totalBorrowShares * sharePrice` reflects the rising debt in token terms, while `shareData.totalShares * sharePrice` gives pool liquidity value – the condition `totalBorrowShares <= totalShares` means the pool is never over-borrowed. On the gas front, Phase 3 achieved its targets: a cold borrow costs around **115k gas** and a cold repay \~**108k gas**, which is within the 120k/110k budget. This efficiency comes from using a single storage slot for debt and a single interest index (versus per-user accounting) and from batching reads/writes as much as possible (reading the whole UserVault struct at once, etc.). Borrowing and repayment automatically invoke the minimal number of external calls (interest model and oracle price).

> **Storage & Types:** Borrowed share balances are stored per user in `UserVault.borrowShares` (within slot 7’s mapping) and aggregated in `totalBorrowShares` (slot 13). The interest index lives in `borrowIndices` (slot 9), and the interest rate model address in `interestRateModel` (slot 14). Collateral factors for each collateral type (full-range LP = type0, token0 = type1, token1 = type2, custom LP = type3, etc.) are stored in the PoolPolicyManager and can be updated by governance (e.g. in response to volatility). The vault’s logic uses those factors on every borrow/repay to enforce **no under-collateralized debt**. If a user’s debt ever grows (through interest) to violate maintenance ratio, they become eligible for liquidation (see §5.6). Otherwise, the system ensures **no borrower can ever escape paying interest or reduce their debt without actually repaying** – interest is accrued before any repay or further borrow, and debt is denominated in shares so there’s no way to “inflate” it away. Borrow and repay functions are marked `nonReentrant` to prevent any reentrancy issues. The design also prevents “self-borrowing loops” (depositing and borrowing the same asset to farm interest) – such a strategy is either disallowed or unprofitable due to interest >= yield, as noted in protocol documentation.

## 5.4 LP-NFT Collateral (Concentrated Positions)

Phase 4 introduced the ability to use **concentrated liquidity positions** (Uniswap v4 LP NFTs) as collateral within the vault. Users can now allocate a portion of their liquidity to a custom price range, enhancing capital efficiency, while still keeping that position inside the vault for borrowing and margin purposes. These are managed by two primary functions: `openLPPosition` and `closeLPPosition`, along with a fee collection helper.

**Opening a Position:** A user calls `openLPPosition(poolId, tickLower, tickUpper, amount0Desired, amount1Desired, amount0Min, amount1Min)`. This operation is executed via the Spot hook (to handle the actual Uniswap interactions) or directly by the user through the VaultManager. The vault first ensures the position feature isn’t paused (there could be a specific flag or it falls under a general deposit/pause). It then transfers up to `amount0Desired` and `amount1Desired` from the user (like a deposit, respecting min slippage params) to provide liquidity in the specified **tick range**. Using Uniswap’s **PositionManager** (address stored in slot 4), the VaultManager mints a new liquidity position NFT for the given range and liquidity amount. The NFT is held in the VaultManager’s custody (like all vault LP NFTs). The vault records metadata about this position in `lpPositionMeta[poolId][positionId]` (slot 16), including the owner (which user opened it), the tick range, the liquidity quantity, and snapshots of fee growth in the range. It also updates `positionOwnerIndex[poolId][user]` (slot 17) to append this new `positionId` to the user’s list of open positions. Simultaneously, the user’s `positionCounts` in their UserVault is incremented to track how many non-full-range positions they have open. On successful creation, an `LPPositionOpened` event is emitted with details of the position (owner, positionId, provided amounts, etc.).

From the user’s perspective, this operation moves some of their assets into a focused liquidity band. Those assets now contribute to the pool only when the price is within `[tickLower, tickUpper)`. Importantly, the position’s **value** (the worth of the NFT in underlying tokens) still counts toward the user’s collateral in the vault. The VaultManager will value the position in real-time using the pool’s current price – essentially, at any moment the position can be treated as some amount of token0 and token1 (even if it’s currently in/out of range, it has an implicit value). This allows users to borrow against concentrated positions as well, though the PoolPolicyManager may assign different collateral factors to such positions (possibly more conservative due to their higher risk). In Phase 4, a new collateral type (e.g. type 3) was introduced for custom-range LP, with its own init and maintenance factors.

**Earning Fees:** While the custom position is active, it earns trading fees separately from the full-range position. These fees accumulate within the NFT (Uniswap tracks them). The vault does **not** automatically reinvest fees for individual positions (to avoid moving the user’s specific liquidity). Instead, the user (or a keeper) can call `collectLPFees(poolId, positionId)` to harvest the fees from that NFT without closing the position. This will invoke Uniswap’s `collect` on the position, transferring any accrued token0 and token1 fees to the VaultManager. The vault then credits those amounts to the user’s `token0Claims`/`token1Claims` balances (as they now belong to the user but are held in the vault). The position’s fee counters (`feeGrowthInsideLast` in `LPPositionMeta`) are updated so it effectively resets the earned fees tracker. An `LPFeesCollected` event is emitted to record the collection. This allows users to realize profits from their concentrated positions periodically or before adjusting them, without taking the position out of the vault.

**Closing a Position:** When a user wants to remove a concentrated position, they call `closeLPPosition(poolId, positionId, amount0Min, amount1Min)`. The vault will look up the position metadata (to ensure the caller is the owner of that position) and then use the Uniswap PositionManager to **remove all liquidity** from that NFT. This converts the position back into the underlying tokens (any impermanent gain/loss or fees are realized at this point). The tokens are not sent directly to the user; rather, they are returned to the vault contract. The VaultManager then updates the user’s balances: it increases the user’s `token0Claims` and `token1Claims` by the amounts of tokens exited from the position. Essentially, the liquidity is turned into claimable tokens inside the vault for the user. The vault then deletes the position metadata entry and removes the positionId from the user’s `positionOwnerIndex` array (maintaining consistency by possibly swapping the last element into the removed slot). It decrements the user’s `positionCounts` in their UserVault to reflect one less open position. Finally, an `LPPositionClosed` event is emitted with the outcome (amount0/amount1 returned). The user can later withdraw those tokens from the vault or use them to open another position or repay debt, etc.

All these operations (`openLPPosition`, `collectLPFees`, `closeLPPosition`) are integrated into the vault’s solvency logic. When assessing a user’s collateral vs. debt, the VaultManager aggregates: the value of their full-range shares, plus the value of each custom position, plus any idle tokens. A custom position’s value is essentially `token0 + token1 * price` (if partially out of range, one of those components is fully present as the deposited asset). For example, an NFT out-of-range on one side is effectively all one asset – the vault counts that fully. If in range, it’s a mix of both assets; the vault uses an oracle or on-chain formula to estimate its current composition. This is facilitated by Uniswap’s math (given liquidity and current tick, one can compute how much of each token the position represents at the current price). Thus, **custom positions are treated as first-class collateral**. They have their own collateral factor (e.g. perhaps a bit lower than full-range LP since they may be riskier), set via PoolPolicyManager’s `CollateralFactorUpdated` (Phase 3 event) for positionType 3. The vault’s invariant checks ensure even with concentrated positions, the user’s **loan-to-value stays under the limit** – if the position’s value falls (price leaves the range, making liquidity effectively one-sided with perhaps less total value), the system can trigger liquidation (see §5.6).

**Use Cases:** This feature enables strategies like providing narrowly focused liquidity to earn higher fees and still being able to borrow against it, or setting up positions that double as **limit orders** (one-tick positions – see §5.5). It greatly increases capital efficiency. From a technical standpoint, it was implemented without changing the vault’s core storage layout established in Phase 1 – just adding new slots for the metadata and owner index (slots 16–17). It did not disrupt any Phase 1–3 functionality (the append-only storage approach). Gas costs for these operations were optimized: opening a position costs on the order of \~**170k gas**, closing \~**150k**, and fee collection \~**110k**, all acceptable for occasional management operations.

> **Storage & Modules:** Custom positions are stored in `lpPositionMeta` (slot 16), which maps a pool and NFT ID to an `LPPositionMeta` struct with fields like owner address, tickLower, tickUpper, liquidity (uint128), and fee accrual snapshots. The struct might also include `owed0`/`owed1` if any tokens are yet to be collected. The `positionOwnerIndex` (slot 17) maps each pool and user to an array of their position IDs. The length of this array equals the `positionCounts` in the user’s vault struct, and this provides an easy way to enumerate and liquidate all of a user’s positions if needed. The Uniswap **PositionManager** is crucial here (slot 4): it’s the contract that actually mints and burns the NFT positions. The vault never transfers these NFTs out; it holds them until closed, which means the vault contract is the on-chain owner of all LP position tokens. This simplifies fee collection and liquidation (the vault can directly manipulate any position). All position openings/closings are subject to global pause flags (`PAUSE_DEPOSITS` could logically cover opens of new positions, and a specific flag could cover position management). The design remains forward-compatible: the vault reserved space in the UserVault for `positionCounts` from the start, and by Phase 4 simply activated it.

## 5.5 Position-Based Limit Orders

Phase 5 added a native **limit order** feature to the vault. A limit order in this context is essentially a very narrow (one-tick wide) liquidity position that allows a user to swap a specific amount of one token for the other once a target price is reached. By leveraging Uniswap’s AMM mechanics, the vault can place liquidity at a single tick, so that when the market price crosses that tick, the liquidity is taken and the user ends up holding the opposite asset – achieving the effect of a limit order execution. These limit orders are managed as special LP positions inside the vault.

**Placing a Limit Order:** A user calls `placeLimitOrder(poolId, isBuyOrder, amountIn, tickTarget)`. Here, `isBuyOrder` indicates which asset the user wants to acquire: if true, the user is using token0 to buy token1 (so they are selling token0 at a higher price – a “zero-for-one” order), if false, they are using token1 to buy token0 (a “one-for-zero” order). The vault will transfer `amountIn` of the sell token from the user (similar to a deposit) and then create a one-tick-wide liquidity position:

- If `isBuyOrder = true` (sell token0 for token1), the position is set just **above** the target tick. The user’s token0 is placed as liquidity that will sit just below the target price, waiting for the price to rise into that tick and swap the token0 for token1. In Uniswap terms, token0 is the one being sold as price goes up.
- If `isBuyOrder = false` (sell token1 for token0), the position is set just **below** the target tick. The token1 is placed such that when price falls to the tick, the liquidity converts token1 into token0.

In either case, the position covers exactly one tick interval (from tickTarget to tickTarget+1, effectively) – meaning it’s as concentrated as possible. The vault uses the PositionManager to mint this position NFT, very much like in §5.4, and records it in `lpPositionMeta` and `positionOwnerIndex`. In fact, limit orders are implemented under the hood using the same data structures as other custom LP positions (type 3 collateral). The difference is just in the chosen tick range and that only one asset is contributed. The vault may mark these positions internally (e.g. via a flag in metadata or by recognizing that `tickUpper = tickLower+1` and one of the deposited token amounts is zero) as limit orders for special handling.

A `LimitOrderPlaced` event is emitted, indicating the pool, tick, direction (zero-for-one or one-for-zero), and amount provided. The user’s `positionCounts` increases by 1 and the position is tied to them as collateral just like any LP position. Crucially, the user’s `token0Claims/token1Claims` don’t increase because the tokens went into the position, not idle balance. Instead, they now hold an “order” represented by that position.

**Execution on Price Crossing:** Once the market price touches the target tick, the limit order position will start getting filled by arbitragers or traders. For example, suppose it was a sell-token0 order (isBuyOrder=true). As the price moves up to the tick, trades will consume the token0 in that one-tick range, giving the position token1 in return. Once the price fully crosses the tick, the position will have entirely flipped its composition: all the token0 originally provided will be gone, and the equivalent value in token1 will now be sitting in the position (or vice versa for the opposite order). At that point, the limit order is effectively **executed** – the user has bought the target asset at the desired price. However, the position NFT still exists (with only the output token inside it). The vault needs to “settle” the order by removing the liquidity and releasing the output tokens to the user.

AEGIS V2 allows **anyone** (typically a keeper bot) to trigger the settlement of a filled order. The function `cancelLimitOrder(orderId, to)` serves this purpose. If the order is unfilled or partially filled, calling `cancelLimitOrder` will simply withdraw whatever liquidity or tokens are currently in the position and return them to the user (effectively canceling the order). If the order has been fully executed by market price movement, `cancelLimitOrder` will withdraw the proceeds of the order (all in the output token). In both cases, the VaultManager calls PositionManager to burn the one-tick liquidity NFT (like a close position), transfers any remaining tokens from it to the vault, updates the user’s balances, and deletes the position record. Essentially, `cancelLimitOrder` is a wrapper around `closeLPPosition` for one-tick positions, but it’s made available to anyone (not just the order owner) because a keeper might execute the order on the user’s behalf when the price crosses. The `to` parameter specifies where the output tokens should go; typically this would be the user’s address (so a keeper would call `cancelLimitOrder(..., to=user)` to deliver the funds). The vault verifies the caller’s intent is allowed (either the owner or a public executor if the order conditions are met). In the current design, there is **no protocol fee or incentive paid to the executor** of the order beyond the arbitrage opportunity. This was a deliberate simplification: the expectation is that if the order offers a favorable price, arbitrageurs will fill it and then call `cancelLimitOrder` to claim the output, possibly making a small profit externally. The protocol doesn’t charge any fee on limit order execution; the user effectively gets the full benefit of their limit order price.

**Active Tick Tracking:** To facilitate efficient execution, the vault maintains an `activeTicks` set for each pool (slot 18). Whenever a limit order is placed at tick T, that tick is added to the pool’s active set. When an order at tick T is canceled or fully executed and removed, the vault removes T from the set if no other orders remain at that tick. The Spot hook or external keepers use this set to quickly identify relevant ticks. For instance, when the pool’s price crosses a tick, the Spot hook (in `afterSwap`) could check if that tick is in the active set – if so, it knows a limit order was present and likely got filled. The hook can then call `cancelLimitOrder` automatically, or signal a keeper to do so. The vault’s design anticipated scaling to many orders; thus, `activeTicks` is structured for efficient insertion/removal and lookup (e.g. using a mapping and an array for O(1) membership check and manageable iteration). In the final implementation, a single mapping `activeTicks` (slot 18) tracks ticks with any open orders, and additional reserved storage (slots 19–20) remains for potential future order book optimizations. (The Phase 5 draft considered an aggregated `LimitOrderBook` per tick and an array of active ticks, but the simplified approach in final implementation is to treat each order as an individual position and use a tick set for triggers. This maintains clarity and leaves room to aggregate in future if needed.)

**Collateral and Margin:** An open limit order is counted as part of the user’s collateral. Essentially, until it’s executed or canceled, the assets locked in the order still belong to the user (in the form of the NFT liquidity). The vault accounts for the value of that liquidity similarly to any other position. If the user has no debt, it’s straightforward – it’s just their asset in a different form. If the user has debt, the order’s value contributes to keeping them solvent. One subtlety is that while the order is pending, the user cannot freely use those locked assets (they’d have to cancel the order to free them), but they still provide security for the loan. The collateral factor for one-tick positions may be set more conservatively, because a limit order that is far out-of-range is essentially idle and could have a time lag to convert to a liquid asset. However, because the vault can cancel the order and retrieve the assets if needed (e.g. during liquidation), it is valid collateral. In fact, during a liquidation (see §5.6), the liquidator can choose to cancel the user’s limit orders to seize the underlying tokens if those are the easiest collateral to grab.

**Lifecycle:** Summarizing a typical lifecycle: (1) User places a limit order (e.g. sell 1000 USDC for WETH at a certain price). (2) The vault locks 1000 USDC in a one-tick position at the target price. (3) Time passes; when market hits that price, trades take the 1000 USDC and replace it with, say, 0.5 WETH in the position. (4) A keeper notices the tick crossed and calls `cancelLimitOrder` for the user’s order. (5) Vault withdraws the 0.5 WETH from the position, credits it to the user’s balances (or sends to their address), and marks the order closed. The user effectively swapped 1000 USDC for 0.5 WETH at the target price, minus perhaps some slippage within the tick (negligible if tick width is small). If the price never reaches the tick, the user can cancel and get back their 1000 USDC (or whatever remains if partially filled).

> **Storage & Cleanup:** Limit orders utilize the same storage as other LP NFTs (slots 16–17 for metadata and indexing). The design reserves slot 19 and 20 for possible expansion of order tracking (e.g. a more complex order book), but currently they remain unused and marked reserved. The `activeTicks` mapping (slot 18) is the primary addition for performance. Each limit order is one entry in `lpPositionMeta` and is indistinguishable there from a regular position except by its range (tick interval = 1) and initial deposit pattern (single-sided). The system ensures that when an order is closed, all references are removed: the positionId is taken out from the user’s index, and the tick is removed from activeTicks if appropriate. This prevents buildup of stale data. In terms of modules, no special external module is needed for limit orders – it reuses the Spot hook and Uniswap managers. However, off-chain **keeper bots** are an implicit part of the system: to ensure timely execution, the protocol expects that arbitrageurs or keepers will monitor price moves and call the execute/cancel function for orders. The incentive for them is the arbitrage profit or at least the avoidance of leaving money on the table (the user’s order effectively offers a small arbitrage when it’s priced better than the market just before crossing). The protocol may later introduce a small incentive fee or gas rebate for order execution, but none exists in the current design.

## 5.6 Liquidation & Protocol-Owned Liquidity

Phase 6 implemented automated **liquidation** of under-collateralized positions and introduced the concept of **Protocol-Owned Liquidity (POL) as an insurance fund**. If a user’s borrow position falls below safety thresholds, the vault allows it to be liquidated by others to prevent bad debt. The liquidator repays some or all of the debt in exchange for the user’s collateral, with a portion of that collateral going to the protocol as a penalty (insurance). The key functions here are `liquidatePosition` (for partial, or “soft” liquidation) and `liquidateVault` (for full liquidation), as well as a governance function `coverBadDebt` that uses POL to shore up any deficits.

**Liquidation Triggers:** Every borrower must maintain their **Debt-to-Value Ratio (DTR)** below the maintenance collateral factor (e.g. if maint = 85%, debt should be ≤85% of collateral value). If due to market moves (collateral value drops or debt increases via interest) a user’s DTR goes beyond a **soft trigger** (e.g. 98% of the allowed max), their position becomes eligible for partial liquidation. If it reaches the absolute limit (100% or more, meaning debt ≥ collateral value), it is eligible for full liquidation. The vault does not automatically liquidate; instead, it relies on external actors (keepers) to call the liquidation functions when they spot such conditions. However, the vault provides all the info needed (via events, lens views, etc.) to detect these. Additionally, if a position lingers above the soft trigger for a certain **grace period**, the system may allow full liquidation even before reaching 100% (to avoid long-term near-insolvency). These specifics are governed by policy – for simplicity: DTR ≥98% → partial liquidation allowed; DTR ≥100% (or prolonged >98%) → full liquidation allowed.

**Partial Liquidation (Soft):** The function `liquidatePosition(poolId, user)` handles partial liquidations. When called, the VaultManager checks global `PAUSE_LIQUIDATIONS` is not set and then assesses the target user’s vault. If the user’s DTR is below the trigger (not high enough), it reverts `NotInLiquidationWindow`. If it’s above the trigger (e.g. 98%), the vault proceeds. The goal of a partial liquidation is to **repay a sufficient portion of the debt to bring the user’s DTR back to a safe level** (say down to \~90%). The vault calculates an amount of debt `X` (in share units) that, if repaid, would reduce the DTR to an acceptable value (this could be a fixed fraction like 10% of the debt, or whatever achieves target LTV).

- The liquidator is expected to provide the underlying tokens equal to that `X` shares of debt. VaultManager uses the oracle price and current interest index to compute the token0 and token1 needed (this is similar to the repay calculation). Let’s denote these provided tokens as D0 and D1 (amounts of token0 and token1).
- The vault then reduces the user’s `borrowShares` by X (effectively forgiving that portion of debt as it’s being paid off). Now the user’s debt is smaller.
- In exchange, the vault must **seize collateral** from the user equivalent to the value of the repaid debt plus a penalty. Typically, the penalty is 10% of the debt value (so liquidator gets assets worth 110% of what they paid, yielding a 10% bonus). The vault calculates the amount of collateral assets to take such that their market value = D0+D1 \* 110%. This collateral could be in various forms: first, any idle token balances of the user (token0Claims, token1Claims) are easiest to take; then full-range LP shares (which can be converted to tokens by burning shares); then perhaps entire custom positions (closed and taken). Partial liquidation tries to not completely wipe out the user if possible – it will take just enough. In practice, the vault likely burns some of the user’s LP shares to withdraw tokens, and/or takes some of their token claims. It may also close one of their smaller custom positions if needed to cover the amount. After determining what to seize, the vault transfers **90%** of those seized tokens to the liquidator (that equals the debt they covered, plus a proportional bonus if collateral exactly equals 110%). The remaining **10%** of the seized value is kept by the vault as insurance. Concretely, the vault might call `_mintPolFromLiquidation(poolId, bonus0, bonus1)` to add that 10% (bonus0 token0 and bonus1 token1) as protocol liquidity, crediting `insurancePolShares`.
- The user’s vault remains open but now with less debt and less collateral. An event like `VaultPartialLiquidated` or `PositionLiquidated` is emitted, containing how much debt was repaid and collateral seized (and possibly the liquidator address).

After a partial liquidation, the user typically has a healthier DTR (e.g. back to \~88-90%). They can continue as a borrower, or choose to repay or add collateral to improve their position. The protocol prefers partial liquidations as a first line of defense because it allows positions to be salvaged (user doesn’t lose everything) and avoids firesales unless absolutely necessary. Multiple partial liquidations can happen over time if the user keeps hovering near the brink.

**Full Liquidation:** The function `liquidateVault(poolId, user)` triggers a complete liquidation of a vault. This is called when the user’s debt is equal or greater than their collateral value (or they failed to recover after soft liquidations). Full liquidation means the user loses all remaining collateral and the loan is closed out entirely. The steps:

- The liquidator must pay **the entire outstanding debt** of the user. That means providing tokens equal to `user.borrowShares * current share price` (essentially all D0,D1 required to cover 100% of debt). The VaultManager will transfer in those tokens from the caller. If the caller doesn’t supply enough (which would be odd, since amount is known), it fails; typically the caller will call with the exact required amounts.
- The vault then sets `user.borrowShares = 0` (debt cleared) and correspondingly reduces `totalBorrowShares`. The vault proceeds to **seize all collateral** from the user: all their token0Claims and token1Claims are taken, their entire `shareBalance` of full-range shares is burned and withdrawn from the pool, and every custom LP position they have is closed (the VaultManager will iterate through `positionOwnerIndex` to close each position NFT). In short, the user’s vault is emptied out.
- Now, how to distribute that collateral? If the collateral’s total value is **greater than or equal to** the debt that was owed, the liquidator can be made whole. The standard protocol rule is still to give the liquidator 90% of the collateral and reserve 10% as insurance. If collateral value = debt (user was exactly at 100% DTR), liquidator pays e.g. \$100 and gets \$100 in collateral – but to incentivize taking such trades (since there’s no profit), the protocol grants a 10% bonus from that collateral. So the liquidator would get \$90 (out of the \$100 collateral) plus \$10 as bonus – actually in that case, they get all \$100 (since 90% of collateral covers their \$100 paid, plus 10% bonus = the full collateral). If collateral value was _more_ than debt (perhaps the user’s DTR was just slightly over 100%), the liquidator would get 90% of collateral, which is more than the debt they paid (profit), and the protocol takes 10%. If collateral value was _less_ than debt (say user had \$95 collat for \$100 debt), the liquidator will get all \$95 of collateral (the vault isn’t going to hold insurance when not even debt is covered; typically 90% rule means liquidator gets \$85.5 and protocol \$9.5, but that doesn’t cover \$100 – we handle that via bad debt, explained next). In practice, if collateral < debt, the liquidator still loses some money (they paid \$100, got \$95 value, a \$5 loss). The protocol will then register that \$5 as **bad debt**.
- The outcome: The user’s vault is closed (no collateral, no debt). A `VaultLiquidated(poolId, user, debtRepaid, collateralSeized)` event is emitted. If any shortfall occurred (debt not fully covered by collateral), the vault records the amount in `badDebt[poolId]` (slot 23) and emits `BadDebtRecorded(poolId, amount)`. Conversely, if collateral exceeded debt, the leftover after paying the liquidator’s 90% might effectively go into the insurance fund (depending on implementation, but typically protocol keeps 10% of collateral regardless, so any excess collateral beyond the liquidator’s payment just means the protocol’s 10% is larger in absolute terms and covers the remainder). The `insurancePolShares` may increase as a result of taking that 10% (the vault would add the seized tokens to POL).

At this point, the user is wiped out in that pool (their UserVault for that pool would show 0 assets and 0 debt). They could still use other pools independently (each pool’s collateral/debt is managed separately by design). If they end up with bad debt recorded, it means the LPs of that pool suffered a loss equal to that bad debt (the pool’s assets were used to pay out more than the collateral could support, effectively). The system’s health metrics (see Appendix F or VaultMetrics events) would show that pool’s `totalCollateral` vs `totalDebt` and any `badDebt` outstanding.

**Protocol-Owned Liquidity & Bad Debt:** The vault accumulates an insurance buffer through the 10% liquidator penalties and the fee splits. All POL (both from fees and liquidations) is tracked in `totalPolShares` (slot 21), and the subset from liquidations in `insurancePolShares` (slot 22). Invariants: `insurancePolShares <= totalPolShares` always, and ideally `insurancePolShares` grows over time to cover any potential defaults. If a `badDebt` is recorded, governance can invoke `coverBadDebt(poolId, shares)`. This owner-only function uses the protocol’s POL to offset the bad debt. It will burn the specified amount of the protocol’s liquidity shares (up to the amount needed) from the pool and use the withdrawn tokens to cancel out the bad debt. Essentially, the protocol is paying off the shortfall from its own pocket/liquidity, making the pool whole. When executed, `coverBadDebt` reduces `badDebt[poolId]` accordingly, lowers `totalPolShares` and `insurancePolShares` (since some of the insurance liquidity was expended), and emits `BadDebtCovered(poolId, amountCovered)`. This mechanism socializes losses to the protocol (and by extension, possibly token holders or treasury) rather than LPs, which is important for lender confidence. If the insurance fund isn’t sufficient, governance might cover the rest via other means (e.g. add funds from treasury, or let the bad debt remain for a while).

**Liquidation Auction Details:** AEGIS does not use auctions; liquidations are immediate and at a fixed bonus (10%). This is simpler and relies on arbitrage to make the system solvent quickly. In extreme cases, multiple liquidators might compete, but since the first to call wins, it’s basically first-come. The design ensures that any attempt to liquidate when not warranted will revert (so attackers can’t steal collateral when a vault is healthy). Also, the Pause flag provides a safety hatch: if an oracle malfunctions or a bug is detected, the DAO can set `PAUSE_LIQUIDATIONS` to true (bit 4 of pauseFlags), which will make both `liquidatePosition` and `liquidateVault` revert with `Paused`. This is only for emergencies, as pausing liquidations could lead to bad debt if issues persist. Typically, it would be used briefly to fix an oracle or systemic issue.

**Integration with Collateral Types:** The vault’s liquidation logic considers all forms of collateral. For partial liquidations, it will likely take the **most liquid collateral first**: token balances (already in token form), then full-range LP shares (which can be converted to tokens permissionlessly via PoolManager), then possibly concentrated positions. If it needs to seize a concentrated NFT, it might have to close that position (which could incur some slippage if the range is wide or out-of-range). Because of this complexity, the implementation may prefer to liquidate whole positions rather than fractional, i.e., if a user has a custom position, a partial liquidation might choose to fully close one of their positions as part of the seized collateral. This simplifies execution and is acceptable as long as the value taken is appropriate. In full liquidations, all positions are closed anyway. The system ensures no collateral type is “unseizable”: the vault holds all NFTs, and can withdraw any liquidity or tokens needed.

**Post-Liquidation:** After liquidation, the user’s vault is either healthier or closed. A liquidated user could deposit new funds and start again (the contract does not blacklist addresses for being liquidated, though their creditworthiness in that pool is back to zero until they add collateral). The events emitted allow off-chain systems to record what happened, and the VaultMetrics event (emitted at most once per block per pool) will reflect the reduced debt and possibly increased POL. The insurance fund grows whenever a liquidation happens without bad debt (protocol gains 10% of collateral), and shrinks if coverBadDebt is used.

> **Storage & Metrics:** Liquidation-related state: `insurancePolShares` (slot 22) holds how many POL shares are from insurance (liquidation penalties). `badDebt` (slot 23) tracks any unbacked debt per pool. These are both new in Phase 7 final. The vault emits `BadDebtRecorded` and `BadDebtCovered` events accordingly. The **VaultMetrics** event (emitted with throttling) includes fields for total collateral, total debt, and total POL in a pool, which let observers calculate health ratios easily. Module-wise, liquidations rely on the Spot hook’s price feed (or an integrated oracle) to value collateral vs debt. The PoolPolicyManager provides the collateral factors and could also specify a **liquidation fee** or bonus (hardcoded to 10% in current implementation, but could be adjustable). The design remains within Uniswap’s hook gas limits by performing liquidations as separate transactions (not within swaps). Finally, the integration of POL in liquidity is seamless: the vault’s POL shares simply sit as part of `shareData.totalShares` and earn fees like any liquidity – effectively acting as an insurance buffer that grows over time. An invariant holds that **insurancePolShares never exceeds totalPolShares** (by definition) and **totalPolShares <= shareData.totalShares** trivially. Thus, POL is always a subset of actual liquidity in the pools, ready to be burned to cover losses if needed.

## 5.7 Batch Engine (Atomic Multi-Action Processing)

Each action’s expected results are summarized in the _Post‑Conditions_ tables in
`workflows.md`. At the end of every batch the vault calls `InvariantSuite.verify()`
to ensure all referenced invariants hold before finalizing.

During a batch the interest index is cached once, saving gas (T4).

One of the major enhancements in AEGIS V2 is the **Batch Processing Engine**, which allows users (or keepers) to execute multiple vault operations atomically in a single transaction. Instead of making separate calls for a series of actions (e.g. withdraw, then swap, then repay), a user can package them into one **batch** via `executeBatchTyped`. This improves UX (one-click complex interactions) and can save gas through shared computations. All actions in a batch either **succeed entirely or revert entirely** – ensuring no partial completion or intermediate unsafe states.

**Motivation & Design Goals:** The batch engine is designed to let users build higher-level operations like self-collateralized leverage (borrow and swap to more collateral), position rollovers, or combined deposits and withdrawals, without needing trust in off-chain sequencing. Key design goals include: (a) maintain **safety** by enforcing a deterministic execution order and invariant checks throughout; (b) preserve **atomicity** – if any sub-action fails or would violate constraints, the entire batch aborts (state rolls back); (c) optimize gas by avoiding redundant operations (e.g. accrue interest once for several borrows) and sharing external calls when possible; (d) provide flexibility to support all core action types (liquidity ops, transfers, borrows, repays, swaps, liquidations, etc.).

**Batch Interface:** The VaultManager exposes one primary entry point for batching:

```solidity
function executeBatchTyped(Action[] calldata actions) external nonReentrant;
```

Each batch is an array of encoded actions. The first byte of each `bytes` action is an **Action Code** (a small enum value indicating what the action is), and the remaining bytes are the parameters (similar to function calldata). For example, an encoded Deposit action might start with `0x00` (code for Deposit) followed by the encoded poolId, amount0, amount1, etc. The VaultManager will loop through these actions and perform them in a controlled manner. The entire function is marked `nonReentrant` to prevent any external reentry during execution.

**Deterministic Reordering:** A crucial innovation is that the batch engine **does not necessarily execute actions in the user-provided order** if that order could violate safety. Instead, it categorizes actions into phases and reorders them internally to ensure that risk-reducing moves happen before risk-increasing moves. Specifically, the engine splits actions into two broad phases:

- **Phase A: Collateral-Increasing or Risk-Reducing actions.** These include deposits (adding collateral), repays (reducing debt), and certain neutral operations like collecting fees or poking positions that don’t jeopardize solvency. These will be executed first regardless of their order in the input, because they can only improve the vault’s safety margin. The engine goes through the action list, picks out all Phase A actions, and executes them in the sequence they appeared (relative order preserved among themselves). After each such sub-action, it updates the state and runs an **invariant check** to ensure nothing unexpected broke solvency (though these actions by nature shouldn’t). Typically, deposits and repays will always pass the checks since they make things safer (if a supposed risk-reducing action did trigger an invariant failure, it means something external like a transfer failed or pool was paused – in which case the batch aborts). By the end of Phase A, the user’s vault is in its “safest” intermediate state (max collateral, min debt).
- **Phase B: Collateral-Decreasing or Risk-Increasing actions.** These include withdrawals (removing collateral), borrows (increasing debt), swaps that potentially alter the risk profile, opening new positions (since that reallocates collateral), closing positions or cancelling orders (if they release collateral to the user), and liquidation calls (though those typically affect others’ vaults). After Phase A, the engine executes all Phase B actions, again in the relative order they were given (just grouped after Phase A). Before each action, it checks that the action is allowable (e.g. a Withdraw will check post-withdraw solvency) and after executing it updates state and runs invariant checks. If any action here would violate collateral requirements, it will revert – either via an explicit require in the action’s logic or the post-check detecting a breach. The deterministic ordering ensures that, for example, if the user intended to withdraw then repay (which unsafely would draw out collateral before reducing debt), the engine will swap it to repay first (Phase A) then withdraw (Phase B). If the user only provided a withdraw without a matching repay and it would make them insolvent, the withdraw action itself will fail its check and cause a batch revert.

By structuring execution this way, the engine guarantees that at no point will the vault go into an unsafe state. Any sequence that cannot be reordered into a safe execution (meaning the requested actions are inherently unsafe together) is rejected upfront.

**Invariant Enforcement:** Throughout batch execution, the vault rigorously enforces all relevant invariants. This includes user solvency (collateral vs debt within limits) after each action, pool utilization limits (cannot borrow if pool utilization would exceed a threshold, e.g. 95%), oracle sanity (if an action requires a fresh price and it’s not available or out of bounds, it fails), and maintenance of global invariants like totalShares vs totalBorrowShares. The engine effectively performs a **check after each sub-action** and a comprehensive check at the end. If any check fails, it immediately aborts the batch and reverts all changes. Because state updates are done in-memory or revertible until the batch completes, a revert means the vault is as if the batch never happened (except for gas used). The final check after Phase B is essentially an assertion that the system invariants hold in the end state (which they should if all intermediate checks passed).

**Atomicity:** The all-or-nothing property is inherent in how Ethereum transactions and the EVM work – the batch function call either completes fully or, if a revert is triggered at any point, none of its state changes persist. From the user’s perspective, either the entire sequence of operations succeeded or nothing did. The engine will emit events for each successful sub-action during execution, but if a later action fails and causes a revert, those events (being part of a reverted transaction) will not actually be recorded on-chain. If the batch succeeds, the vault may choose to emit a `BatchExecuted(user, actionsCount)` summary event, though it is optional since one can infer a batch from multiple events in the same tx.

**Batch Execution Pipeline:** Internally, `executeBatchTyped` goes through stages:

1. **Init Batch (Pre-Processing):** Immediately upon entry, the vault performs one-time updates: it **accrues interest** on all pools involved and fetches current oracle prices for relevant assets. If multiple actions involve the same pool, interest accrual is done only once at the start (ensuring a consistent interest index for all subsequent borrow/repay actions in the batch). Likewise, a fresh price is pulled (or a cached TWAP from Spot) so that all actions use the same price baseline. Policy parameters like collateral factors and utilization caps are also loaded upfront for quick reference during the batch. This setup ensures all calculations in the batch are using synchronized, up-to-date data, avoiding timing exploits.
2. **Phase A – Execute Safe Actions:** The engine identifies all **Phase A** actions (Deposit, Repay, etc.) and executes each in order. For example, if the batch was \[Withdraw, Repay], it will reorder to \[Repay] in Phase A first. After executing each, it logs the event and checks invariants. These actions may increase the user’s token balances in vault (for deposits) or decrease their debt (for repays), improving their standing.
3. **Phase B – Execute Risky Actions:** Next, the engine executes all **Phase B** actions in order. Each action’s own checks (e.g. `require` statements such as ensuring a withdraw doesn’t leave negative balance or `ExceedsMaintCF`) will guard against obvious issues. After performing the action (e.g. transferring tokens out for a Withdraw, or increasing debt for a Borrow), the engine runs a post-check to confirm the vault is still solvent and within utilization, etc.. If any fail, revert. Notably, **internal swaps** (Action code V8) are treated as Phase B (neutral but placed after deposits to ensure funding). Swaps are executed via the Spot hook’s swap function; during a batch, each swap will trigger Uniswap hooks which update oracle prices and accumulate fees. The batch engine accounts for this: after each swap action, the latest price is known (since the swap just happened and Spot provides an updated price to the vault), so subsequent actions use the new price. This guarantees that if, say, the user swaps debt into another asset, the vault’s next borrow check sees the post-swap collateral value.
4. **Finalize Batch:** After all actions, the vault performs a final comprehensive invariant check (ensuring the user’s final DTR is below 100%, pool utilizations are fine, etc.). Then it releases the reentrancy lock (automatically as the function returns) and emits any final events like BatchExecuted. The batch then ends successfully.

Throughout the execution, **reentrancy is prevented** by the `nonReentrant` guard on `executeBatchTyped`, meaning that even though the Spot hook might call back into vault functions (like on swaps or mints), those functions are carefully marked or recognized so as not to double-enter the batch engine in an unsafe way. In essence, Spot’s callbacks can call certain vault internal functions but cannot recursively call `executeBatchTyped` (this is explicitly disallowed by the guard). The design ensures that external calls are either view/pure or to known safe contracts (PoolManager, Oracle) that won’t attempt reentrant vault calls.

**Action Codes & Handlers:** The batch engine supports a predefined set of **action codes (V0, V1, …)** corresponding to vault operations. The final implementation defines 15 codes (V0–V14), which include all major functions described in §5.1–§5.6. For reference, **Table 5.7.a** below lists the action codes:

| Safe-Order Phase | Code    | Action Name                        | Phase (Risk Effect)                                  | Internal Handler (simplified signature)                                                            |
| ---------------- | ------- | ---------------------------------- | ---------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| A                | **V0**  | Deposit (Full-Range Liquidity)     | Phase A (reduces risk)                               | `_depositFullRange(poolId, amount0, amount1, minShares)`                                           |
| B                | **V1**  | Withdraw (Full-Range Liquidity)    | Phase B (increases risk)                             | `_withdrawFullRange(poolId, shares, amount0Min, amount1Min, to)`                                   |
| B                | **V2**  | Borrow (Increase Debt)             | Phase B (increases risk)                             | `_borrow(poolId, shareAmount, to)`                                                                 |
| A                | **V3**  | Repay (Reduce Debt)                | Phase A (reduces risk)                               | `_repay(poolId, shareAmount, from)`                                                                |
| B                | **V4**  | Open LP Position (Conc. Liquidity) | Phase B (mostly neutral)                             | `_openLPPosition(poolId, tickLower, tickUpper, liquidity, amount0Max, amount1Max)`                 |
| B                | **V5**  | Close LP Position                  | Phase B (can release collateral)                     | `_closeLPPosition(positionId, amount0Min, amount1Min)`                                             |
| B                | **V6**  | Place Limit Order (One-tick LP)    | Phase B (mostly neutral)                             | `_placeLimitOrder(poolId, isBuyOrder, amountIn, tickTarget)`                                       |
| B                | **V7**  | Cancel Limit Order                 | Phase B (releases collateral)                        | `_cancelLimitOrder(orderId, to)`                                                                   |
| B                | **V8**  | Swap (via Vault/Spot)              | Phase B (neutral)\*\*                                | `_swap(poolId, zeroForOne, amountIn, amountOutMin, to)`                                            |
| B                | **V9**  | Liquidate (Partial)                | Phase B (reduces system risk)                        | `_liquidate(poolId, victim, repayShares, to) returns (seized0, seized1)`                           |
| A                | **V10** | Claim Position Fees                | Phase A (neutral or reduces risk)                    | `_claimPositionFees(positionId, to)` _(collect fees from an active position)_                      |
| B                | **V11** | Close Vault (Repay & Withdraw All) | Phase B (overall reduces risk, but final withdrawal) | `_closeVault(poolId, to)` _(repay all debt using available collat, withdraw remainder)_            |
| B                | **V12** | Liquidate (Full)                   | Phase B (reduces system risk)                        | `_liquidate(poolId, victim, type=FULL, to)` _(could reuse `_liquidate` internally with full flag)_ |
| A                | **V13** | Poke Positions (Update)            | Phase A (neutral maintenance)                        | `_pokePositions(user, poolIds[])` _(update accrual info on positions)_                             |
|                  | **V14** | **(Reserved)**                     | _N/A_                                                | _(Unused placeholder for future actions)_                                                          |

**Table 5.7.a – Supported Batch Action Codes**: _Phase indicates how the engine categorizes the action for ordering. Neutral actions (like swaps) are treated as Phase B by default to ensure all collateral-adding actions happen beforehand. The internal handler functions correspond to VaultManager’s implementations of each action._ (**Note:** Action V11 “Close Vault” is a composite convenience that means “repay all debt (could use user’s vault balances) and withdraw all collateral” – it effectively sequences a Repay for full debt and a Withdraw of remaining collateral; the engine may handle it by expanding into those sub-actions internally.)

When `executeBatchTyped` runs, it decodes each action in turn and calls the corresponding internal function. These handlers are essentially the same code that is used for the external single-action functions, just adapted to be invoked internally without separate authorization (the batch function itself checks permissions globally). This ensures consistency: doing an action via batch or via direct call goes through identical logic, so the same errors and events occur. For example, V0 Deposit will perform the same checks and emit `Deposit` event as a normal deposit call.

**Safety and Gas Considerations:** The deterministic ordering and grouping of actions are what guarantee safety. Users cannot circumvent collateral checks by ordering things cleverly – the engine will always put repays before borrows, etc., or revert if something inherently unsafe is attempted. Neutral actions like swaps are placed in Phase B to be conservative (a swap doesn’t change total value, but executing it after deposits ensures the assets to swap are in place). The up-front interest accrual and price fetch means the entire batch uses a single “snapshot” of time (no gaps for someone to slip in another tx and change things mid-way). There is an invariant that no user vault’s LTV should exceed the maintenance threshold at any point in a batch – the code enforces that by either reordering or reverting. Thus, the system remains as secure as if each action were done in separate transactions with checks in between.

On the gas side, batching multiple actions is generally more efficient than executing them separately. Shared steps like interest accrual, price oracle calls, or repeated storage accesses are done once instead of multiple times. For example, doing a Deposit (\~175k gas) followed by a Borrow (\~115k) separately might cost \~290k total, whereas in a batch the combined could be \~250k because interest is accrued once and some overhead is shared. The engine’s overhead – parsing the array, sorting actions into phases, and looping – is on the order of a few thousand gas per action plus a fixed cost for the initial setup. There’s no unbounded loop except iterating over the actions list (which is bounded by block gas limits anyway). The contract uses memory to accumulate state changes within the batch to avoid excessive storage writes until needed. As a result, even a batch of 10–12 actions should comfortably execute within block limits (likely a couple million gas at most, which is fine on L1). The stack depth is carefully managed (we avoid deep recursion by iterative processing), so we can handle reasonably large batches (though extremely large batches might hit block gas before any stack issues).

**Example Use-Case:** Suppose a user wants to **lever up** on a particular asset in one transaction. They have some WETH deposited and want to borrow stablecoin against it and immediately swap to more WETH (increasing their WETH position). They could construct a batch: `[ Borrow(poolId, X, toVault), Swap(poolId, zeroForOne=false, amountIn=X, minOut=Y, toVault) ]`. The engine will reorder Deposits/Repays (none here) vs Borrows/Swaps as needed. Here both actions are Phase B (borrow increases risk, swap is neutral). It will execute Borrow first (with all checks: they can only borrow such that they remain under init CF). Then it executes Swap – the Spot hook takes the borrowed stablecoins (sitting in the vault as token1 claims from the borrow) and swaps them for WETH, which ends up as token0 claims in the user’s vault. After the batch, the user has more WETH in vault (collateral up) and more debt. The invariant checks ensure the final state is still below maintenance CF (this essentially automates what might otherwise require multiple tx and careful timing). All of it happens atomically, so no front-running can mess up the execution; either it all executes at the expected tick price or it reverts if price moved too much (the user would set `minOut` on the swap to avoid bad slippage, causing revert if not met).

In summary, the Batch Engine empowers advanced interactions while maintaining the vault’s stringent safety guarantees. By sequencing actions internally and rolling back on any failure, it effectively extends the vault’s functionality to **composable DeFi legos** that users can mix and match, without needing any off-chain coordinator. This was a key part of the AEGIS V2 upgrade, enabling features expected in Uniswap v4 ecosystems (like hook-composed operations) to be user-friendly and secure.

> **Note:** Batch processing was introduced in the final spec and was not present in earlier phase drafts. It required careful consideration of hook call gas limits (to ensure a batch doesn’t exceed what Uniswap’s hook can handle – e.g. splitting large swaps, if needed) and of reentrancy (hence the single entry lock). The implementation was tested against all invariants to ensure, for instance, that a batch of \[Withdraw, Borrow] reorders to \[Borrow, Withdraw] or reverts if impossible. Gas usage was measured for common batches (see Appendix D for a gas table), confirming that combining actions yields net savings (e.g., \~330k for a deposit+borrow+swap sequence, which is lower than executing them separately). The system also prevents certain pathological batches; for example, one cannot recursively call `executeBatchTyped` within a batch, and any attempt to do so will hit the reentrancy guard or simply not have a defined action code.

### 5.7.4 Helper Math Libraries (T9)

The core math for deposits, withdrawals, borrows and repays has been extracted into `LibVaultMath` and `LibPoolMath`. These libraries deploy via deterministic `CREATE2` using `bytes32 salt = keccak256("AEGIS_LIB_V1")`. The vault delegate-calls into them, keeping logic modular and upgradeable.

> **Why T9?** Delegate-call libraries keep the main contract slim while allowing upgrades to the math routines without redeploying storage.

| Action Flow            | Old Gas | New Gas |      Δ |
| ---------------------- | ------: | ------: | -----: |
| deposit                | 175 000 | 172 000 | –3 000 |
| withdraw               | 165 000 | 161 000 | –4 000 |
| borrow                 | 115 000 | 112 000 | –3 000 |
| repay                  | 108 000 | 105 000 | –3 000 |
| deposit→borrow (batch) | 285 002 | 279 511 | –5 491 |
| repay→withdraw         | 273 000 | 268 000 | –5 000 |
| close vault (batch)    | 320 000 | 312 000 | –8 000 |

Gas benchmarks were taken on Arbitrum and post‑Dencun Ethereum mainnet
(EIP‑4844 blob pricing). Results show comparable savings across chains.

### Change Log – Phase 5–7 Draft vs Final Implementation

The following summarizes key behavioral changes and design finalizations compared to the Phase 5–7 draft specifications (the earlier design documents), and notes the deprecation of those draft specs in favor of this unified final spec:

- **Limit Orders (Phase 5 Draft → Final):** The draft design contemplated an aggregated order book structure with `limitOrders` mapping and an array of `activeOrderTicks` per pool. In the final implementation, each limit order is simply a one-tick LP position under the hood. The vault uses a single `activeTicks` set (slot 18) to track ticks with orders, and reserved slots 19–20 for future expansion. Multiple users’ orders at the same tick are not aggregated into one NFT; instead, each order mints its own position NFT (this simplifies per-user accounting and removal). The outcome is functionally the same for users, but the internal mechanism is streamlined. The public interface remains `placeLimitOrder` and `cancelLimitOrder` (with execution by keepers allowed), as described in the draft, but final names and storage align with the unified position framework. The older **08_Limit_Orders.md** draft is now archived in favor of §5.5 of this spec.

- **Liquidation & POL (Phase 6 Draft → Final):** The Phase 6 draft proposed integrating Protocol-Owned Liquidity and eliminating the separate FullRangeLiquidityManager. The final implementation realizes this: VaultManagerCore now mints/burns Uniswap liquidity directly (FRLM module removed). The POL accounting is fully implemented with `totalPolShares` and `insurancePolShares` mappings. Liquidation flows were refined: rather than a generic `liquidateVault` for any case, we have distinct `liquidatePosition` (partial) and `liquidateVault` (full) functions, each with clearly defined triggers and outcomes. The draft’s idea of partial vs full triggers (98%/99% thresholds) is preserved, with an added grace period concept in policy (not hard-coded). Event names were adjusted for clarity: e.g. `VaultLiquidated` (with params including any badDebt) replaces a draft name like `LiquidationTriggered` for full liquidations, and `BadDebtRecorded`/`BadDebtCovered` events were introduced to track insurance usage. Additionally, the governance function `coverBadDebt` is finalized to burn POL shares and compensate shortfalls. The Phase 6 spec is superseded by §5.6 of this document.

- **Governance & Observability (Phase 7 Draft → Final):** Phase 7’s draft focused on metrics and admin controls. The final spec integrates these throughout: a **VaultMetrics** event (not present in earlier phases) now emits aggregate pool stats (collateral, debt, POL) at most once per block per pool; this fulfills the observability goal. The pause flag catalog was expanded and finalized (bits 0–10 covering all operations, as detailed in Appendix C). Importantly, the final update introduces the **Batch Engine** which was not in the original Phase 7 scope – this is a new capability added in AEGIS V2 final. It allows atomic multi-step operations, aligning the vault with advanced Uniswap v4 use cases. The addition of `executeBatchTyped` and its safety framework is an extension beyond the phase drafts, reflecting feedback and the evolving DeFi composability requirements. The Phase 7 draft spec (which mainly outlined pause flags and some metric/event plans) is now archived, replaced by §§5.6–5.7 and Appendix C/D of this document.

- **Function & Interface Alignment:** All function names and signatures have been standardized to match the final `IVaultManagerCore.sol`. For example, draft placeholders like `executeOrder` are concretely implemented as `cancelLimitOrder`, and internal helper names were adjusted for consistency (`_repayShares` -> `_repay`, etc.). The final interface (see Appendix A) includes every function introduced across phases 1–7, with no TODOs remaining. Any discrepancies in draft docs have been resolved. For instance, Phase 5’s draft mention of possibly aggregating orders is moot – the final uses one NFT per order as noted, and the interface did not need to expose any aggregation detail.

- **Storage Layout:** The storage slot reservations made in early phases were utilized as intended. E.g. Phase 3 reserved slot 5 and 9 which became active as slot 14 (interestRateModel) and slot 13 (borrowIndices). Phase 4 added slots 16–17 as planned for positions, and Phase 5 reserved slots 18–20 (two of which were partially used for activeTicks and two left reserved). Phase 6 and 7 added slots 21–24 for POL, badDebt, and metrics, aligning with draft expectations. No storage repacking or repurposing occurred – this spec confirms an **append-only storage extension** through V2, exactly as promised in Phase 1 (immutable core). Appendix B provides the final unified storage map. The draft specs for storage (Phase 4 and Phase 5 tables) can be archived now that Appendix B and §4 of this spec supersede them.

- **Gas Targets:** The final implementation met or exceeded the gas optimization targets set in drafts. Phase 3’s borrow/repay gas was within target (see §5.3), Phase 4’s position open/close gas was as projected or lower, and the batch engine, though new, was optimized with shared operations to keep multi-action combos efficient. Specific gas tables from drafts (Phase 3 and Phase 4 gas analysis in the drafts) have been consolidated into Appendix D of this final spec. Any “TODO: optimize X” notes in drafts were resolved in implementation (e.g., caching pool policy lookups in batch, grouping storage reads).

- **Deprecation of Draft Documents:** The phase-specific draft specs (`phase4_spec.md`, `p5_spec.md`, `p6_spec.md`, `p7_spec.md`, etc.) and older batch design notes (e.g. `batch_processing_v1.md`) are now considered **archived** references. All normative information has been merged into this Final Specification. Notably:

  - **Phase 4 Spec**: All content on LP-NFT collateral is now in §5.4, and storage changes in §4/Appendix B.
  - **Phase 5 Spec**: Limit order design is finalized in §5.5 (with differences as noted above).
  - **Phase 6 Spec**: Liquidation and POL mechanisms are in §5.6 (with updated event names and process).
  - **Phase 7 Spec**: Governance controls (pause flags) and metrics events are in §5.6 and Appendix C/E, while the new Batch Engine (not in original Phase 7) is covered in §5.7.

These draft documents should be marked as superseded and archived for historical record. The **Final Specification v2.0** (this document) is now the single source of truth for the AEGIS Unified Vault’s behavior.
