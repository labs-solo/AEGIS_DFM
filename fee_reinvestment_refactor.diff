diff --git a/PR_DESCRIPTION.md b/PR_DESCRIPTION.md
deleted file mode 100644
index 504d75b..0000000
--- a/PR_DESCRIPTION.md
+++ /dev/null
@@ -1,280 +0,0 @@
-# FullRange Phase 7: Complete Multi-File Architecture Implementation
-
-This PR completes the implementation of the FullRange hook for Uniswap V4, following the seven-phase development roadmap. The implementation uses a modular, multi-file architecture that significantly reduces code complexity while maintaining high test coverage.
-
-## Architecture Overview
-
-The FullRange implementation follows a modular design pattern with specialized components:
-
-1. **Core Contract (`FullRange.sol`)**: 
-   - Inherits from `ExtendedBaseHook` to implement Uniswap V4 hook interface
-   - Delegates specialized functionality to submodules
-   - Implements hook callbacks with custom logic for oracle updates and dynamic fee validation
-
-2. **Pool Management (`FullRangePoolManager.sol`)**:
-   - Handles pool creation with dynamic fee validation
-   - Stores minimal pool data (totalLiquidity, tickSpacing)
-   - Enforces governance controls for pool creation
-
-3. **Liquidity Management (`FullRangeLiquidityManager.sol`)**:
-   - Implements ratio-based deposit logic
-   - Handles partial withdrawals with share token burning
-   - Manages leftover tokens (remain in user wallet)
-
-4. **Oracle Management (`FullRangeOracleManager.sol`)**:
-   - Implements block/tick-based throttling for oracle updates
-   - Tracks last update block and tick
-   - Calls external oracle when thresholds are met
-
-5. **Hook Callbacks (`FullRangeHooks.sol`)**:
-   - Handles salt verification
-   - Distinguishes deposit vs. withdrawal by liquidityDelta sign
-   - Processes callback data
-
-6. **Utility Functions (`FullRangeUtils.sol`)**:
-   - Provides ratio math for deposits and withdrawals
-   - Handles token transfers with allowance checks
-   - Implements share calculation logic
-
-7. **Interface Definition (`IFullRange.sol`)**:
-   - Defines core data structures (DepositParams, WithdrawParams, etc.)
-   - Specifies external interface for integrations
-
-## File Structure
-
-```
-src/
-├── FullRange.sol                  # Main contract integrating all modules
-├── FullRangePoolManager.sol       # Pool creation & dynamic fee management
-├── FullRangeLiquidityManager.sol  # Deposit/withdraw & liquidity updates
-├── FullRangeOracleManager.sol     # Oracle throttling & updates
-├── FullRangeHooks.sol             # Hook callback logic
-├── FullRangeUtils.sol             # Helper methods for ratio-based operations
-├── interfaces/
-│   └── IFullRange.sol             # Interface for external integrations
-└── base/
-    └── ExtendedBaseHook.sol       # Base hook implementation
-```
-
-## Test Coverage
-
-All core components have achieved the target of 90%+ test coverage:
-
-- **FullRangeHooks.sol**: 100% line coverage
-- **FullRangeLiquidityManager.sol**: 90.57% line coverage
-- **FullRangeOracleManager.sol**: 97.06% line coverage
-- **FullRangePoolManager.sol**: 95.65% line coverage
-- **FullRangeUtils.sol**: 100% line coverage
-
-The test suite includes:
-- Unit tests for each component
-- Integration tests for the complete system
-- Edge case testing for ratio math, slippage, and oracle throttling
-- Hook validation and callback testing
-
-## Key Features Implemented
-
-1. **Dynamic Fee Pool Creation**:
-   - Only pools with dynamic fees (0x800000) are supported
-   - Governance controls for pool creation
-
-2. **Ratio-Based Deposits**:
-   - Deposits use the optimal ratio of tokens
-   - Leftover tokens remain in user wallet
-   - Slippage protection with min amount parameters
-
-3. **Partial Withdrawals**:
-   - Burn share tokens for partial withdrawals
-   - Proportional token return based on share percentage
-
-4. **Oracle Throttling**:
-   - Block-based throttling (skip updates if not enough blocks passed)
-   - Tick-based throttling (skip updates if tick change is small)
-
-5. **Hook Integration**:
-   - Full implementation of Uniswap V4 hook interface
-   - Custom logic in hook callbacks for oracle updates
-
-## Integration Testing Plan
-
-The following is a comprehensive plan for testing the FullRange implementation against a real PoolManager using Foundry's anvil:
-
-```
-# Simulation Steps (Using Anvil)
-
-## 1. Install & Setup Foundry
-- Install Foundry by running:
-  ```
-  curl -L https://foundry.paradigm.xyz | bash
-  foundryup
-  ```
-- Clone the repositories for your FullRange code (Phases 1–7) and the Uniswap V4‑core codebase.
-- In your FullRange project folder, configure the foundry.toml or remappings.txt so it references your local Uniswap V4‑core path. Example:
-  ```
-  remappings = [
-    "v4-core=../uniswap-v4-core",
-    # possibly other remappings
-  ]
-  ```
-
-## 2. Launch an Anvil Local Testnet
-- Open a new terminal and run:
-  ```
-  anvil --block-time 1
-  ```
-  This spins up a local Ethereum environment with instant blocks or ~1s blocks, ideal for testing.
-
-## 3. Deploy a Real PoolManager from Uniswap V4‑Core to Anvil
-- In your FullRange repo, create a deployment script (e.g., a Foundry "script" or a Hardhat plugin if you prefer bridging).
-- Compile the v4‑core code with Foundry:
-  ```
-  forge build
-  ```
-- Deploy the PoolManager contract to your local anvil:
-  ```
-  forge create --rpc-url http://127.0.0.1:8545 path/to/PoolManager.sol:PoolManager --private-key <YOUR_TEST_KEY>
-  ```
-- This yields a deployed address for your PoolManager. Note it for the next step.
-
-## 4. Deploy Submodules (PoolManager, LiquidityManager, OracleManager) against Anvil
-- FullRangePoolManager:
-  ```
-  forge create --rpc-url http://127.0.0.1:8545 ./src/FullRangePoolManager.sol:FullRangePoolManager \
-    --constructor-args <DeployedPoolManagerAddress> <GovernanceAddress> \
-    --private-key <YOUR_TEST_KEY>
-  ```
-- FullRangeLiquidityManager:
-  ```
-  forge create --rpc-url http://127.0.0.1:8545 ./src/FullRangeLiquidityManager.sol:FullRangeLiquidityManager \
-    --constructor-args <DeployedPoolManagerAddress> <DeployedFullRangePoolManagerAddress> \
-    --private-key <YOUR_TEST_KEY>
-  ```
-- FullRangeOracleManager:
-  ```
-  forge create --rpc-url http://127.0.0.1:8545 ./src/FullRangeOracleManager.sol:FullRangeOracleManager \
-    --constructor-args <DeployedPoolManagerAddress> <TruncGeoOracleAddress> \
-    --private-key <YOUR_TEST_KEY>
-  ```
-- No direct deploy for FullRangeUtils if it's a library. Foundry will link it automatically.
-
-## 5. Deploy the Final FullRange.sol Hook
-- Reference the addresses from the submodules (PoolManager, LiquidityManager, OracleManager) and pass them to FullRange:
-  ```
-  forge create --rpc-url http://127.0.0.1:8545 ./src/FullRange.sol:FullRange \
-    --constructor-args <AnvilDeployedPoolManagerAddress> \
-                      <DeployedFullRangePoolManagerAddress> \
-                      <DeployedFullRangeLiquidityManagerAddress> \
-                      <DeployedFullRangeOracleManagerAddress> \
-                      <GovernanceAddress> \
-    --private-key <YOUR_TEST_KEY>
-  ```
-- ExtendedBaseHook constructor is invoked, verifying that the deployed hook's permissions match your getHookPermissions() logic (via Hooks.validateHookPermissions).
-
-## 6. Register the FullRange Address as a Hook in the Real PoolManager
-- For any new pool you create, set the hooks field in the PoolKey to the deployed FullRange address.
-- Example if you do it manually:
-  ```
-  PoolKey memory key = PoolKey({
-    currency0: token0,
-    currency1: token1,
-    fee: 0x800000, // dynamic fee
-    tickSpacing: 60,
-    hooks: <FullRangeHookAddress>
-  });
-  // Then manager.initialize(key, initialSqrtPriceX96) or createPool(key, initialSqrtPriceX96)
-  ```
-
-## 7. Simulate Dynamic‑Fee Pool Creation
-- Impersonate or use the governance key you used above:
-  ```
-  anvil --block-time 1 --accounts 10 # note that one account is your gov
-  ```
-- Call initializeNewPool(...) on FullRange:
-  ```
-  fullRange.initializeNewPool(key, initialSqrtPriceX96);
-  ```
-- Confirm the call references FullRangePoolManager internally, and the real Uniswap PoolManager is invoked.
-- Verify if a non‑dynamic fee is used → revert with "NotDynamicFee".
-
-## 8. Simulate a Deposit
-- Approve tokens on the local anvil environment:
-  1. Deploy or mint an ERC20 token to your test account.
-  2. ERC20(token0).approve(address(FullRange), hugeAmount)
-  3. Same for token1.
-- Deposit:
-  ```
-  fullRange.deposit({
-    poolId: pid,
-    amount0Desired: ...,
-    amount1Desired: ...,
-    amount0Min: ...,
-    amount1Min: ...,
-    to: ...,
-    deadline: ...
-  });
-  ```
-- Confirm leftover tokens remain in your wallet if ratio is not fully used.
-- Observe the on-chain events from hooking logic (beforeAddLiquidity, afterAddLiquidity) if you track them in your local anvil logs.
-
-## 9. Simulate a Partial Withdrawal
-- If you minted shares for deposit, you can burn some for partial withdrawal:
-  ```
-  fullRange.withdraw({
-    poolId: pid,
-    sharesBurn: 500,
-    amount0Min: ...,
-    amount1Min: ...,
-    deadline: ...
-  });
-  ```
-- Confirm partial ratio logic, check hooking calls like beforeRemoveLiquidity, afterRemoveLiquidity.
-
-## 10. Hooks Callback Verification
-- Perform a swap via the real PoolManager referencing this FullRange address as hooks.
-- Anvil logs or Foundry traces will show calls to beforeSwap / afterSwap.
-- If you have a custom logic in _beforeSwap, you can check the returned BeforeSwapDelta.
-
-## 11. Invoke Oracle Updates
-- Call:
-  ```
-  fullRange.updateOracle(key);
-  ```
-- Confirm anvil logs the calls to FullRangeOracleManager.updateOracleWithThrottle, and if block/tick thresholds are not met, no external oracle call is made.
-
-## 12. Claim & Reinvest Fees
-- Generate some volume or simulate fees.
-- Call:
-  ```
-  fullRange.claimAndReinvestFees();
-  ```
-- Confirm FullRangeLiquidityManager logic is invoked.
-- Observe minted or re-staked liquidity if that's how you coded your submodules.
-
-## 13. Coverage Check
-- In a separate environment, run Foundry coverage:
-  ```
-  forge coverage
-  ```
-- This ensures you see 90%+ coverage. Verify the final FullRange.sol lines/branches are tested. You may want to add or tweak tests in your Foundry test folder if coverage is below 90.
-
-## 14. Optional Final Trials
-- Try large token amounts and partial leftover to ensure no overflow.
-- Try forced or custom hooking to see how your _beforeSwap or _beforeInitialize logic might respond to unusual data.
-
-## 15. Prepare for Audit
-- Provide this anvil simulation script & instructions, along with your final code, to the auditors.
-- Summarize design decisions (dynamic fee, leftover tokens, hooking approach, fallback logic, block/tick threshold, etc.) for clear audit scoping.
-```
-
-## Next Steps
-
-We request that Taylor proceed with the Anvil-based integration testing as specified in the plan above. This will ensure that our implementation works correctly with a real Uniswap V4 PoolManager in a close-to-production environment.
-
-The integration testing will validate:
-1. Hook address validation and permissions
-2. Dynamic fee pool creation
-3. Deposit and withdrawal functionality
-4. Oracle throttling logic
-5. Hook callback behavior
-
-Once the integration testing is complete, we'll be ready for a formal audit of the codebase. 
\ No newline at end of file
diff --git a/lib/v4-core b/lib/v4-core
--- a/lib/v4-core
+++ b/lib/v4-core
@@ -1 +1 @@
-Subproject commit 80311e34080fee64b6fc6c916e9a51a437d0e482
+Subproject commit 80311e34080fee64b6fc6c916e9a51a437d0e482-dirty
diff --git a/pr_comment.md b/pr_comment.md
deleted file mode 100644
index 53cd9f2..0000000
--- a/pr_comment.md
+++ /dev/null
@@ -1,33 +0,0 @@
-# Dynamic Fee Management Integration & Bug Fix
-
-I've made the following improvements to the codebase:
-
-## 1. Fixed Name Collision
-- Renamed the `DynamicFeeCheck` library in `FullRange.sol` to `DynamicFeeCheckInternal` to resolve a name collision with other code
-- Updated all references to this library to use the new name
-- This fixed compilation errors in tests related to duplicate declarations
-
-## 2. Integrated Dynamic Fee Management
-- Successfully integrated the `FullRangeDynamicFeeManager` component, which:
-  - Tracks the frequency of "cap events" (extreme volatility) in the truncated oracle
-  - Automatically adjusts fees based on volatility (higher during volatile periods, lower during stable periods)
-  - Implements surge pricing during high volatility to protect liquidity providers
-  - Provides governance controls for fee bounds and overrides
-
-## 3. Added Comprehensive Tests
-- All tests for `FullRangeDynamicFeeManager` now pass successfully, including:
-  - Initial state and ownership verification
-  - Access control and authorization checks
-  - Fee bounds enforcement
-  - Dynamic fee adjustment algorithm during volatile and stable periods
-  - Surge pricing functionality
-  - Fee override capabilities for governance
-  - Mathematical correctness of the exponential decay mechanism
-
-## 4. Integration with Main Contract
-- Added proper construction and initialization in `FullRange.sol`
-- Implemented dynamic fee updates before deposits and withdrawals
-- Added cap event detection after swaps
-- All 87 tests across 12 test suites are now passing
-
-These changes complete the implementation of the dynamic fee mechanism as specified in the requirements, providing automatic protection for LPs during volatile market conditions.
diff --git a/src/FeeReinvestmentManager.sol b/src/FeeReinvestmentManager.sol
index 9733e63..0af0ac0 100644
--- a/src/FeeReinvestmentManager.sol
+++ b/src/FeeReinvestmentManager.sol
@@ -8,7 +8,7 @@ import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
 import {FullRangeLiquidityManager} from "./FullRangeLiquidityManager.sol";
 import {IFullRangeLiquidityManager} from "./interfaces/IFullRangeLiquidityManager.sol";
 import {TickMath} from "v4-core/src/libraries/TickMath.sol";
-import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
+import {BalanceDelta, BalanceDeltaLibrary, toBalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
 import {MathUtils} from "./libraries/MathUtils.sol";
 import {Errors} from "./errors/Errors.sol";
 import {Currency} from "v4-core/src/types/Currency.sol";
@@ -18,13 +18,14 @@ import {IPoolPolicy} from "./interfaces/IPoolPolicy.sol";
 import {ReentrancyGuard} from "solmate/src/utils/ReentrancyGuard.sol";
 import {IHooks} from "v4-core/src/interfaces/IHooks.sol";
 import {IFullRange} from "./interfaces/IFullRange.sol";
+import {IUnlockCallback} from "v4-core/src/interfaces/callback/IUnlockCallback.sol";
 
 /**
  * @title FeeReinvestmentManager
- * @notice Optimized implementation for managing fee claiming, reinvestment, and protocol-owned liquidity (POL)
- * @dev Hybrid approach combining efficiency optimizations with flexibility preservation
+ * @notice Streamlined implementation for managing fee extraction and protocol-owned liquidity (POL)
+ * @dev Optimized approach focusing on POL fee extraction and reinvestment
  */
-contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
+contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard, IUnlockCallback {
     using PoolIdLibrary for PoolKey;
     
     // ================ IMMUTABLE STATE ================
@@ -37,42 +38,34 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
     
     // ================ CONFIGURATION ================
     
-    /// @notice Operation modes for fee reinvestment
-    enum ReinvestmentMode { ALWAYS, THRESHOLD_CHECK, NEVER }
-    
-    /// @notice Default reinvestment mode
-    ReinvestmentMode public defaultReinvestmentMode = ReinvestmentMode.ALWAYS;
-    
     /// @notice Governance address for POL withdrawals
     address public governanceTreasury;
     
-    /// @notice Fee reinvestment threshold (in basis points, default 10 = 0.1%)
-    uint256 public feeReinvestmentThresholdBps = 10;
-    
     /// @notice Minimum time between fee collections
-    uint256 public minimumFeeCollectionInterval = 1 hours;
+    uint256 public minimumCollectionInterval = 6 hours;
     
-    /// @notice Minimum time between reinvestments
-    uint256 public minimumReinvestmentInterval = 4 hours;
+    /// @notice Maximum time between fee collections
+    uint256 public maximumCollectionInterval = 7 days;
     
     /// @notice Global reinvestment pause switch
     bool public reinvestmentPaused;
     
-    /// @notice Fee distribution settings (in PPM, must sum to 1,000,000)
-    uint256 public polSharePpm = 100000;      // 10% default
-    uint256 public fullRangeSharePpm = 100000; // 10% default
-    uint256 public lpSharePpm = 800000;       // 80% default
-    
     // ================ POOL STATE ================
     
     /// @notice Consolidated pool fee state structure
     struct PoolFeeState {
-        uint256 pendingFee0;                 // Pending token0 fees
-        uint256 pendingFee1;                 // Pending token1 fees
-        uint256 cumulativeFeeMultiplier;     // Current fee multiplier (0 = default)
         uint256 lastFeeCollectionTimestamp;  // Last time fees were collected
         uint256 lastSuccessfulReinvestment;  // Last time reinvestment succeeded
         bool reinvestmentPaused;             // Pool-specific pause flag
+        uint256 leftoverToken0;              // Leftover token0 from previous reinvestment
+        uint256 leftoverToken1;              // Leftover token1 from previous reinvestment
+    }
+    
+    /// @notice Callback data for extraction operations
+    struct CallbackData {
+        PoolId poolId;
+        address token0;
+        address token1;
     }
     
     // ================ STORAGE ================
@@ -80,12 +73,6 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
     /// @notice Consolidated fee state for each pool
     mapping(PoolId => PoolFeeState) public poolFeeStates;
     
-    /// @notice Pending LP fees for token0
-    mapping(PoolId => uint256) public lpFeesPending0;
-    
-    /// @notice Pending LP fees for token1
-    mapping(PoolId => uint256) public lpFeesPending1;
-    
     /// @notice Reference to the liquidity manager
     IFullRangeLiquidityManager public liquidityManager;
     
@@ -94,8 +81,8 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
     
     // ================ CONSTANTS ================
     
-    /// @notice Default multiplier value
-    uint256 private constant DEFAULT_MULTIPLIER = 1e18;
+    /// @notice Default POL share
+    uint256 private constant DEFAULT_POL_SHARE_PPM = 100000; // 10%
     
     /// @notice PPM denominator (100%)
     uint256 private constant PPM_DENOMINATOR = 1000000;
@@ -108,33 +95,27 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
     /// @notice Emitted when a configuration value is updated
     event ConfigUpdated(string indexed configName, bytes value);
     
-    /// @notice Emitted when fee distribution settings are updated
-    event FeeDistributionUpdated(uint256 polShare, uint256 fullRangeShare, uint256 lpShare);
-    
-    /// @notice Emitted when the fee multiplier is updated
-    event FeeMultiplierUpdated(PoolId indexed poolId, uint256 oldMultiplier, uint256 newMultiplier);
-    
     /// @notice Emitted when reinvestment is paused or resumed
     event ReinvestmentStatusChanged(bool globalPaused);
     
     /// @notice Emitted when pool-specific reinvestment is paused or resumed
     event PoolReinvestmentStatusChanged(PoolId indexed poolId, bool paused);
     
-    /// @notice Emitted when reinvestment mode is changed
-    event ReinvestmentModeChanged(ReinvestmentMode mode);
-    
-    /// @notice Emitted when reinvestment thresholds are updated
-    event ReinvestmentThresholdUpdated(uint256 thresholdBps);
-    
-    /// @notice Emitted when LP fees are accumulated
-    event LPFeesAccumulated(PoolId indexed poolId, uint256 amount0, uint256 amount1);
-    
     /// @notice Emitted when POL is accumulated
     event POLAccrued(PoolId indexed poolId, uint256 amount0, uint256 amount1);
     
     /// @notice Emitted when reinvestment fails
     event ReinvestmentFailed(PoolId indexed poolId, string reason);
     
+    /// @notice Emitted when reinvestment succeeds
+    event POLFeesProcessed(PoolId indexed poolId, uint256 pol0, uint256 pol1, bool reinvested);
+    
+    /// @notice Emitted when collection interval is updated
+    event CollectionIntervalUpdated(uint256 newIntervalSeconds);
+    
+    /// @notice Emitted when leftover tokens are included in reinvestment
+    event LeftoverTokensProcessed(PoolId indexed poolId, uint256 leftover0, uint256 leftover1);
+    
     // ================ MODIFIERS ================
     
     /**
@@ -153,6 +134,14 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
         _;
     }
     
+    /**
+     * @notice Ensures the pool manager can call a function
+     */
+    modifier onlyPoolManager() {
+        if (msg.sender != address(poolManager)) revert Errors.AccessOnlyPoolManager(msg.sender);
+        _;
+    }
+    
     // ================ CONSTRUCTOR ================
     
     /**
@@ -221,396 +210,335 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
     }
     
     /**
-     * @notice Sets the fee reinvestment threshold
-     * @param newThresholdBps New threshold value (10 = 0.1%)
+     * @notice Sets the collection interval for permissionless fee collection
+     * @param newIntervalSeconds The new interval in seconds
      */
-    function setFeeReinvestmentThreshold(uint256 newThresholdBps) external onlyGovernance {
-        if (newThresholdBps > 1000) revert Errors.ParameterOutOfRange(newThresholdBps, 0, 1000);
-        feeReinvestmentThresholdBps = newThresholdBps;
-        emit ReinvestmentThresholdUpdated(newThresholdBps);
+    function setCollectionInterval(uint256 newIntervalSeconds) external onlyGovernance {
+        if (newIntervalSeconds < 1 hours) {
+            revert Errors.CollectionIntervalTooShort(newIntervalSeconds, 1 hours);
+        }
+        if (newIntervalSeconds > 7 days) {
+            revert Errors.CollectionIntervalTooLong(newIntervalSeconds, 7 days);
+        }
+        
+        minimumCollectionInterval = newIntervalSeconds;
+        emit CollectionIntervalUpdated(newIntervalSeconds);
     }
     
-    /**
-     * @notice Sets the default reinvestment mode
-     * @param mode The new reinvestment mode
-     */
-    function setDefaultReinvestmentMode(ReinvestmentMode mode) external onlyGovernance {
-        defaultReinvestmentMode = mode;
-        emit ReinvestmentModeChanged(mode);
-    }
+    // ================ CORE FUNCTIONS ================
     
     /**
-     * @notice Sets fee distribution percentages
-     * @param _polSharePpm Protocol-owned liquidity share in PPM
-     * @param _fullRangeSharePpm Full range share in PPM
-     * @param _lpSharePpm LP share in PPM
+     * @notice Calculates the fee delta to extract for protocol purposes
+     * @param poolId The pool ID
+     * @param feesAccrued The total fees accrued
+     * @return extractDelta The balance delta representing the portion to extract
      */
-    function setFeeDistribution(
-        uint256 _polSharePpm,
-        uint256 _fullRangeSharePpm,
-        uint256 _lpSharePpm
-    ) external onlyGovernance {
-        if (_polSharePpm + _fullRangeSharePpm + _lpSharePpm != PPM_DENOMINATOR) {
-            revert Errors.AllocationSumError(_polSharePpm, _fullRangeSharePpm, _lpSharePpm, PPM_DENOMINATOR);
+    function calculateExtractDelta(
+        PoolId poolId,
+        BalanceDelta feesAccrued
+    ) external view override returns (BalanceDelta extractDelta) {
+        // Skip if no fees to extract or system paused
+        if (reinvestmentPaused || poolFeeStates[poolId].reinvestmentPaused ||
+            (feesAccrued.amount0() <= 0 && feesAccrued.amount1() <= 0)) {
+            return BalanceDeltaLibrary.ZERO_DELTA;
         }
         
-        polSharePpm = _polSharePpm;
-        fullRangeSharePpm = _fullRangeSharePpm;
-        lpSharePpm = _lpSharePpm;
+        // Get POL share for this pool (either pool-specific or global)
+        uint256 polSharePpm = getPolSharePpm(poolId);
+        
+        // Calculate portions to extract for POL
+        int256 fee0 = feesAccrued.amount0() > 0 ? int256(feesAccrued.amount0()) : int256(0);
+        int256 fee1 = feesAccrued.amount1() > 0 ? int256(feesAccrued.amount1()) : int256(0);
         
-        emit FeeDistributionUpdated(_polSharePpm, _fullRangeSharePpm, _lpSharePpm);
+        // Use unchecked for gas optimization as these calculations cannot overflow
+        unchecked {
+            int256 extract0 = (fee0 * int256(polSharePpm)) / int256(PPM_DENOMINATOR);
+            int256 extract1 = (fee1 * int256(polSharePpm)) / int256(PPM_DENOMINATOR);
+            
+            return toBalanceDelta(int128(extract0), int128(extract1));
+        }
     }
     
     /**
-     * @notice Sets minimum time between fee collections
-     * @param newInterval New interval in seconds
+     * @notice Internal function to check if reinvestment should be performed
+     * @param poolId The pool ID
+     * @return shouldPerformReinvestment Whether reinvestment should be performed
      */
-    function setMinimumFeeCollectionInterval(uint256 newInterval) external onlyGovernance {
-        if (newInterval < 300 || newInterval > 1 days) {
-            revert Errors.ParameterOutOfRange(newInterval, 300, 1 days);
+    function _shouldReinvest(PoolId poolId) internal view returns (bool shouldPerformReinvestment) {
+        // Skip if reinvestment is paused
+        if (reinvestmentPaused || poolFeeStates[poolId].reinvestmentPaused) {
+            return false;
         }
-        minimumFeeCollectionInterval = newInterval;
-        emit ConfigUpdated("minimumFeeCollectionInterval", abi.encode(newInterval));
+        
+        // Check if enough time has passed since last collection
+        PoolFeeState storage feeState = poolFeeStates[poolId];
+        if (block.timestamp < feeState.lastFeeCollectionTimestamp + minimumCollectionInterval) {
+            return false;
+        }
+        
+        // Default to true if all checks pass
+        return true;
     }
-    
+
     /**
-     * @notice Sets minimum time between reinvestments
-     * @param newInterval New interval in seconds
+     * @notice Internal function to collect and process accumulated fees
+     * @param poolId The pool ID to collect fees for
+     * @return extracted Whether fees were successfully extracted and processed
      */
-    function setMinimumReinvestmentInterval(uint256 newInterval) external onlyGovernance {
-        if (newInterval < 600 || newInterval > 1 days) {
-            revert Errors.ParameterOutOfRange(newInterval, 600, 1 days);
+    function _collectAccumulatedFees(PoolId poolId) internal returns (bool extracted) {
+        PoolFeeState storage feeState = poolFeeStates[poolId];
+        
+        // Check if system is paused
+        if (reinvestmentPaused || feeState.reinvestmentPaused) {
+            revert Errors.PoolReinvestmentBlocked(poolId);
+        }
+        
+        // Get pool key
+        PoolKey memory key = _getPoolKey(poolId);
+        if (key.tickSpacing == 0) {
+            revert Errors.PoolNotInitialized(poolId);
+        }
+        
+        // Prepare callback data
+        bytes memory data = abi.encode(
+            CallbackData({
+                poolId: poolId,
+                token0: Currency.unwrap(key.currency0),
+                token1: Currency.unwrap(key.currency1)
+            })
+        );
+
+        // Call unlock to extract fees
+        bytes memory result = poolManager.unlock(data);
+        
+        // Decode the result
+        (bool success, uint256 extracted0, uint256 extracted1) = abi.decode(result, (bool, uint256, uint256));
+        
+        if (!success || (extracted0 == 0 && extracted1 == 0)) {
+            return false;
         }
-        minimumReinvestmentInterval = newInterval;
-        emit ConfigUpdated("minimumReinvestmentInterval", abi.encode(newInterval));
+
+        // Update last fee collection timestamp
+        feeState.lastFeeCollectionTimestamp = block.timestamp;
+
+        // Get leftover tokens from previous attempts
+        uint256 leftover0 = feeState.leftoverToken0;
+        uint256 leftover1 = feeState.leftoverToken1;
+
+        // Calculate total tokens available for reinvestment
+        uint256 total0 = extracted0 + leftover0;
+        uint256 total1 = extracted1 + leftover1;
+
+        // Emit fee extraction event
+        emit FeesExtracted(poolId, extracted0, extracted1, msg.sender);
+
+        // Process POL portion (10%)
+        (uint256 pol0, uint256 pol1) = _processPOLPortion(poolId, total0, total1);
+        
+        // Emit POL fees processed event
+        emit POLFeesProcessed(poolId, pol0, pol1, true);
+
+        return true;
     }
-    
-    // ================ CORE FUNCTIONS ================
-    
+
     /**
-     * @notice Processes reinvestment if needed based on current reinvestment mode
+     * @notice Internal implementation of fee reinvestment logic
      * @param poolId The pool ID
-     * @param value Value to use for threshold calculation (e.g., swap amount)
      * @return reinvested Whether fees were successfully reinvested
      * @return autoCompounded Whether auto-compounding was performed
      */
-    function processReinvestmentIfNeeded(
-        PoolId poolId,
-        uint256 value
-    ) external override returns (bool reinvested, bool autoCompounded) {
-        return _processReinvestment(poolId, OperationType.SWAP, value);
+    function _processReinvestmentIfNeeded(
+        PoolId poolId
+    ) internal returns (bool reinvested, bool autoCompounded) {
+        // Check if enough time has passed since last collection
+        PoolFeeState storage feeState = poolFeeStates[poolId];
+        uint256 collectionThreshold = minimumCollectionInterval;
+        if (block.timestamp < feeState.lastFeeCollectionTimestamp + collectionThreshold) {
+            revert Errors.ValidationDeadlinePassed(
+                uint32(feeState.lastFeeCollectionTimestamp + collectionThreshold), 
+                uint32(block.timestamp)
+            );
+        }
+
+        // Check if we should reinvest
+        if (!_shouldReinvest(poolId)) {
+            return (false, false);
+        }
+        
+        // Try to collect fees
+        bool success = _collectAccumulatedFees(poolId);
+        if (!success) {
+            return (false, false);
+        }
+        return (true, false);
     }
-    
+
     /**
-     * @notice Processes reinvestment if needed based on operation type
+     * @notice Checks if reinvestment should be performed based on the current mode and conditions
+     * @param poolId The pool ID
+     * @param swapValue Used for threshold calculations
+     * @return shouldPerformReinvestment Whether reinvestment should be performed
+     */
+    function shouldReinvest(PoolId poolId, uint256 swapValue) external view returns (bool shouldPerformReinvestment) {
+        return _shouldReinvest(poolId);
+    }
+
+    /**
+     * @notice Permissionless function to collect and process accumulated fees
+     * @param poolId The pool ID to collect fees for
+     * @return extracted Whether fees were successfully extracted and processed
+     */
+    function collectAccumulatedFees(PoolId poolId) external nonReentrant returns (bool extracted) {
+        // Check if enough time has passed since last collection
+        PoolFeeState storage feeState = poolFeeStates[poolId];
+        uint256 collectionThreshold = minimumCollectionInterval;
+        if (block.timestamp < feeState.lastFeeCollectionTimestamp + collectionThreshold) {
+            revert Errors.ValidationDeadlinePassed(
+                uint32(feeState.lastFeeCollectionTimestamp + collectionThreshold), 
+                uint32(block.timestamp)
+            );
+        }
+
+        return _collectAccumulatedFees(poolId);
+    }
+
+    /**
+     * @notice Processes reinvestment if needed based on value threshold
      * @param poolId The pool ID
-     * @param opType The operation type
+     * @param value Used for threshold calculations
      * @return reinvested Whether fees were successfully reinvested
      * @return autoCompounded Whether auto-compounding was performed
      */
     function processReinvestmentIfNeeded(
         PoolId poolId,
-        OperationType opType
-    ) external override returns (bool reinvested, bool autoCompounded) {
-        // Use a default value based on operation type
-        uint256 defaultValue = opType == OperationType.DEPOSIT ? 1000000 : 500000;
-        return _processReinvestment(poolId, opType, defaultValue);
+        uint256 value
+    ) external nonReentrant returns (bool reinvested, bool autoCompounded) {
+        return _processReinvestmentIfNeeded(poolId);
     }
-    
+
     /**
-     * @notice Internal implementation of processReinvestmentIfNeeded
+     * @notice Processes reinvestment if needed based on operation type
      * @param poolId The pool ID
-     * @param opType The operation type
-     * @param value Value for threshold calculation
+     * @param opType The operation type (SWAP, DEPOSIT, WITHDRAWAL)
      * @return reinvested Whether fees were successfully reinvested
      * @return autoCompounded Whether auto-compounding was performed
      */
-    function _processReinvestment(
+    function processReinvestmentIfNeeded(
         PoolId poolId,
-        OperationType opType,
-        uint256 value
-    ) internal nonReentrant returns (bool reinvested, bool autoCompounded) {
-        // Circuit breaker check
-        PoolFeeState storage feeState = poolFeeStates[poolId];
-        if (reinvestmentPaused || feeState.reinvestmentPaused) {
-            return (false, false);
-        }
-        
-        // Check if reinvestment should be performed
-        if (!_shouldReinvest(poolId, opType, value)) {
-            return (false, false);
-        }
-        
-        // For deposits, apply auto-compounding
-        if (opType == OperationType.DEPOSIT) {
-            autoCompounded = _autoCompoundFees(poolId);
-        }
-        
-        // Execute reinvestment for POL portion
-        reinvested = _executeReinvestment(poolId);
-        
-        return (reinvested, autoCompounded);
+        OperationType opType
+    ) external nonReentrant returns (bool reinvested, bool autoCompounded) {
+        return _processReinvestmentIfNeeded(poolId);
     }
-    
+
     /**
      * @notice Reinvests accumulated fees for a specific pool
      * @param poolId The pool ID to reinvest fees for
      * @return amount0 The amount of token0 fees reinvested
      * @return amount1 The amount of token1 fees reinvested
      */
-    function reinvestFees(PoolId poolId) external override returns (uint256 amount0, uint256 amount1) {
+    function reinvestFees(PoolId poolId) external returns (uint256 amount0, uint256 amount1) {
         // Skip if reinvestment is paused
-        PoolFeeState storage feeState = poolFeeStates[poolId];
-        if (reinvestmentPaused || feeState.reinvestmentPaused) {
-            return (0, 0);
-        }
-        
-        // Collect any pending fees
-        collectFees(poolId);
-        
-        // Get pending fees
-        amount0 = feeState.pendingFee0;
-        amount1 = feeState.pendingFee1;
-        
-        if (amount0 == 0 && amount1 == 0) {
-            return (0, 0);
-        }
-        
-        // Apply auto-compounding first
-        _autoCompoundFees(poolId);
-        
-        // Then execute POL reinvestment
-        bool success = _executeReinvestment(poolId);
-        
-        // Return the fee amounts
-        return success ? (amount0, amount1) : (0, 0);
-    }
-    
-    /**
-     * @notice Collects accrued fees from the pool
-     * @param poolId The pool ID to collect fees for
-     * @return fee0 Amount of token0 fees collected
-     * @return fee1 Amount of token1 fees collected
-     */
-    function collectFees(PoolId poolId) public returns (uint256 fee0, uint256 fee1) {
-        PoolFeeState storage feeState = poolFeeStates[poolId];
-        
-        // Check if enough time has passed since last collection
-        if (block.timestamp < feeState.lastFeeCollectionTimestamp + minimumFeeCollectionInterval) {
+        if (reinvestmentPaused || poolFeeStates[poolId].reinvestmentPaused) {
             return (0, 0);
         }
         
         // Get pool key
         PoolKey memory key = _getPoolKey(poolId);
         if (key.tickSpacing == 0) {
-            // Pool key not found, pool may not exist
-            return (0, 0);
-        }
-        
-        // Track token balances before take to determine collected fees
-        uint256 token0BalanceBefore = 0;
-        uint256 token1BalanceBefore = 0;
-        address token0 = Currency.unwrap(key.currency0);
-        address token1 = Currency.unwrap(key.currency1);
-        
-        if (token0 != address(0)) {
-            token0BalanceBefore = ERC20(token0).balanceOf(address(this));
-        }
-        if (token1 != address(0)) {
-            token1BalanceBefore = ERC20(token1).balanceOf(address(this));
-        }
-        
-        // Execute take for token0 fees
-        bool takeSuccess = false;
-        try poolManager.take(key.currency0, address(this), 0) {
-            takeSuccess = true;
-        } catch {
-            // Take failed, fallback to try token1 only
+            revert Errors.PoolNotInitialized(poolId);
         }
         
-        // Execute take for token1 fees if token0 succeeded
-        if (takeSuccess) {
-            try poolManager.take(key.currency1, address(this), 0) {
-                // Both takes succeeded
-            } catch {
-                // Token1 take failed, but we continue
-            }
-        }
-        
-        // Calculate the delta in balances to determine collected fees
-        uint256 token0BalanceAfter = token0 != address(0) ? ERC20(token0).balanceOf(address(this)) : 0;
-        uint256 token1BalanceAfter = token1 != address(0) ? ERC20(token1).balanceOf(address(this)) : 0;
-        
-        fee0 = token0BalanceAfter > token0BalanceBefore ? token0BalanceAfter - token0BalanceBefore : 0;
-        fee1 = token1BalanceAfter > token1BalanceBefore ? token1BalanceAfter - token1BalanceBefore : 0;
-        
-        if (fee0 > 0 || fee1 > 0) {
-            // Update pending fees
-            feeState.pendingFee0 += fee0;
-            feeState.pendingFee1 += fee1;
-            feeState.lastFeeCollectionTimestamp = block.timestamp;
-            
-            emit FeesAccumulated(poolId, fee0, fee1);
+        // Try to collect fees first
+        bool success = _collectAccumulatedFees(poolId);
+        if (!success) {
+            return (0, 0);
         }
         
-        return (fee0, fee1);
-    }
-    
-    /**
-     * @notice Determines if reinvestment should be performed
-     * @param poolId The pool ID
-     * @param opType The operation type
-     * @param value Value for threshold calculation
-     * @return shouldPerform Whether reinvestment should be performed
-     */
-    function _shouldReinvest(
-        PoolId poolId,
-        OperationType opType,
-        uint256 value
-    ) internal view returns (bool shouldPerform) {
+        // Get current leftover amounts
         PoolFeeState storage feeState = poolFeeStates[poolId];
+        amount0 = feeState.leftoverToken0;
+        amount1 = feeState.leftoverToken1;
         
-        // Quick return paths based on reinvestment mode
-        if (defaultReinvestmentMode == ReinvestmentMode.NEVER) {
-            return false;
-        }
-        
-        // For deposits, always consider reinvestment
-        if (opType == OperationType.DEPOSIT) {
-            return block.timestamp >= feeState.lastSuccessfulReinvestment + minimumReinvestmentInterval;
-        }
-        
-        if (defaultReinvestmentMode == ReinvestmentMode.ALWAYS) {
-            return block.timestamp >= feeState.lastSuccessfulReinvestment + minimumReinvestmentInterval;
-        }
-        
-        // THRESHOLD_CHECK mode - implement proportional threshold check
-        uint256 pendingTotal = feeState.pendingFee0 + feeState.pendingFee1;
-        if (pendingTotal == 0) return false;
-        
-        // Get reserves for proportional threshold
-        (uint256 reserve0, uint256 reserve1) = _getReserves(poolId);
-        uint256 reserveTotal = reserve0 + reserve1;
+        // Reset leftover amounts since we're reinvesting them
+        feeState.leftoverToken0 = 0;
+        feeState.leftoverToken1 = 0;
         
-        // If no reserves, use absolute threshold
-        if (reserveTotal == 0) {
-            return pendingTotal >= 1000;
-        }
-        
-        // Calculate threshold as percentage of reserves
-        uint256 thresholdValue = (reserveTotal * feeReinvestmentThresholdBps) / 10000;
-        
-        // Use minimum threshold for small pools
-        if (thresholdValue < 1000) thresholdValue = 1000;
-        
-        return pendingTotal >= thresholdValue;
+        return (amount0, amount1);
     }
     
     /**
-     * @notice Auto-compounds fees by increasing the fee multiplier
-     * @param poolId The pool ID
-     * @return compounded Whether auto-compounding was performed
+     * @notice Unlock callback for fee extraction
+     * @param data The encoded callback data
+     * @return The result of the operation
      */
-    function _autoCompoundFees(PoolId poolId) internal returns (bool compounded) {
-        PoolFeeState storage feeState = poolFeeStates[poolId];
-        
-        // Get pending fees
-        uint256 fee0 = feeState.pendingFee0;
-        uint256 fee1 = feeState.pendingFee1;
-        
-        if (fee0 == 0 && fee1 == 0) {
-            return false;
+    function unlockCallback(bytes calldata data) external onlyPoolManager returns (bytes memory) {
+        // Decode callback data
+        CallbackData memory cb = abi.decode(data, (CallbackData));
+        
+        // Get pool ID and tokens
+        PoolId poolId = cb.poolId;
+        address token0 = cb.token0;
+        address token1 = cb.token1;
+        
+        // Try to extract fees using take(0) technique
+        uint256 token0Before = token0 != address(0) ? ERC20(token0).balanceOf(address(this)) : 0;
+        uint256 token1Before = token1 != address(0) ? ERC20(token1).balanceOf(address(this)) : 0;
+        
+        // Execute zero-take to collect fees
+        try poolManager.take(Currency.wrap(token0), address(this), 0) {
+            // First take succeeded
+        } catch {
+            // Take failed, return failure
+            return abi.encode(false, 0, 0);
         }
         
-        // Calculate fee distribution
-        uint256 fr0 = (fee0 * fullRangeSharePpm) / PPM_DENOMINATOR;
-        uint256 fr1 = (fee1 * fullRangeSharePpm) / PPM_DENOMINATOR;
-        uint256 pol0 = (fee0 * polSharePpm) / PPM_DENOMINATOR;
-        uint256 pol1 = (fee1 * polSharePpm) / PPM_DENOMINATOR;
-        uint256 lp0 = fee0 - fr0 - pol0;
-        uint256 lp1 = fee1 - fr1 - pol1;
-        
-        // Handle full range portion through multiplier
-        bool frCompounded = false;
-        if (fr0 > 0 || fr1 > 0) {
-            // Get pool reserves
-            (uint256 reserve0, uint256 reserve1) = _getReserves(poolId);
-            
-            // Skip if no reserves 
-            if (reserve0 > 0 && reserve1 > 0) {
-                // Calculate the multiplier increase
-                uint256 oldMultiplier = _getEffectiveMultiplier(feeState.cumulativeFeeMultiplier);
-                
-                // Calculate geometric means for fees and reserves
-                uint256 feeValue = MathUtils.calculateGeometricShares(fr0, fr1);
-                uint256 reserveValue = MathUtils.calculateGeometricShares(reserve0, reserve1);
-                
-                if (reserveValue > 0) {
-                    // Calculate increase factor proportional to reserve value
-                    uint256 increaseFactor = (feeValue * DEFAULT_MULTIPLIER) / reserveValue;
-                    
-                    // Update the multiplier if there's an increase
-                    if (increaseFactor > 0) {
-                        uint256 newMultiplier = oldMultiplier + increaseFactor;
-                        feeState.cumulativeFeeMultiplier = newMultiplier;
-                        
-                        emit FeeMultiplierUpdated(poolId, oldMultiplier, newMultiplier);
-                        
-                        // Mark the fees as "invested" through the multiplier
-                        feeState.pendingFee0 -= fr0;
-                        feeState.pendingFee1 -= fr1;
-                        
-                        frCompounded = true;
-                    }
-                }
-            }
+        try poolManager.take(Currency.wrap(token1), address(this), 0) {
+            // Second take succeeded
+        } catch {
+            // Take failed but continue since we might have token0 fees
         }
         
-        // Set aside POL fees for reinvestment
-        if (pol0 > 0 || pol1 > 0) {
-            // Keep in pending fees - they'll be used in executeReinvestment
-            emit POLAccrued(poolId, pol0, pol1);
-        }
+        // Calculate extracted amounts
+        uint256 token0After = token0 != address(0) ? ERC20(token0).balanceOf(address(this)) : 0;
+        uint256 token1After = token1 != address(0) ? ERC20(token1).balanceOf(address(this)) : 0;
         
-        // Handle LP fees
-        if (lp0 > 0 || lp1 > 0) {
-            // Add to LP pending fees for claiming
-            lpFeesPending0[poolId] += lp0;
-            lpFeesPending1[poolId] += lp1;
-            
-            // Remove from pending fees
-            feeState.pendingFee0 -= lp0;
-            feeState.pendingFee1 -= lp1;
-            
-            emit LPFeesAccumulated(poolId, lp0, lp1);
-        }
+        uint256 extracted0 = token0After > token0Before ? token0After - token0Before : 0;
+        uint256 extracted1 = token1After > token1Before ? token1After - token1Before : 0;
         
-        return frCompounded;
+        // Return success and extracted amounts
+        return abi.encode(true, extracted0, extracted1);
     }
     
     /**
-     * @notice Execute POL reinvestment
+     * @notice Process the POL portion of fees
      * @param poolId The pool ID
-     * @return success Whether reinvestment was successful
+     * @param pol0 Amount of token0 for POL
+     * @param pol1 Amount of token1 for POL
+     * @return amount0 The amount of token0 reinvested
+     * @return amount1 The amount of token1 reinvested
      */
-    function _executeReinvestment(PoolId poolId) internal returns (bool success) {
+    function _processPOLPortion(
+        PoolId poolId,
+        uint256 pol0,
+        uint256 pol1
+    ) internal returns (uint256 amount0, uint256 amount1) {
         PoolFeeState storage feeState = poolFeeStates[poolId];
         
-        // Calculate POL amounts (from pending fees)
-        uint256 fee0 = feeState.pendingFee0;
-        uint256 fee1 = feeState.pendingFee1;
+        // Get previous leftover amounts
+        uint256 leftover0 = feeState.leftoverToken0;
+        uint256 leftover1 = feeState.leftoverToken1;
         
-        if (fee0 == 0 && fee1 == 0) {
-            return false;
-        }
+        // Add any leftover amounts from previous reinvestment attempts
+        pol0 += leftover0;
+        pol1 += leftover1;
         
-        // Calculate POL amounts
-        uint256 pol0 = (fee0 * polSharePpm) / PPM_DENOMINATOR;
-        uint256 pol1 = (fee1 * polSharePpm) / PPM_DENOMINATOR;
+        // Emit event if we're processing leftovers
+        if (leftover0 > 0 || leftover1 > 0) {
+            emit LeftoverTokensProcessed(poolId, leftover0, leftover1);
+        }
         
-        // Skip if no POL amounts
         if (pol0 == 0 && pol1 == 0) {
-            return false;
+            return (0, 0);
         }
         
         // Get pool reserves for optimal ratios
@@ -627,25 +555,29 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
         
         // Skip if no reinvestable amounts
         if (optimal0 == 0 && optimal1 == 0) {
-            return false;
+            return (0, 0);
         }
         
         // Execute reinvestment
-        success = _executePolReinvestment(poolId, optimal0, optimal1);
+        bool success = _executePolReinvestment(poolId, optimal0, optimal1);
         
         if (success) {
-            // Update fee state
-            feeState.pendingFee0 = 0;
-            feeState.pendingFee1 = 0;
-            feeState.lastSuccessfulReinvestment = block.timestamp;
+            // Calculate and store the leftover amounts
+            feeState.leftoverToken0 = pol0 - optimal0;
+            feeState.leftoverToken1 = pol1 - optimal1;
             
-            // Emit event
-            emit FeesReinvested(poolId, fee0, fee1, optimal0, optimal1);
+            // Emit event for POL accrual
+            emit POLAccrued(poolId, optimal0, optimal1);
+            emit FeesReinvested(poolId, pol0, pol1, optimal0, optimal1);
+            return (optimal0, optimal1);
         } else {
+            // If reinvestment failed, store all amounts as leftovers
+            feeState.leftoverToken0 = pol0;
+            feeState.leftoverToken1 = pol1;
+            
             emit ReinvestmentFailed(poolId, "POL reinvestment execution failed");
+            return (0, 0);
         }
-        
-        return success;
     }
     
     /**
@@ -750,15 +682,6 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
         }
     }
     
-    /**
-     * @notice Get effective multiplier with default handling
-     * @param storedMultiplier The stored multiplier value
-     * @return effectiveMultiplier The effective multiplier to use
-     */
-    function _getEffectiveMultiplier(uint256 storedMultiplier) internal pure returns (uint256) {
-        return storedMultiplier == 0 ? DEFAULT_MULTIPLIER : storedMultiplier;
-    }
-    
     /**
      * @notice Safe token approval with redundant call elimination
      * @param token The token to approve
@@ -780,21 +703,19 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
     // ================ VIEW FUNCTIONS ================
     
     /**
-     * @notice Get the amount of pending fees for token0 for a pool
-     * @param poolId The pool ID
-     * @return The amount of pending token0 fees
-     */
-    function pendingFees0(PoolId poolId) external view override returns (uint256) {
-        return poolFeeStates[poolId].pendingFee0;
-    }
-    
-    /**
-     * @notice Get the amount of pending fees for token1 for a pool
-     * @param poolId The pool ID
-     * @return The amount of pending token1 fees
+     * @notice Get the POL share percentage for a specific pool
+     * @param poolId The pool ID to get the POL share for
+     * @return The POL share in PPM (parts per million)
      */
-    function pendingFees1(PoolId poolId) external view override returns (uint256) {
-        return poolFeeStates[poolId].pendingFee1;
+    function getPolSharePpm(PoolId poolId) public view override returns (uint256) {
+        // First check if pool-specific POL shares are enabled
+        if (address(policyManager) != address(0)) {
+            (uint256 polSharePpm, ,) = policyManager.getFeeAllocations(poolId);
+            return polSharePpm;
+        }
+        
+        // Default to 10% if no policy manager or no pool-specific value
+        return DEFAULT_POL_SHARE_PPM; 
     }
     
     /**
@@ -803,46 +724,38 @@ contract FeeReinvestmentManager is IFeeReinvestmentManager, ReentrancyGuard {
      * @return The cumulative fee multiplier
      */
     function cumulativeFeeMultiplier(PoolId poolId) external view override returns (uint256) {
-        return _getEffectiveMultiplier(poolFeeStates[poolId].cumulativeFeeMultiplier);
+        // Fixed at 1e18 in the new model
+        return 1e18;
     }
     
     /**
-     * @notice Returns true if fees should be reinvested based on current settings
+     * @notice Get the amount of pending fees for token0 for a pool
      * @param poolId The pool ID
-     * @param value Value for threshold calculation
-     * @return shouldReinvest Whether fees should be reinvested
+     * @return The amount of pending token0 fees
      */
-    function shouldReinvest(PoolId poolId, uint256 value) external view returns (bool) {
-        return _shouldReinvest(poolId, OperationType.SWAP, value);
+    function pendingFees0(PoolId poolId) external view override returns (uint256) {
+        // This always returns 0 in the new model since we don't track pending fees
+        return 0;
     }
     
     /**
-     * @notice Gets LP pending fees for a specific pool
+     * @notice Get the amount of pending fees for token1 for a pool
      * @param poolId The pool ID
-     * @return pending0 Pending token0 LP fees
-     * @return pending1 Pending token1 LP fees
+     * @return The amount of pending token1 fees
      */
-    function getLPPendingFees(PoolId poolId) external view returns (uint256 pending0, uint256 pending1) {
-        return (lpFeesPending0[poolId], lpFeesPending1[poolId]);
+    function pendingFees1(PoolId poolId) external view override returns (uint256) {
+        // This always returns 0 in the new model since we don't track pending fees
+        return 0;
     }
     
     /**
-     * @notice Gets all fee-related information for a pool
+     * @notice Get information about leftover tokens from previous reinvestments
      * @param poolId The pool ID
-     * @return state The pool fee state
-     * @return lpFees0 Pending LP token0 fees
-     * @return lpFees1 Pending LP token1 fees
-     * @return isPaused Whether reinvestment is paused for this pool
+     * @return leftover0 Leftover token0 amount
+     * @return leftover1 Leftover token1 amount
      */
-    function getPoolFeeInfo(PoolId poolId) external view returns (
-        PoolFeeState memory state,
-        uint256 lpFees0,
-        uint256 lpFees1,
-        bool isPaused
-    ) {
-        state = poolFeeStates[poolId];
-        lpFees0 = lpFeesPending0[poolId];
-        lpFees1 = lpFeesPending1[poolId];
-        isPaused = reinvestmentPaused || state.reinvestmentPaused;
+    function getLeftoverTokens(PoolId poolId) external view returns (uint256 leftover0, uint256 leftover1) {
+        PoolFeeState storage feeState = poolFeeStates[poolId];
+        return (feeState.leftoverToken0, feeState.leftoverToken1);
     }
 } 
\ No newline at end of file
diff --git a/src/FullRange.sol b/src/FullRange.sol
index 6462250..acd6bbd 100644
--- a/src/FullRange.sol
+++ b/src/FullRange.sol
@@ -23,13 +23,14 @@ import { IFeeReinvestmentManager } from "./interfaces/IFeeReinvestmentManager.so
 import { ReentrancyGuard } from "solmate/src/utils/ReentrancyGuard.sol";
 import { StateLibrary } from "v4-core/src/libraries/StateLibrary.sol";
 import { PoolTokenIdUtils } from "./utils/PoolTokenIdUtils.sol";
+import { IFullRangeHooks } from "./interfaces/IFullRangeHooks.sol";
 
 /**
  * @title FullRange
  * @notice Optimized Uniswap V4 Hook contract with minimized bytecode size
  * @dev Implements IFullRange and uses delegate calls to manager contracts for complex logic
  */
-contract FullRange is IFullRange, IUnlockCallback, ReentrancyGuard {
+contract FullRange is IFullRange, IFullRangeHooks, IUnlockCallback, ReentrancyGuard {
     using PoolIdLibrary for PoolKey;
     
     // =========================================================================
@@ -90,6 +91,8 @@ contract FullRange is IFullRange, IUnlockCallback, ReentrancyGuard {
     event PolicyInitializationFailed(PoolId indexed poolId, string reason);
     event Deposit(address indexed sender, PoolId indexed poolId, uint256 amount0, uint256 amount1, uint256 shares);
     event Withdraw(address indexed sender, PoolId indexed poolId, uint256 amount0, uint256 amount1, uint256 shares);
+    event FeeExtractionProcessed(PoolId indexed poolId, uint256 amount0, uint256 amount1);
+    event FeeExtractionFailed(PoolId indexed poolId, string reason);
     
     // Modifiers
     modifier onlyGovernance() {
@@ -158,7 +161,7 @@ contract FullRange is IFullRange, IUnlockCallback, ReentrancyGuard {
             beforeSwapReturnDelta: false,
             afterSwapReturnDelta: false,
             afterAddLiquidityReturnDelta: false,
-            afterRemoveLiquidityReturnDelta: false
+            afterRemoveLiquidityReturnDelta: true
         });
     }
 
@@ -714,4 +717,78 @@ contract FullRange is IFullRange, IUnlockCallback, ReentrancyGuard {
     {
         return IHooks.afterDonate.selector;
     }
+
+    /**
+     * @notice Implementation for afterRemoveLiquidityReturnDelta hook
+     */
+    function afterRemoveLiquidityReturnDelta(
+        address sender,
+        PoolKey calldata key,
+        IPoolManager.ModifyLiquidityParams calldata params,
+        BalanceDelta delta,
+        BalanceDelta feesAccrued,
+        bytes calldata hookData
+    ) external returns (bytes4, BalanceDelta) {
+        PoolId poolId = key.toId();
+        
+        // Delegate extraction calculation to FeeReinvestmentManager
+        address reinvestPolicy = policyManager.getPolicy(poolId, IPoolPolicy.PolicyType.REINVESTMENT);
+        
+        if (reinvestPolicy != address(0)) {
+            try IFeeReinvestmentManager(reinvestPolicy).calculateExtractDelta(
+                poolId, feesAccrued
+            ) returns (BalanceDelta extractDelta) {
+                // Only emit event if successful, no additional logic here
+                if (extractDelta.amount0() > 0 || extractDelta.amount1() > 0) {
+                    emit FeeExtractionProcessed(poolId, uint256(uint128(extractDelta.amount0())), uint256(uint128(extractDelta.amount1())));
+                }
+                return (IFullRangeHooks.afterRemoveLiquidityReturnDelta.selector, extractDelta);
+            } catch (bytes memory reason) {
+                // If calculation fails, extract nothing
+                emit FeeExtractionFailed(poolId, string(reason));
+                return (IFullRangeHooks.afterRemoveLiquidityReturnDelta.selector, BalanceDeltaLibrary.ZERO_DELTA);
+            }
+        }
+        
+        // If no policy, don't extract anything
+        return (IFullRangeHooks.afterRemoveLiquidityReturnDelta.selector, BalanceDeltaLibrary.ZERO_DELTA);
+    }
+
+    /**
+     * @notice Implementation for beforeSwapReturnDelta hook
+     */
+    function beforeSwapReturnDelta(
+        address sender,
+        PoolKey calldata key,
+        IPoolManager.SwapParams calldata params,
+        bytes calldata hookData
+    ) external returns (bytes4, BeforeSwapDelta) {
+        return (IFullRangeHooks.beforeSwapReturnDelta.selector, BeforeSwapDeltaLibrary.ZERO_DELTA);
+    }
+
+    /**
+     * @notice Implementation for afterSwapReturnDelta hook
+     */
+    function afterSwapReturnDelta(
+        address sender,
+        PoolKey calldata key,
+        IPoolManager.SwapParams calldata params,
+        BalanceDelta delta,
+        bytes calldata hookData
+    ) external returns (bytes4, BalanceDelta) {
+        return (IFullRangeHooks.afterSwapReturnDelta.selector, BalanceDeltaLibrary.ZERO_DELTA);
+    }
+
+    /**
+     * @notice Implementation for afterAddLiquidityReturnDelta hook
+     */
+    function afterAddLiquidityReturnDelta(
+        address sender,
+        PoolKey calldata key,
+        IPoolManager.ModifyLiquidityParams calldata params,
+        BalanceDelta delta,
+        bytes calldata hookData
+    ) external returns (bytes4, BalanceDelta) {
+        return (IFullRangeHooks.afterAddLiquidityReturnDelta.selector, BalanceDeltaLibrary.ZERO_DELTA);
+    }
 }
\ No newline at end of file
diff --git a/src/PoolPolicyManager.sol b/src/PoolPolicyManager.sol
index 8323b2a..1b16ac9 100644
--- a/src/PoolPolicyManager.sol
+++ b/src/PoolPolicyManager.sol
@@ -45,6 +45,12 @@ contract PoolPolicyManager is IPoolPolicy, Owned {
     // Mapping of policy implementations by pool and type
     mapping(PoolId => mapping(PolicyType => address)) private _policies;
     
+    // Add a new mapping for pool-specific POL share percentages
+    mapping(PoolId => uint256) public poolPolSharePpm;
+    
+    // Add a flag to enable/disable pool-specific POL percentages
+    bool public allowPoolSpecificPolShare;
+    
     // Events
     event FeeConfigChanged(
         uint256 polSharePpm,
@@ -59,6 +65,8 @@ contract PoolPolicyManager is IPoolPolicy, Owned {
     event TickSpacingSupportChanged(uint24 tickSpacing, bool isSupported);
     event PolicySet(PoolId indexed poolId, PolicyType indexed policyType, address implementation);
     event PoolInitialized(PoolId indexed poolId, address hook, int24 initialTick);
+    event PoolPOLShareChanged(PoolId indexed poolId, uint256 polSharePpm);
+    event PoolSpecificPOLSharingEnabled(bool enabled);
     
     /**
      * @notice Constructor initializes the policy manager with default values
@@ -176,6 +184,15 @@ contract PoolPolicyManager is IPoolPolicy, Owned {
      * @inheritdoc IPoolPolicy
      */
     function getFeeAllocations(PoolId poolId) external view returns (uint256, uint256, uint256) {
+        // Check if pool has a specific POL share
+        uint256 poolSpecificPolShare = poolPolSharePpm[poolId];
+        
+        // If pool-specific POL share is enabled and set for this pool, use it
+        if (allowPoolSpecificPolShare && poolSpecificPolShare > 0) {
+            return (poolSpecificPolShare, 0, 1000000 - poolSpecificPolShare);
+        }
+        
+        // Otherwise use the global settings
         return (polSharePpm, fullRangeSharePpm, lpSharePpm);
     }
     
@@ -269,6 +286,37 @@ contract PoolPolicyManager is IPoolPolicy, Owned {
         defaultDynamicFeePpm = feePpm;
     }
     
+    /**
+     * @notice Sets a pool-specific POL share percentage
+     * @param poolId The ID of the pool
+     * @param _polSharePpm The POL share in PPM (parts per million)
+     */
+    function setPoolPolShare(PoolId poolId, uint256 _polSharePpm) external onlyOwner {
+        // Verify pool-specific POL sharing is enabled
+        if (!allowPoolSpecificPolShare) {
+            revert Errors.PoolSpecificPolPercentageNotAllowed();
+        }
+        
+        // Validate the POL share is within reasonable bounds (1% to 20%)
+        if (_polSharePpm < 10000 || _polSharePpm > 200000) {
+            revert Errors.InvalidPolPercentage(_polSharePpm, 10000, 200000);
+        }
+        
+        // Set the pool-specific POL share
+        poolPolSharePpm[poolId] = _polSharePpm;
+        
+        emit PoolPOLShareChanged(poolId, _polSharePpm);
+    }
+    
+    /**
+     * @notice Enables or disables pool-specific POL share percentages
+     * @param _enabled Whether to enable pool-specific POL shares
+     */
+    function setAllowPoolSpecificPolShare(bool _enabled) external onlyOwner {
+        allowPoolSpecificPolShare = _enabled;
+        emit PoolSpecificPOLSharingEnabled(_enabled);
+    }
+    
     // === Tick Scaling Policy Functions ===
     
     /**
diff --git a/src/errors/Errors.sol b/src/errors/Errors.sol
index 4106bfc..0c41293 100644
--- a/src/errors/Errors.sol
+++ b/src/errors/Errors.sol
@@ -18,7 +18,7 @@ library Errors {
     error Unauthorized();
     
     // Validation and input errors
-    error ValidationDeadlinePassed(uint32 deadline, uint32 timestamp);
+    error ValidationDeadlinePassed(uint32 deadline, uint32 blockTime);
     error ValidationZeroAddress(string target);
     error ValidationInvalidInput(string reason);
     error ValidationZeroAmount(string parameter);
@@ -32,6 +32,8 @@ library Errors {
     error ArrayLengthMismatch();
     error InvalidCallbackSalt();
     error InvalidPolicyImplementationsLength(uint256 length);
+    error NotInitialized();
+    error ReinvestmentDisabled();
     
     // Math errors
     error DivisionByZero();
@@ -57,6 +59,9 @@ library Errors {
     error ZeroPolicyManagerAddress();
     error ZeroPoolManagerAddress();
     error ZeroFullRangeAddress();
+    error HookHandlerCallFailed(bytes reason);
+    error HookDispatchFailed(bytes4 selector);
+    error DelegateCallFailed();
     
     // Pool errors
     error PoolNotInitialized(PoolId poolId);
@@ -71,6 +76,8 @@ library Errors {
     error PoolUnsupportedTickSpacing(int24 tickSpacing);
     error PoolInvalidFeeOrTickSpacing(uint24 fee, int24 tickSpacing);
     error PoolTickOutOfRange(int24 tick, int24 minTick, int24 maxTick);
+    error PoolInEmergencyState(PoolId poolId);
+    error PoolNotFound(PoolId poolId);
     
     // Liquidity errors
     error InsufficientAmount(uint256 requested, uint256 available);
@@ -124,4 +131,16 @@ library Errors {
     error TokenEthNotAccepted();
     error TokenInsufficientEth(uint256 required, uint256 provided);
     error TokenEthTransferFailed(address to, uint256 amount);
+
+    // Fee Reinvestment Manager Errors
+    error FeeExtractionFailed(string reason);
+    error InvalidPolPercentage(uint256 provided, uint256 min, uint256 max);
+    error PoolSpecificPolPercentageNotAllowed();
+    error InvalidFeeDistribution(uint256 polShare, uint256 lpShare, uint256 expected);
+    error PoolReinvestmentBlocked(PoolId poolId);
+    error CollectionIntervalTooShort(uint256 provided, uint256 minimum);
+    error CollectionIntervalTooLong(uint256 provided, uint256 maximum);
+    error CalculationError(string reason);
+    error HookCallbackFailed(string reason);
+    error FeesNotAvailable();
 } 
\ No newline at end of file
diff --git a/src/errors/errors.sol b/src/errors/errors.sol
index 8c18211..0c41293 100644
--- a/src/errors/errors.sol
+++ b/src/errors/errors.sol
@@ -18,7 +18,7 @@ library Errors {
     error Unauthorized();
     
     // Validation and input errors
-    error ValidationDeadlinePassed(uint32 deadline, uint32 timestamp);
+    error ValidationDeadlinePassed(uint32 deadline, uint32 blockTime);
     error ValidationZeroAddress(string target);
     error ValidationInvalidInput(string reason);
     error ValidationZeroAmount(string parameter);
@@ -131,4 +131,16 @@ library Errors {
     error TokenEthNotAccepted();
     error TokenInsufficientEth(uint256 required, uint256 provided);
     error TokenEthTransferFailed(address to, uint256 amount);
+
+    // Fee Reinvestment Manager Errors
+    error FeeExtractionFailed(string reason);
+    error InvalidPolPercentage(uint256 provided, uint256 min, uint256 max);
+    error PoolSpecificPolPercentageNotAllowed();
+    error InvalidFeeDistribution(uint256 polShare, uint256 lpShare, uint256 expected);
+    error PoolReinvestmentBlocked(PoolId poolId);
+    error CollectionIntervalTooShort(uint256 provided, uint256 minimum);
+    error CollectionIntervalTooLong(uint256 provided, uint256 maximum);
+    error CalculationError(string reason);
+    error HookCallbackFailed(string reason);
+    error FeesNotAvailable();
 } 
\ No newline at end of file
diff --git a/src/interfaces/IFeeReinvestmentManager.sol b/src/interfaces/IFeeReinvestmentManager.sol
index 3660a49..3bf7b7f 100644
--- a/src/interfaces/IFeeReinvestmentManager.sol
+++ b/src/interfaces/IFeeReinvestmentManager.sol
@@ -4,6 +4,7 @@ pragma solidity 0.8.26;
 import {PoolId} from "v4-core/src/types/PoolId.sol";
 import {PoolKey} from "v4-core/src/types/PoolKey.sol";
 import {IPoolPolicy} from "./IPoolPolicy.sol";
+import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
 
 /**
  * @title IFeeReinvestmentManager
@@ -20,6 +21,15 @@ interface IFeeReinvestmentManager {
      */
     event FeesReinvested(PoolId indexed poolId, uint256 fee0, uint256 fee1, uint256 investable0, uint256 investable1);
     
+    /**
+     * @notice Emitted when fees are extracted
+     * @param poolId The pool ID
+     * @param fee0 Amount of token0 fees
+     * @param fee1 Amount of token1 fees
+     * @param caller Address that triggered the extraction
+     */
+    event FeesExtracted(PoolId indexed poolId, uint256 fee0, uint256 fee1, address indexed caller);
+    
     /**
      * @notice Operation types for different reinvestment contexts
      */
@@ -29,6 +39,24 @@ interface IFeeReinvestmentManager {
         WITHDRAWAL 
     }
     
+    /**
+     * @notice Calculates the fee delta to extract for protocol purposes
+     * @param poolId The pool ID
+     * @param feesAccrued The total fees accrued
+     * @return The balance delta representing the portion to extract
+     */
+    function calculateExtractDelta(
+        PoolId poolId,
+        BalanceDelta feesAccrued
+    ) external view returns (BalanceDelta);
+    
+    /**
+     * @notice Permissionless function to collect and process accumulated fees
+     * @param poolId The pool ID to collect fees for
+     * @return extracted Whether fees were successfully extracted and processed
+     */
+    function collectAccumulatedFees(PoolId poolId) external returns (bool extracted);
+    
     /**
      * @notice Checks if reinvestment should be performed based on the current mode and conditions
      * @param poolId The pool ID
@@ -89,4 +117,19 @@ interface IFeeReinvestmentManager {
      * @return The cumulative fee multiplier
      */
     function cumulativeFeeMultiplier(PoolId poolId) external view returns (uint256);
+    
+    /**
+     * @notice Get the POL share percentage for a specific pool
+     * @param poolId The pool ID to get the POL share for
+     * @return The POL share in PPM (parts per million)
+     */
+    function getPolSharePpm(PoolId poolId) external view returns (uint256);
+
+    /**
+     * @notice Get information about leftover tokens from previous reinvestments
+     * @param poolId The pool ID
+     * @return leftover0 Leftover token0 amount
+     * @return leftover1 Leftover token1 amount
+     */
+    function getLeftoverTokens(PoolId poolId) external view returns (uint256 leftover0, uint256 leftover1);
 } 
\ No newline at end of file
diff --git a/src/interfaces/IFullRangeHooks.sol b/src/interfaces/IFullRangeHooks.sol
index ebea4c5..5c6be9c 100644
--- a/src/interfaces/IFullRangeHooks.sol
+++ b/src/interfaces/IFullRangeHooks.sol
@@ -70,6 +70,7 @@ interface IFullRangeHooks is IHooks {
      * @param key The key for the pool
      * @param params The parameters for removing liquidity
      * @param delta The caller's balance delta after removing liquidity
+     * @param feesAccrued The fees accrued during the operation
      * @param hookData Arbitrary data handed into the PoolManager by the liquidity provider
      * @return bytes4 The function selector for the hook
      * @return BalanceDelta The hook's delta in token0 and token1
@@ -79,6 +80,7 @@ interface IFullRangeHooks is IHooks {
         PoolKey calldata key,
         IPoolManager.ModifyLiquidityParams calldata params,
         BalanceDelta delta,
+        BalanceDelta feesAccrued,
         bytes calldata hookData
     ) external returns (bytes4, BalanceDelta);
 } 
\ No newline at end of file
diff --git a/test/GasBenchmarkTest.t.sol b/test/GasBenchmarkTest.t.sol
index ef4672b..72b1c04 100644
--- a/test/GasBenchmarkTest.t.sol
+++ b/test/GasBenchmarkTest.t.sol
@@ -28,7 +28,7 @@ contract GasBenchmarkTest is LocalUniswapV4TestBase {
     uint24 constant REGULAR_POOL_FEE = 3000;   // 0.3% fee for regular pool
     
     function setUp() public override {
-        // Call parent setUp to initialize the environment
+        // Call parent setUp to initialize the environment with the hook already deployed
         super.setUp();
         
         // Create a regular pool without hooks and tight tick spacing
@@ -42,14 +42,12 @@ contract GasBenchmarkTest is LocalUniswapV4TestBase {
         regularPoolId = regularPoolKey.toId();
         
         // Initialize the regular pool at the center of a tick space
-        vm.startPrank(deployer);
-        // Calculate center of a tick space for initialization
         int24 regularTickSpaceCenter = ((0 / REGULAR_TICK_SPACING) * REGULAR_TICK_SPACING) + (REGULAR_TICK_SPACING / 2);
         uint160 centerSqrtPriceX96 = TickMath.getSqrtPriceAtTick(regularTickSpaceCenter);
+        
+        vm.startPrank(deployer);
         poolManager.initialize(regularPoolKey, centerSqrtPriceX96);
         vm.stopPrank();
-        
-        // Note: The hooked pool is already initialized in the parent setUp
     }
     
     function test_compareAddLiquidity() public {
diff --git a/test/LocalUniswapV4TestBase.t.sol b/test/LocalUniswapV4TestBase.t.sol
index f7efd3e..89c84c1 100644
--- a/test/LocalUniswapV4TestBase.t.sol
+++ b/test/LocalUniswapV4TestBase.t.sol
@@ -223,7 +223,8 @@ abstract contract LocalUniswapV4TestBase is Test {
             Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG | 
             Hooks.AFTER_REMOVE_LIQUIDITY_FLAG | 
             Hooks.BEFORE_SWAP_FLAG | 
-            Hooks.AFTER_SWAP_FLAG
+            Hooks.AFTER_SWAP_FLAG |
+            Hooks.AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG
         );
 
         // Debug logs
@@ -237,9 +238,9 @@ abstract contract LocalUniswapV4TestBase is Test {
             address(dynamicFeeManager)
         );
         
-        // Mine for a hook address with the correct permission bits
+        // Mine for a hook address with the correct permission bits using the deployer address
         (address hookAddress, bytes32 salt) = HookMiner.find(
-            governance, // Using governance as the deployer instead of this contract
+            deployer, // Using deployer (instead of governance) as the deployer address
             flags,
             type(FullRange).creationCode,
             constructorArgs
@@ -248,42 +249,31 @@ abstract contract LocalUniswapV4TestBase is Test {
         console2.log("Mined hook address:", hookAddress);
         console2.log("Permission bits in address:", uint160(hookAddress) & Hooks.ALL_HOOK_MASK);
         
-        // Debug the governance and deployment information
-        console2.log("== Debug governance information ==");
+        // Debug governance information to help diagnose the issue
+        console2.log("== Debug deployment information ==");
         console2.log("This contract address:", address(this));
         console2.log("Current sender:", msg.sender);
-        console2.log("Policy manager address:", address(policyManager));
-        address currentGovernance = policyManager.getSoloGovernance();
-        console2.log("Current governance address:", currentGovernance);
+        console2.log("Deployer address:", deployer);
         
-        // Deploy from governance account
+        // Make sure we're using the deployer address for deployment
         vm.stopPrank();
-        vm.startPrank(governance); // Use governance account to deploy
+        vm.startPrank(deployer);
+        console2.log("Deploying hook from:", msg.sender);
         
-        // Deploy the hook with the mined salt
-        console2.log("Deploying hook from:", governance);
-        FullRange hook = new FullRange{salt: salt}(
+        // Deploy the hook using CREATE2 with the found salt
+        FullRange hookContract = new FullRange{salt: salt}(
             poolManager,
             IPoolPolicy(address(policyManager)),
             liquidityManager,
             dynamicFeeManager
         );
         
-        // Reset back to original sender
-        vm.stopPrank();
-        vm.startPrank(msg.sender);
-        
-        // Verify the deployment
-        address actualAddress = address(hook);
-        console2.log("Actual deployed hook address:", actualAddress);
-        console2.log("Permission bits in deployed address:", uint160(actualAddress) & Hooks.ALL_HOOK_MASK);
-        console2.log("Salt used:", uint256(salt));
+        // Ensure the deployed address matches the mined address
+        require(address(hookContract) == hookAddress, "Hook address mismatch");
         
-        // Verify hook address
-        require(actualAddress == hookAddress, "Hook address mismatch");
-        require((uint160(actualAddress) & Hooks.ALL_HOOK_MASK) == flags, "Hook permission bits mismatch");
+        // Already pranking as deployer, no need to change
         
-        return address(hook);
+        return hookAddress;
     }
 
     /**
diff --git a/test/SimpleV4Test.t.sol b/test/SimpleV4Test.t.sol
index 393f62c..27f177e 100644
--- a/test/SimpleV4Test.t.sol
+++ b/test/SimpleV4Test.t.sol
@@ -1,9 +1,28 @@
 // SPDX-License-Identifier: BUSL-1.1
 pragma solidity 0.8.26;
 
-import "./LocalUniswapV4TestBase.t.sol";
-import "forge-std/console2.sol";
-// Import the necessary structs from FullRange interfaces
+import {Test} from "forge-std/Test.sol";
+import {console2} from "forge-std/Console2.sol";
+import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
+import {PoolManager} from "v4-core/src/PoolManager.sol";
+import {PoolKey} from "v4-core/src/types/PoolKey.sol";
+import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
+import {Hooks} from "v4-core/src/libraries/Hooks.sol";
+import {IHooks} from "v4-core/src/interfaces/IHooks.sol";
+import {Currency, CurrencyLibrary} from "v4-core/src/types/Currency.sol";
+import {PoolSwapTest} from "v4-core/src/test/PoolSwapTest.sol";
+import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
+import {TickMath} from "v4-core/src/libraries/TickMath.sol";
+import {HookMiner} from "../src/utils/HookMiner.sol";
+import {MockERC20} from "solmate/src/test/utils/mocks/MockERC20.sol";
+
+import {FullRange} from "../src/FullRange.sol";
+import {FullRangeLiquidityManager} from "../src/FullRangeLiquidityManager.sol";
+import {FullRangeDynamicFeeManager} from "../src/FullRangeDynamicFeeManager.sol";
+import {PoolPolicyManager} from "../src/PoolPolicyManager.sol";
+import {DefaultCAPEventDetector} from "../src/DefaultCAPEventDetector.sol";
+import {ICAPEventDetector} from "../src/interfaces/ICAPEventDetector.sol";
+import {IPoolPolicy} from "../src/interfaces/IPoolPolicy.sol";
 import {DepositParams, WithdrawParams} from "../src/interfaces/IFullRange.sol";
 
 /**
@@ -11,12 +30,163 @@ import {DepositParams, WithdrawParams} from "../src/interfaces/IFullRange.sol";
  * @notice A simple test suite that verifies basic Uniswap V4 operations with our hook
  * @dev This file MUST be compiled with Solidity 0.8.26 to ensure hook address validation works correctly
  */
-contract SimpleV4Test is LocalUniswapV4TestBase {
-    function setUp() public override {
-        console2.log("SimpleV4Test: Beginning setup");
+contract SimpleV4Test is Test {
+    using PoolIdLibrary for PoolKey;
+    using CurrencyLibrary for Currency;
+
+    PoolManager poolManager;
+    FullRange fullRange;
+    FullRangeLiquidityManager liquidityManager;
+    FullRangeDynamicFeeManager dynamicFeeManager;
+    PoolPolicyManager policyManager;
+    DefaultCAPEventDetector capEventDetector;
+    PoolSwapTest swapRouter;
+
+    // Test tokens
+    MockERC20 token0;
+    MockERC20 token1;
+    PoolKey poolKey;
+    PoolId poolId;
+
+    address payable alice = payable(address(0x1));
+    address payable bob = payable(address(0x2));
+    address payable charlie = payable(address(0x3));
+    address payable deployer = payable(address(0x4));
+    address payable governance = payable(address(0x5));
+
+    function setUp() public {
+        // Deploy PoolManager
+        poolManager = new PoolManager(address(this));
+
+        // Deploy test tokens
+        token0 = new MockERC20("Test Token 0", "TEST0", 18);
+        token1 = new MockERC20("Test Token 1", "TEST1", 18);
+
+        // Ensure token0 address is less than token1
+        if (address(token0) > address(token1)) {
+            (token0, token1) = (token1, token0);
+        }
+
+        // Deploy policy manager with configuration
+        uint24[] memory supportedTickSpacings = new uint24[](3);
+        supportedTickSpacings[0] = 10;
+        supportedTickSpacings[1] = 60;
+        supportedTickSpacings[2] = 200;
+
+        policyManager = new PoolPolicyManager(
+            governance,
+            500000, // POL_SHARE_PPM (50%)
+            300000, // FULLRANGE_SHARE_PPM (30%)
+            200000, // LP_SHARE_PPM (20%)
+            100,    // MIN_TRADING_FEE_PPM (0.01%)
+            1000,   // FEE_CLAIM_THRESHOLD_PPM (0.1%)
+            2,      // DEFAULT_POL_MULTIPLIER
+            3000,   // DEFAULT_DYNAMIC_FEE_PPM (0.3%)
+            10,     // TICK_SCALING_FACTOR
+            supportedTickSpacings
+        );
+
+        // Deploy CAP Event Detector
+        capEventDetector = new DefaultCAPEventDetector(poolManager, governance);
+
+        // Deploy Liquidity Manager
+        liquidityManager = new FullRangeLiquidityManager(poolManager, governance);
+
+        // We need to create a temporary address for FullRange since the constructor requires a non-zero address
+        address tempFullRangeAddress = address(1);
         
-        // Call the parent setUp to initialize the environment
-        super.setUp();
+        // Deploy Dynamic Fee Manager with temporary FullRange address
+        dynamicFeeManager = new FullRangeDynamicFeeManager(
+            governance,
+            IPoolPolicy(address(policyManager)),
+            poolManager,
+            tempFullRangeAddress, // temporary address - will be updated after FullRange deployment
+            ICAPEventDetector(address(capEventDetector))
+        );
+
+        // Calculate required hook flags
+        uint160 flags = uint160(
+            Hooks.BEFORE_INITIALIZE_FLAG | 
+            Hooks.AFTER_INITIALIZE_FLAG | 
+            Hooks.BEFORE_ADD_LIQUIDITY_FLAG | 
+            Hooks.AFTER_ADD_LIQUIDITY_FLAG |
+            Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG |
+            Hooks.AFTER_REMOVE_LIQUIDITY_FLAG |
+            Hooks.BEFORE_SWAP_FLAG | 
+            Hooks.AFTER_SWAP_FLAG |
+            Hooks.AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG
+        );
+
+        // Prepare constructor arguments
+        bytes memory constructorArgs = abi.encode(
+            address(poolManager),
+            IPoolPolicy(address(policyManager)),
+            address(liquidityManager),
+            address(dynamicFeeManager)
+        );
+
+        // Mine for a hook address with the correct permission bits
+        (address hookAddress, bytes32 salt) = HookMiner.find(
+            governance,
+            flags,
+            type(FullRange).creationCode,
+            constructorArgs
+        );
+
+        console2.log("Mined hook address:", hookAddress);
+        console2.log("Permission bits in address:", uint160(hookAddress) & Hooks.ALL_HOOK_MASK);
+
+        // Deploy from governance account
+        vm.startPrank(governance);
+
+        // Deploy the hook with the mined salt
+        fullRange = new FullRange{salt: salt}(
+            poolManager,
+            IPoolPolicy(address(policyManager)),
+            liquidityManager,
+            dynamicFeeManager
+        );
+
+        // Verify the deployment
+        require(address(fullRange) == hookAddress, "Hook address mismatch");
+        require((uint160(address(fullRange)) & Hooks.ALL_HOOK_MASK) == flags, "Hook permission bits mismatch");
+
+        // Update managers with correct FullRange address
+        liquidityManager.setFullRangeAddress(address(fullRange));
+        
+        // Redeploy the dynamic fee manager with the correct FullRange address
+        dynamicFeeManager = new FullRangeDynamicFeeManager(
+            governance,
+            IPoolPolicy(address(policyManager)),
+            poolManager,
+            address(fullRange),  // Now using the actual FullRange address
+            ICAPEventDetector(address(capEventDetector))
+        );
+
+        vm.stopPrank();
+
+        // Deploy swap router
+        swapRouter = new PoolSwapTest(IPoolManager(address(poolManager)));
+
+        // Initialize pool
+        poolKey = PoolKey({
+            currency0: Currency.wrap(address(token0)),
+            currency1: Currency.wrap(address(token1)),
+            fee: 3000,
+            tickSpacing: 60,
+            hooks: IHooks(address(fullRange))
+        });
+
+        poolId = poolKey.toId();
+
+        // Initialize pool with sqrt price of 1
+        poolManager.initialize(poolKey, 79228162514264337593543950336);
+
+        // Mint test tokens to users
+        token0.mint(alice, 1e18);
+        token1.mint(alice, 1e18);
+        token0.mint(bob, 1e18);
+        token1.mint(bob, 1e18);
     }
     
     /**
@@ -83,7 +253,7 @@ contract SimpleV4Test is LocalUniswapV4TestBase {
      */
     function test_swap() public {
         // ======================= ARRANGE =======================
-        // First add liquidity to enable swapping - a pool needs liquidity to facilitate swaps
+        // First add liquidity to enable swapping
         uint128 liquidityAmount = 1e9;
         
         // Approve tokens for the FullRange hook and deposit
@@ -109,23 +279,34 @@ contract SimpleV4Test is LocalUniswapV4TestBase {
         vm.startPrank(bob);
         token0.approve(address(poolManager), type(uint256).max);
         token1.approve(address(poolManager), type(uint256).max);
-        // Also approve tokens to the swapRouter (PoolSwapTest) since it calls transferFrom directly
         token0.approve(address(swapRouter), type(uint256).max);
         token1.approve(address(swapRouter), type(uint256).max);
         vm.stopPrank();
         
-        // Record Bob's initial token balances before the swap
+        // Record Bob's initial token balances
         uint256 bobToken0Before = token0.balanceOf(bob);
         uint256 bobToken1Before = token1.balanceOf(bob);
         console2.log("Bob token0 balance before swap:", bobToken0Before);
         console2.log("Bob token1 balance before swap:", bobToken1Before);
         
         // ======================= ACT =======================
-        // Perform a swap: Bob trades token0 for token1
-        // Use a small amount to avoid overflow issues
+        // Perform swap: token0 -> token1
         uint256 swapAmount = 1e8;
         
-        swapExactInput(bob, true, swapAmount);
+        vm.startPrank(bob);
+        IPoolManager.SwapParams memory swapParams = IPoolManager.SwapParams({
+            zeroForOne: true,
+            amountSpecified: int256(swapAmount),
+            sqrtPriceLimitX96: TickMath.MIN_SQRT_PRICE + 1
+        });
+
+        PoolSwapTest.TestSettings memory testSettings = PoolSwapTest.TestSettings({
+            takeClaims: false,
+            settleUsingBurn: false
+        });
+
+        swapRouter.swap(poolKey, swapParams, testSettings, "");
+        vm.stopPrank();
         
         // ======================= ASSERT =======================
         // Record Bob's token balances after the swap
@@ -134,12 +315,9 @@ contract SimpleV4Test is LocalUniswapV4TestBase {
         console2.log("Bob token0 balance after swap:", bobToken0After);
         console2.log("Bob token1 balance after swap:", bobToken1After);
         
-        // Verify the swap executed correctly:
-        // 1. Bob should have spent some amount of token0 (which includes the swap fee)
+        // Verify the swap executed correctly
         assertTrue(bobToken0Before > bobToken0After, "Bob should have spent some token0");
-        // 2. Bob should have received some amount of token1 in return
-        assertTrue(bobToken1After > bobToken1Before, "Bob should have received some token1 in exchange");
-        // 3. Verify Bob received exactly the specified amount of token1
+        assertTrue(bobToken1After > bobToken1Before, "Bob should have received some token1");
         assertEq(bobToken1After - bobToken1Before, swapAmount, "Bob should have received exactly the swap amount of token1");
     }
 } 
\ No newline at end of file
